[
  {
    "text": "from manim import *\n\n\nclass Main(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = Cylinder(radius=2, height=3)\n        name = Text(\"Kiron\").scale(2).shift(UP)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=20 * DEGREES)\n        self.play(Create(cylinder, run_time=3))\n        self.play(FadeOut(cylinder))\n        self.play(DrawBorderThenFill(axes))\n        self.play(Write(name))"
  },
  {
    "text": "from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        t = Text(\"Kiron\").shift(UP * 2).shift(LEFT)\n        t2 = Text(\"Tisha\").shift(DOWN * 2).shift(RIGHT)\n        a1 = Arrow(start=t.get_corner(DOWN), end=t2.get_corner(UP))\n        self.play(Write(t), GrowArrow(a1), Create(t2), run_time=3)\n        self.wait()\n        g1 = Group(t, t2, a1)\n        self.play(g1.animate.scale(1.5))\n        self.wait()\n        self.play(t2.animate.shift(UP * 2))\n        self.play(a1.animate.put_start_and_end_on(start=t.get_corner(DOWN), end=t2.get_corner(UP)))\n        self.wait()"
  },
  {
    "text": "import math\n\nfrom manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        # Background.\n        # background = ImageMobject(\"sea.jpg\")\n        background = Rectangle(height=config.frame_height, width=config.frame_width). \\\n            set_color([TEAL, BLUE, GREEN]). \\\n            set_opacity(0.7)\n        self.play(FadeIn(background), run_time=1)\n        self.bring_to_back(background)\n\n        # Default starting wait.\n        self.wait(0.5)\n\n        name = Text(\"Hello Kiron.\", color=BLUE)\n        self.play(Write(name), run_time=3)\n        self.play(Indicate(name))\n\n        # Default ending wait.\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        chart = BarChart(\n            values=[-5, 40, -10, 20, -3],\n            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n            y_range=[-20, 50, 10],\n            y_length=6,\n            x_length=10,\n            x_axis_config={\"font_size\": 36},\n        )\n\n        c_bar_lbls = chart.get_bar_labels(font_size=48)\n        self.add(chart, c_bar_lbls)"
  },
  {
    "text": "from manim import *\n\nimport numpy as np\n\n\nclass Shape(Scene):\n    def construct(self):\n        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\n        position_list = [\n            [4, 1, 0],  # middle right\n            [4, -2.5, 0],  # bottom right\n            [0, -2.5, 0],  # bottom left\n            [0, 3, 0],  # top left\n            [2, 1, 0],  # middle\n            [4, 3, 0],  # top right\n        ]\n        square_and_triangles = Polygon(*position_list, color=PURPLE_B)\n        self.add(isosceles, square_and_triangles)\n        myC=Circle()"
  },
  {
    "text": "# Implement Animation for this mobject.\nfrom abc import ABC\n\nfrom manim import *\n\n\nclass IndexPositionError(Exception):\n    def __str__(self):\n        return \"'index_pos' should be either 'UP' or 'DOWN'\"\n\n\n# Extend from VMobject cause no other has defined animations.\n# Don't extend from Mobject directly because of Mobject is abstract.\nclass Array(VMobject):\n    def __init__(\n            self,\n            entries: Mobject | str = [],\n            show_index: bool = True,\n            start_index: int = 0,\n            index_step: int = 1,\n            index_pos: np.ndarray = UP,\n            index_color: color = WHITE,\n            box_height: float = 1.0,\n            box_width: float = 1.0,\n            box_color: color = YELLOW,\n            entry_color: color = PURE_BLUE,\n            stroke_width: float = 1.5\n    ):\n        self.length = len(entries)\n        self.entries = entries\n        super().__init__()\n\n        if index_pos is not UP and index_pos is not DOWN:\n            raise IndexPositionError()\n\n        # boxes\n        self.base_box = Rectangle(height=box_height, width=box_width, stroke_width=stroke_width, stroke_color=box_color)\n        self.boxes = Group(*[self.base_box.copy() for i in range(0, self.length)]).arrange(buff=0)\n\n        # indices\n        if show_index:\n            self.indices = []\n            count = 0\n            while count < self.length:\n                self.indices.append(Tex(f\"${start_index}$\", color=index_color))\n                start_index += index_step\n                count += 1\n            for i in range(0, self.length, 1):\n                self.indices[i].scale(box_height * 0.7)\n                self.indices[i].next_to(self.boxes[i], index_pos, buff=MED_SMALL_BUFF)\n\n        # entries, must be a list of Mobjects or str.\n        for i in range(0, self.length, 1):\n            if type(self.entries[i]) is str:\n                self.entries[i] = Text(f\"{self.entries[i]}\")\n            self.entries[i]. \\\n                set_color(entry_color). \\\n                scale_to_fit_height(box_height * 0.70). \\\n                scale_to_fit_width(box_width * 0.82). \\\n                move_to(self.boxes[i])\n\n        # adding all submobjects\n        if show_index:\n            self.add(*self.indices)\n        self.add(*self.boxes)\n        self.add(*self.entries)\n        self.move_to(ORIGIN)\n\n\nclass Pointer(VMobject):\n    def __init__(self):\n        super().__init__()\n        pass\n\n\nclass Main(Scene):\n    def construct(self):\n        a = Array([\"Kiron\", \"Nirob\", \"Israt\"], start_index=2, index_pos=RIGHT)\n        self.play(Create(a, run_time=8))"
  },
  {
    "text": "from manim import *\n\ntbox = r'''\n\\newtcolorbox{mybox}{colback=red!5!white, colframe=red!75!black, width=8cm}\n\\begin{mybox}\n    \\textcolor{black}{This is my own box.}\n\\end{mybox}\n'''\n\n\nclass Main(Scene):\n    def construct(self):\n        self.wait(0.5)\n\n        # self.camera.background_color = WHITE\n        # Basic self settings.\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{tcolorbox, tikz}\")\n\n        self.always_update_mobjects = True\n        box = Tex(tbox, tex_template=myTemplate)\n\n        theBox = SVGMobject(\"box.svg\").scale(0.5)\n        self.play(DrawBorderThenFill(theBox), run_time=3)\n        self.play(Indicate(theBox, color=theBox.get_color()))\n\n        self.wait()\n\n\nclass AtomSVG(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        apple = SVGMobject(\"apple.svg\").scale(2)\n        self.play(Create(apple), run_time=3)\n        self.play(apple.animate.scale(0.5))\n\n        self.wait(2)\n\n\nclass LogoAnimate(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        self.wait(0.5)\n\n        react = SVGMobject(\"react logo.svg\", height=2.2, width=2.2).shift(LEFT * 5)\n        angular = SVGMobject(\"angular logo.svg\", height=2.2, width=2.2).next_to(react, RIGHT * 5)\n        vue = SVGMobject(\"vue logo.svg\", height=2.2, width=2.2).next_to(angular, RIGHT * 5)\n\n        g1 = Group(react, angular, vue).move_to(ORIGIN)\n\n        for fra in g1:\n            self.add_sound(\"grow sound.mp3\", gain=1.5)\n            self.play(GrowFromPoint(fra, fra.get_center()), run_time=0.5)\n            self.wait(1)\n\n        self.wait(3)\n\n        self.play(FadeOut(Group(angular, vue), run_time=0.6), react.animate.move_to(ORIGIN).scale(2))\n        self.play(Circumscribe(react))\n        self.wait(3)\n\n\nclass QuotedText(Scene):\n    def construct(self):\n        self.wait(0.5)\n\n        text = r'''\n        A REST API should spend almost all of its descriptive effort\n        \\linebreak\n        in defining the media type(s) used for representing resources\n        \\linebreak\n        and driving application state.\n        '''\n        quote = Tex(text)\n        quoter = Text(\"- Roy Fielding\").next_to(quote, DOWN).shift(RIGHT * 4)\n        self.play(Write(quote, run_time=4))\n        self.play(Create(quoter, run_time=2))\n        self.wait(2)\n        self.play(Unwrite(quote), FadeOut(quoter))"
  },
  {
    "text": "from manim import *\nfrom manim_physics import *\n\n# use a SpaceScene to utilize all specific rigid-mechanics methods\n\n\nclass TwoObjectsFalling(SpaceScene):\n    def construct(self):\n        circle = Circle().shift(UP)\n        circle.set_fill(RED, 1)\n        circle.shift(DOWN + RIGHT)\n\n        rect = Square().shift(UP)\n        rect.rotate(PI / 4)\n        rect.set_fill(YELLOW_A, 1)\n        rect.shift(UP * 2)\n        rect.scale(0.5)\n\n        ground = Line([-4, -3.5, 0], [4, -3.5, 0])\n        wall1 = Line([-4, -3.5, 0], [-4, 3.5, 0])\n        wall2 = Line([4, -3.5, 0], [4, 3.5, 0])\n        walls = VGroup(ground, wall1, wall2)\n        self.add(walls)\n\n        self.play(\n            DrawBorderThenFill(circle),\n            DrawBorderThenFill(rect),\n        )\n        self.make_rigid_body(rect, circle)  # Mobjects will move with gravity\n        self.make_static_body(walls)  # Mobjects will stay in place\n        self.wait(5)\n        # during wait time, the circle and rect would move according to the simulate updater"
  },
  {
    "text": "from manim import *\nfrom manim_voiceover import *\nfrom manim_voiceover.services.gtts import GTTSService\n\nText.set_default(color=BLACK)\nTex.set_default(color=BLACK)\n\n\nclass Main(VoiceoverScene):\n    def construct(self):\n        self.add_sound(\"vhs-startup-6088.mp3\", gain=1.1)\n        # Background.\n        background = Rectangle(height=config.frame_height, width=config.frame_width). \\\n            set_color([TEAL, BLUE, GREEN]). \\\n            set_opacity(0.7)\n        self.play(FadeIn(background, run_time=1.5))\n        self.bring_to_back(background)\n\n        # Default starting wait.\n        self.wait(1)\n\n        # Voiceover setting.\n        self.set_speech_service(GTTSService())\n\n        pi = Tex(r\"$\\pi$\").scale(2.5)\n        pi_text = Text(\"PI, which is an interesting irrational constant.\").next_to(pi, DOWN, buff=0.7)\n        g1 = Group(pi, pi_text).move_to(ORIGIN)\n\n        speech_text = \"Pi, an interesting irrational constant used by mathematicians, scientist, engineers \" \\\n                      \"and also by other stuffs.\"\n\n        with self.voiceover(text=speech_text) as tracker:\n            self.play(Create(pi))\n            self.play(Write(pi_text))\n\n        pi_value = Tex(r\"\\begin{center}$3.14159265358$ \\dots \\linebreak and million lines more\\end{center}\", color=WHITE).scale(2.4)\n\n        with self.voiceover(text=\"It has a robust value.\") as tracker:\n            self.play(FadeOut(background), Transform(g1, pi_value), run_time=1.3)\n\n        # Default ending wait.\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        self.wait()\n\n        a = RegularPolygon(n=10, color=BLUE_E)\n        b = RegularPolygon(n=11, color=YELLOW)\n        c = RegularPolygon(n=12, color=WHITE)\n        d = RegularPolygon(n=30, color=GREEN_C).next_to(c, RIGHT)\n\n        g1 = Group(a, b, c).arrange(RIGHT, 0.75)\n        self.play(Create(a))\n        self.play(Transform(a.copy(), b))\n        self.play(Transform(b.copy(), c))\n        self.clear()\n        self.play(Create(d))\n\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        def update_label_text(object):\n            object.set(text=str(cnt))\n            object.next_to(dot, UP)\n            cnt += 1\n\n        cnt = 1\n        dot = Dot(ORIGIN)\n        label = Text(str(dot.get_x())).next_to(dot, UP)\n        label.add_updater(update_label_text)\n        self.add(label)\n        self.play(dot.animate.move_to(UL*3))\n        self.play(dot.animate.move_to(DOWN*3))"
  },
  {
    "text": "from manim import *\n\n# VoiceOver imports\nfrom manim_voiceover import VoiceoverScene\nfrom manim_voiceover.services.gtts import GTTSService\nfrom manim_voiceover.services.azure import AzureService\n\n\nclass FourierSeries(VoiceoverScene):\n    def construct(self):\n        # Basic self settings.\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{csquotes}\")\n        # self.add(NumberPlane())\n        self.always_update_mobjects = True\n        self.set_speech_service(AzureService(voice=\"en-GB-OliverNeural\", style=\"newscast-casual\"))\n        # self.set_speech_service(GTTSService())\n\n        ourBasicTrigonometricSeriesIs = Text(text=\"We know that the basic trigonometric series is: \", font=\"Arial\",\n                                             font_size=52, weight=SEMIBOLD, width=12, color=GREEN)\n        theBasicTrigonometricEquation = MathTex(r\"\\frac{A_0}{2} + \\sum_{n=1}^{\\infty} (A_n\\cos nx + B_n\\sin nx)\",\n                                                font_size=48)\n        g1 = Group(ourBasicTrigonometricSeriesIs, theBasicTrigonometricEquation).arrange(DOWN, buff=MED_LARGE_BUFF)\n\n        with self.voiceover(text=\"We know that the basic trigonometric series is...\") as tracker:\n            self.play(AddTextLetterByLetter(ourBasicTrigonometricSeriesIs), run_time=tracker.duration / 1.8)\n\n        with self.voiceover(text=\"the equation appearing on the screen.\") as tracker:\n            self.play(FadeIn(theBasicTrigonometricEquation), run_time=tracker.duration / 1.5)\n\n        self.play(g1.animate.scale(0.65).shift(2.9 * UP), run_time=0.8)\n\n        itWillCalled = Tex(\n            r'This equation will be called \\textbf{\\enquote{Fourier Series}} if the terms $A_0, A_n, B_n$ could be substituted into:',\n            tex_template=myTemplate, font_size=34)\n        A0 = MathTex(r\"A_0 = \\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot dx\", font_size=40)\n        An = MathTex(r\"A_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot \\cos nx\\cdot dx\", font_size=40)\n        Bn = MathTex(r\"B_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot \\sin nx\\cdot dx\", font_size=40)\n        g2 = Group(A0, An, Bn).arrange(DOWN, buff=MED_SMALL_BUFF).move_to(0.5 * DOWN)\n        whereFX = Tex(r\"Where \\textbf{$f(x)$} is any single-valued function defined in interval $(-\\pi, \\pi)$.\",\n                      font_size=35).next_to(g2, 1 * DOWN)\n\n        with self.voiceover(\n                text=\"This equation will be called \\\"Fourier Series\\\" if the terms, A nought, A N, B N could be substituted into\") as tracker:\n            self.play(Create(itWillCalled), run_time=tracker.duration / 1.2)\n\n        self.play(itWillCalled.animate.scale(0.7).next_to(g2, 1.3 * UP), run_time=0.3)\n        self.play(itWillCalled.animate.set_fill(RED), SpinInFromNothing(g2), point_color=RED, run_time=0.8)\n\n        with self.voiceover(text=\"these equations.\") as tracker:\n            self.play(Indicate(g2), run_time=tracker.duration)\n\n        with self.voiceover(\n                text=\"Where F of x is any single valued function defined in the exclusive interval from minus pai to pai.\") as tracker:\n            self.play(Write(whereFX), run_time=tracker.duration / 1.8)\n\n        self.play(whereFX.animate(run_time=1.2).shift(0.5 * DOWN).scale(1.15))\n\n        with self.voiceover(text=\"Thank you for watching.\") as tracker:\n            self.play(Circumscribe(whereFX), run_time=tracker.duration * 1.2)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\n\n# All manim class must inherit Scence, cause all the things will be a scence.\nclass squareToCircle(Scene):\n    def construct(self):\n        s = Square().rotate(PI/4)\n        c = Circle()\n\n        # Playing animation.\n        self.play(Create(s))\n        self.play(Transform(s, c), run_time=5)\n        self.play(FadeOut(s))"
  },
  {
    "text": "        self.play(Transform(text,Text(\"Create\").shift(UP*2.5)), run_time=0.5)\n        start = Star()\n        self.play(Create(start))\n        self.play(Transform(text,Text(\"Uncreate\").shift(UP*2.5)), run_time=0.5)\n        self.play(Uncreate(start))"
  },
  {
    "text": "        self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n        circle = Circle()\n        animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n        self.add(circle, animated_boundary)\n        self.wait(2)\n        self.remove(circle, animated_boundary)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"TracedPath\").shift(UP*2.5)), run_time=0.5)\n        dot = Dot(color=RED)\n        trace = TracedPath(dot.get_center)\n        self.add(dot, trace)\n        self.wait(0.5)\n        self.play(dot.animate.shift(UP), run_time=0.5)\n        self.play(dot.animate.shift(LEFT), run_time=0.5)\n        self.play(dot.animate.shift(DOWN+RIGHT), run_time=0.5)\n        self.remove(dot, trace)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"AddTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Here is a text\")\n        self.play(AddTextLetterByLetter(some_text))\n        self.play(Transform(text,Text(\"RemoveTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n        self.play(RemoveTextLetterByLetter(some_text))"
  },
  {
    "text": "        self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Here is more text\")\n        self.play(Write(some_text))\n        self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n        self.play(Unwrite(some_text))\n        self.remove(some_text)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"DrawBorderThenFill\").shift(UP*2.5)), run_time=0.5)\n        square = Square(color=BLUE, fill_opacity=1).set_fill(YELLOW)\n        self.play(DrawBorderThenFill(square))\n        self.remove(square)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"ShowSubmobjectsOneByOne\").shift(UP*2.5)), run_time=0.5)\n        circles2 = VGroup(\n            Circle().shift(UP*0.5),\n            Circle().shift((DOWN+LEFT)*0.5),\n            Circle().shift((DOWN+RIGHT)*0.5)\n        )\n        self.play(ShowSubmobjectsOneByOne(circles2))\n        self.play(Uncreate(circles2))"
  },
  {
    "text": "        self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n        square = Square()\n        self.play(FadeIn(square))\n        self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n        self.play(FadeOut(square))\n        self.remove(square)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n        arrow = Arrow()\n        self.play(GrowArrow(arrow))\n        self.remove(arrow)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n        triangle = Triangle()\n        self.play(GrowFromCenter(triangle))\n        self.remove(triangle)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"GrowFromEdge - DOWN\").shift(UP*2.5)), run_time=0.5)\n        squares = [Square() for _ in range(4)]\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(Transform(text,Text(\"GrowFromEdge - RIGHT\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(Transform(text,Text(\"GrowFromEdge - UP\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[2], UP))\n        self.play(Transform(text,Text(\"GrowFromEdge - LEFT\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[3], LEFT))\n        self.remove(*squares)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"GrowFromPoint\").shift(UP*2.5)), run_time=0.5)\n        dot = Dot().shift(UP+RIGHT*2)\n        star = Star()\n        self.add(dot)\n        self.wait(0.5)\n        self.play(GrowFromPoint(star, dot))\n        self.remove(dot, star)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"SpinInFromNothing\").shift(UP*2.5)), run_time=0.5)\n        triangle = Triangle()\n        self.play(SpinInFromNothing(triangle))\n        self.remove(triangle)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Mathematical Animations\")\n        self.play(ApplyWave(some_text))\n        self.play(ApplyWave(some_text, direction=RIGHT))\n        self.remove(some_text)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"Circumscribe\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Look Here\")\n        self.add(some_text)\n        self.play(Circumscribe(some_text))\n        self.play(Circumscribe(some_text, Circle))\n        self.remove(some_text)"
  },
  {
    "text": "        self.play(Transform(text,Text(\"Flash\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Ta Da\").set_color(YELLOW)\n        self.add(some_text)\n        self.play(Flash(some_text))\n        self.remove(some_text)"
  },
  {
    "text": "from manim import * \nimport numpy as np\n\nclass AllMObjects(ThreeDScene):\n    def construct(self):\n        t = Text(\"Manim Objects\")\n        t.shift(UP*2.5)\n\n        mobject_list = [\n            # Geometry\n            Annulus(),\n            AnnularSector(),\n            Arc(),\n            Circle(),\n            Dot(),\n            Ellipse(),\n            Arrow(),\n            Vector(),\n            Square(),\n            Star(),\n            Triangle(),\n            ArrowCircleTip(),\n            \n            # Frame\n            FullScreenRectangle(),\n            ScreenRectangle(),\n\n            # Graph\n            Graph(vertices=(1,2,3,4,5), edges=[(1,2), (1,3), (4,2), (3,5), (1,5)]),\n\n            # Graphing\n            Axes(),\n            ComplexPlane(),\n            CoordinateSystem(),\n            NumberPlane(),\n            FunctionGraph(lambda x: (-1.0*x)**2),\n            NumberLine(),\n            BarChart(values=[1,2,3,4,5]),\n\n            # Logo\n            ManimBanner(),\n\n            # Matrix\n            DecimalMatrix([[1.0,2.0],[3.0,4.0]]),\n            IntegerMatrix([[1,2],[3,4]]),\n            Matrix([[1,2],[3,4]]),\n            MobjectMatrix([[Circle(),Square()],[Star(),Triangle()]]),\n\n            # Table\n            DecimalTable([[1,2,3,4], [5,6,7,8]], row_labels=[Text(\"Row 1\"), Text(\"Row 2\")]),\n            MathTable([[\"+\", 0, 5, 10],[0, 0, 5, 10],[2, 2, 7, 12],[4, 4, 9, 14]],include_outer_lines=True),\n            MobjectTable( [ [Circle(), Square()] , [Triangle(), Star()] ] ),\n\n            # Text\n            Code(file_name=\"dummy.py\", language=\"Python\"),\n            DecimalNumber(5.5),\n            Integer(5),\n            BulletedList(\"Apple\", \"Pear\", \"Grape\"),\n            MathTex(r\"\\frac{a}{b} = x^{2}\"),\n            SingleStringMathTex(r\"\\frac{a}{b} = x^{2}\"),\n            Tex(\"Hello World\"),\n            Title(\"Here Is a Ttitle\"),\n            MarkupText('<span foreground=\"red\" size=\"x-large\">Red text</span> is <i>fire</i>!\"'),\n            Paragraph('There once was a man', 'that lived in a van', 'with only one right hand'),\n            Text(\"Here is Text\"),\n\n            # Types\n            Point(color=RED),\n            PointCloudDot(),\n        ]\n\n        mobject_list_3d = [\n            ThreeDAxes(),\n            Dodecahedron(),\n            Icosahedron(),\n            Octahedron(),\n            Tetrahedron(edge_length=2),\n            Arrow3D(),\n            Cone(),\n            Cube(),\n            Cylinder(),\n            Dot3D(),\n            Line3D(start=np.array([-3,-3,-3]), end=np.array([3,3,3])),\n            Prism(),\n            Sphere(),\n            Torus(),\n        ]\n\n        # Show all 2D MObjects\n        self.add(t)\n        self.wait(0.2)\n        for mobj in mobject_list:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(0.5)\n                self.remove(mobj)\n            except:\n                continue\n        \n        # Show all 3D MObjects\n        self.play(Transform(t,Text(\"Looking at 3D Mobjects...\").shift(UP*2.5)), run_time=0.5)\n        self.wait(1)\n\n        self.begin_3dillusion_camera_rotation(rate=4)\n        self.wait(2)\n\n        for mobj in mobject_list_3d:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(1)\n                self.remove(mobj)\n            except:\n                continue\n        self.play(FadeOut(t))\n        self.wait()"
  },
  {
    "text": "class FirstExample(Scene):\n    def construct(self):\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        green_square = Square(color=GREEN, fill_opacity=0.8)\n        green_square.next_to(blue_circle, RIGHT)\n        self.add(blue_circle, green_square)"
  },
  {
    "text": "class SecondExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(-3, 3), y_range=(-3, 3))\n        curve = ax.plot(lambda x: (x+2)*x*(x-2)/2, color=RED)\n        area = ax.get_area(curve, (-2, 0))\n        self.add(ax, curve, area)"
  },
  {
    "text": "class SecondExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(-3, 3), y_range=(-3, 3))\n        curve = ax.plot(lambda x: (x+2)*x*(x-2)/2, color=RED)\n        area = ax.get_area(curve, x_range=(-2, 0))\n        self.play(Create(ax, run_time=2), Create(curve, run_time=5))\n        self.play(FadeIn(area))\n        self.wait(2)"
  },
  {
    "text": "class SquareToCircle(Scene):\n    def construct(self):\n        green_square = Square(color=GREEN, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(green_square))\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.play(ReplacementTransform(green_square, blue_circle))\n        self.play(Indicate(blue_circle))\n        self.play(FadeOut(blue_circle))"
  },
  {
    "text": "class ComplexExp(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes(x_range=(-0.1, 4.25), y_range=(-1.5, 1.5), z_range=(-1.5, 1.5), y_length=5, z_length=5)\n        curve = ParametricFunction(\n            lambda p: axes.coords_to_point(p, np.exp(complex(0, PI*p)).real, np.exp(complex(0, PI*p)).imag),\n            t_range=(0, 2, 0.1)\n        )\n        curve_extension = ParametricFunction(\n            lambda p: axes.coords_to_point(p, np.exp(complex(0, PI*p)).real, np.exp(complex(0, PI*p)).imag),\n            t_range=(2, 4, 0.1)\n        )\n        t = MathTex(\"z = e^{t \\pi i}, \\quad t\\in [0, 2]\")\n        t.rotate(axis=OUT, angle=90*DEGREES).rotate(axis=UP, angle=90*DEGREES)\n        t.next_to(curve, UP + OUT)\n        self.set_camera_orientation(phi=90*DEGREES, theta=0, focal_distance=10000)\n        self.add(axes)\n        self.play(Create(curve, run_time=2), Write(t))\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        four = MathTex(\"4\").rotate(axis=OUT, angle=90*DEGREES).rotate(axis=UP, angle=90*DEGREES)\n        four.move_to(t[0][12])\n        self.play(Create(curve_extension, run_time=2), t[0][12].animate.become(four))\n        self.wait()\n        self.move_camera(phi=90*DEGREES, theta=-90*DEGREES, focal_distance=10000)\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        self.move_camera(phi=0, theta=-90*DEGREES, focal_distance=10000)\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        self.play(FadeOut(axes, curve, curve_extension, t, shift=IN))\n        self.wait()"
  },
  {
    "text": "class Positioning(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        self.add(plane)\n\n        # next_to from episode 1\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN)\n        green_dot.next_to(red_dot, RIGHT + UP)  # RIGHT == [1, 0, 0]\n        self.add(red_dot, green_dot)\n\n        # shift\n        s = Square(color=ORANGE)\n        s.shift(2*UP + 4*RIGHT)\n        self.add(s)\n\n        # move_to\n        c = Circle(color=PURPLE)\n        c.move_to([-3, -2, 0])\n        self.add(c)\n\n        # align_to\n        c2 = Circle(radius=0.5, color=RED, fill_opacity=0.5)\n        c3 = c2.copy().set_color(YELLOW)\n        c4 = c2.copy().set_color(ORANGE)\n        c2.align_to(s, UP)\n        c3.align_to(s, RIGHT)\n        c4.align_to(s, UP + RIGHT)\n        self.add(c2, c3, c4)"
  },
  {
    "text": "class CriticalPoints(Scene):\n    def construct(self):\n        c = Circle(color=GREEN, fill_opacity=0.5)\n        self.add(c)\n\n        for d in [(0,0,0), UP, UR, RIGHT, DR, DOWN, DL, LEFT, UL]:\n            self.add(Cross(scale_factor=0.2).move_to(c.get_critical_point(d)))\n\n        s = Square(color=RED, fill_opacity=0.5)\n        s.move_to([1,0,0], aligned_edge=LEFT)\n        self.add(s)"
  },
  {
    "text": "from manim.utils.unit import Percent, Pixels\n\nclass UsefulUnits(Scene):\n    def construct(self):\n        for perc in range(5, 51, 5):\n            self.add(Circle(radius=perc * Percent(X_AXIS)))\n            self.add(Square(side_length=2*perc*Percent(Y_AXIS), color=YELLOW))\n\n        d = Dot()\n        d.shift(100 * Pixels * RIGHT)\n        self.add(d)"
  },
  {
    "text": "class Grouping(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN).next_to(red_dot, RIGHT)\n        blue_dot = Dot(color=BLUE).next_to(red_dot, UP)\n        dot_group = VGroup(red_dot, green_dot, blue_dot)\n        dot_group.to_edge(RIGHT)\n        self.add(dot_group)\n\n        circles = VGroup(*[Circle(radius=0.2) for _ in range(10)])\n        circles.arrange(UP, buff=0.5)\n        self.add(circles)\n\n        stars = VGroup(*[Star(color=YELLOW, fill_opacity=1).scale(0.5) for _ in range(20)])\n        stars.arrange_in_grid(4, 5, buff=0.2)\n        self.add(stars)"
  },
  {
    "text": "from colour import Color\nclass BasicAnimations(Scene):\n    def construct(self):\n        polys = VGroup(\n            *[RegularPolygon(5, radius=1, color=Color(hue=j/5, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for j in range(5)]\n        ).arrange(RIGHT)\n        self.play(DrawBorderThenFill(polys), run_time=2)\n        self.play(\n            Rotate(polys[0], PI, rate_func=lambda t: t), # rate_func=linear\n            Rotate(polys[1], PI, rate_func=smooth),  # default behavior for most animations\n            Rotate(polys[2], PI, rate_func=lambda t: np.sin(t*PI)),\n            Rotate(polys[3], PI, rate_func=there_and_back),\n            Rotate(polys[4], PI, rate_func=lambda t: 1 - abs(1-2*t)),\n            run_time=2\n        )\n        self.wait()"
  },
  {
    "text": "class ConflictingAnimations(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        self.play(Rotate(s, PI), Rotate(s, -PI), run_time=3)"
  },
  {
    "text": "class LaggingGroup(Scene):\n    def construct(self):\n        squares = VGroup(*[Square(color=Color(hue=j/20, saturation=1, luminance=0.5), fill_opacity=0.8) for j in range(20)])\n        squares.arrange_in_grid(4, 5).scale(0.75)\n        self.play(AnimationGroup(*[FadeIn(s) for s in squares], lag_ratio=0.15))"
  },
  {
    "text": "class AnimateSyntax(Scene):\n    def construct(self):\n        s = Square(color=GREEN, fill_opacity=0.5)\n        c = Circle(color=RED, fill_opacity=0.5)\n        self.add(s, c)\n        self.play(s.animate.shift(UP), c.animate.shift(DOWN))\n        self.play(VGroup(s, c).animate.arrange(RIGHT))\n        self.play(c.animate(rate_func=linear).shift(RIGHT).scale(2))\n        self.wait()"
  },
  {
    "text": "class AnimateProblem(Scene):\n    def construct(self):\n        left_square = Square()\n        right_square = Square()\n        VGroup(left_square, right_square).arrange(RIGHT, buff=1)\n        self.add(left_square, right_square)\n        self.play(left_square.animate.rotate(PI), Rotate(right_square, PI), run_time=2)"
  },
  {
    "text": "class AnimationMechanisms(Scene):\n    def construct(self):\n        c = Circle()\n        \n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n        \n        self.add(c)\n        self.wait()\n        self.play(MoveToTarget(c))\n        \n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2)\n\n        self.wait()"
  },
  {
    "text": "class SimpleCustomAnimation(Scene):\n    def construct(self):\n        def spiral_out(mobject, t):\n            radius = 4 * t\n            angle = 2*t * 2*PI\n            mobject.move_to(radius*(np.cos(angle)*RIGHT + np.sin(angle)*UP))\n            mobject.set_color(Color(hue=t, saturation=1, luminance=0.5))\n            mobject.set_opacity(1-t)\n        \n        d = Dot(color=YELLOW)\n        self.add(d)\n        self.play(UpdateFromAlphaFunc(d, spiral_out, run_time=3))"
  },
  {
    "text": "class Disperse(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n    \n    def begin(self):\n        dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(self.mobject.point_from_proportion(p))\n              for p in np.linspace(0, 1, self.dot_number)]\n        )\n        for dot in dots:\n            dot.initial_position = dot.get_center()\n            dot.shift_vector = 2*(dot.get_center() - self.mobject.get_center())\n        dots.set_opacity(0)\n        self.mobject.add(dots)\n        self.dots = dots\n        super().begin()\n        \n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n\n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.mobject.set_opacity(1 - 2*alpha, family=False)\n            self.dots.set_opacity(2*alpha)\n        else:\n            self.mobject.set_opacity(0)\n            self.dots.set_opacity(2*(1 - alpha))\n            for dot in self.dots:\n                dot.move_to(dot.initial_position + 2*(alpha-0.5)*dot.shift_vector)\n            \n            \n\nclass CustomAnimationExample(Scene):\n    def construct(self):\n        st = Star(color=YELLOW, fill_opacity=1).scale(3)\n        self.add(st)\n        self.wait()\n        self.play(Disperse(st, dot_number=200, run_time=4))"
  },
  {
    "text": "class MovingLabel(Scene):\n    def construct(self):\n        blue_dot = Dot(color=BLUE)\n        dot_label = Text(\"Hello dot!\").next_to(blue_dot, UP)\n        dot_label.add_updater(\n            lambda mobject: mobject.next_to(blue_dot, UP)\n        )\n        self.add(blue_dot, dot_label)\n        self.play(blue_dot.animate.shift(RIGHT))\n        self.play(blue_dot.animate.scale(10))\n        self.play(blue_dot.animate.move_to([-2, -2, 0]))"
  },
  {
    "text": "class AllUpdaterTypes(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED).shift(LEFT)\n        pointer = Arrow(ORIGIN, RIGHT).next_to(red_dot, LEFT)\n        pointer.add_updater( # place arrow left of dot\n            lambda mob: mob.next_to(red_dot, LEFT)\n        )\n        \n        def shifter(mob, dt): # make dot move 2 units RIGHT/sec\n            mob.shift(2*dt*RIGHT)\n        red_dot.add_updater(shifter)\n        \n        def scene_scaler(dt): # scale mobjects depending on distance to origin\n            for mob in self.mobjects:\n                mob.set(width=2/(1 + np.linalg.norm(mob.get_center())))\n        self.add_updater(scene_scaler)\n        \n        self.add(red_dot, pointer)\n        # scene has to update initially to fix first frame:\n        # first mobject updaters are called, then scene updaters\n        self.update_self(0)\n        self.wait(5)\n        "
  },
  {
    "text": "class UpdaterAndAnimation(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED).shift(LEFT)\n        rotating_square = Square()\n        rotating_square.add_updater(lambda mob, dt: mob.rotate(dt*PI))\n        \n        def shifter(mob, dt): # make dot move 2 units RIGHT/sec\n            mob.shift(2*dt*RIGHT)\n        red_dot.add_updater(shifter)\n        \n        self.add(red_dot, rotating_square)\n        self.wait(1)\n        red_dot.suspend_updating()\n        self.wait(1)\n        self.play(\n            red_dot.animate.shift(UP),\n            rotating_square.animate.move_to([-2, -2, 0])\n        )\n        self.wait(1)"
  },
  {
    "text": "class ValueTrackerMove(Scene):\n    def construct(self):\n        line = NumberLine(x_range=[-5, 5])\n        position = ValueTracker(0)\n        pointer = Vector(DOWN)\n        pointer.add_updater(\n            lambda mob: mob.next_to(\n                line.number_to_point(position.get_value()), UP\n            )\n        )\n        pointer.update()\n        self.add(line, pointer)\n        self.wait()\n        self.play(position.animate.set_value(4))\n        self.play(position.animate.set_value(-2))"
  },
  {
    "text": "class ValueTrackerPlot(Scene):\n    def construct(self):\n        a = ValueTracker(1)\n        ax = Axes(x_range=[-2, 2, 1], y_range=[-8.5, 8.5, 1], x_length=4, y_length=6)\n        parabola = ax.plot(lambda x: a.get_value() * x**2, color=RED)\n        parabola.add_updater(\n            lambda mob: mob.become(ax.plot(lambda x: a.get_value() * x**2, color=RED))\n        )\n        a_number = DecimalNumber(\n            a.get_value(),\n            color=RED,\n            num_decimal_places=3,\n            show_ellipsis=True\n        )\n        a_number.add_updater(\n            lambda mob: mob.set_value(a.get_value()).next_to(parabola, RIGHT)\n        )\n        self.add(ax, parabola, a_number)\n        self.play(a.animate.set_value(2))\n        self.play(a.animate.set_value(-2))\n        self.play(a.animate.set_value(1))"
  },
  {
    "text": "class SweepingLine(Scene):\n    def construct(self):\n        growing_circle = Circle(radius=0.001)\n\n        moving_line = Line([-7, -5, 0], [-6, 5, 0])\n        moving_line.normal_vector = moving_line.copy().rotate(90*DEGREES).get_vector()\n\n        def opacity_updater(obj):\n            if (  # check whether dot is inside circle\n                sum((growing_circle.points[0] - growing_circle.get_center())**2)\n                >= sum((obj.get_center() - growing_circle.get_center())**2)\n                #  round(  # more general winding number approach!\n                #      get_winding_number(growing_circle.get_anchors() - obj.get_center())\n                #  ) > 0\n            ):\n                obj.set_fill(BLUE, opacity=1)\n                obj.clear_updaters()  # removes opacity_updater, ...\n                obj.add_updater(color_updater)  # and attaches the color_updater function\n                self.add_sound(\"assets/click.wav\")\n\n        def color_updater(obj):\n            if (  # check whether point is *right* of the line\n                np.dot(obj.get_center(), moving_line.normal_vector)\n                < np.dot(moving_line.get_start(), moving_line.normal_vector)\n            ):\n                if obj.color != Color(BLUE):\n                    obj.set_color(BLUE)\n                    self.add_sound(\"assets/click.wav\")\n            else:  # otherwise point is *left* of the line\n                if obj.color != Color(YELLOW):\n                    obj.set_color(YELLOW)\n                    self.add_sound(\"assets/click.wav\")\n\n        self.add(growing_circle)\n\n        for _ in range(30):\n            p = Dot(fill_opacity=0.6)\n            p.move_to([random.uniform(-6, 6), random.uniform(-4, 4), 0])\n            p.add_updater(opacity_updater)\n            self.add(p)\n\n        self.play(\n            growing_circle.animate.scale_to_fit_width(1.5*config.frame_width),\n            run_time=5\n        )\n        self.play(Create(moving_line))\n        self.play(moving_line.animate.shift(14*RIGHT), run_time=5)\n        self.play(moving_line.animate.shift(14*LEFT), run_time=5)"
  },
  {
    "text": "class DeCasteljau(Scene):\n    def construct(self):\n        self.camera.background_color = '#455D3E'\n        a1 = np.array([-3, -2, 0])\n        h1 = np.array([-3, 0, 0])\n        h2 = np.array([3, 0, 0])\n        a2 = np.array([3, 2, 0])\n\n        t = ValueTracker(0.001)\n        self.add(t)\n\n        d01 = Cross(scale_factor=0.2).move_to(a1)\n        d02 = Dot(color=ORANGE).move_to(h1)\n        d03 = Dot(color=ORANGE).move_to(h2)\n        d04 = Cross(scale_factor=0.2).move_to(a2)\n\n        d11 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to(\n                (1- t.get_value()) * d01.get_center() + t.get_value() * d02.get_center()\n            )\n        )\n        d12 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d02.get_center() + t.get_value() * d03.get_center())\n        )\n        d13 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d03.get_center() + t.get_value() * d04.get_center())\n        )\n\n        d21 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d11.get_center() + t.get_value() * d12.get_center())\n        )\n        d22 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d12.get_center() + t.get_value() * d13.get_center())\n        )\n\n        d31 = Dot(color=RED).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d21.get_center() + t.get_value() * d22.get_center())\n        )\n\n        static_lines = [\n            Line(d01.get_center(), d02, color=ORANGE),\n            Line(d02, d03),\n            Line(d03, d04.get_center(), color=ORANGE)\n        ]\n\n        dynamic_lines = [\n            always_redraw(lambda a=a, b=b: Line(a.get_center(), b.get_center(), color=LIGHT_GRAY))\n            for a, b in [\n                (d11, d12), (d12, d13), (d21, d22)\n            ]\n        ]\n        self.add(*dynamic_lines, *static_lines, d01, d02, d03, d04, d11, d12, d13, d21, d22, d31)\n        self.add(\n            TracedPath(lambda: d31.get_center(), stroke_color=RED)\n        )\n\n        self.wait(0.5)\n        self.play(t.animate(run_time=5).set_value(0.999))\n        self.wait(0.5)\n        self.play(FadeOut(VGroup(\n            *dynamic_lines, *static_lines, d02, d03, d11, d12, d13, d21, d22\n        )))\n        self.wait()"
  },
  {
    "text": "class RateFuncDemo(Scene):\n    def construct(self):\n        props = [\n            (\"smooth\", X11.SIENNA1),\n            (\"smoothstep\", X11.SIENNA2),\n            (\"smootherstep\", X11.SIENNA3),\n            (\"smoothererstep\", X11.SIENNA4)\n        ]\n        squares = VGroup()\n        for label_text, color in props:\n            col_square = Square()\n            col_square.set_fill(color, opacity=1)\n            col_square.set_stroke(opacity=0)\n            label = Text(label_text, font_size=24, font=\"Monospace\")\n            label.next_to(col_square, UP)\n            col_square.add(label)\n            squares.add(col_square)\n            \n        squares.arrange(RIGHT, buff=1).shift(2*UP)\n        self.add(squares)\n        \n        progress = VDict({\n            \"line\": Line(4*LEFT, 4*RIGHT),\n            \"marker\": Dot(radius=0.15)\n        })\n        progress[\"marker\"].move_to(progress[\"line\"].point_from_proportion(0))\n        progress.next_to(squares, UP)\n        self.add(progress)\n        \n        anims = []\n        for ind, (rate_name, _) in enumerate(props):\n            rate_func = getattr(rate_functions, rate_name)\n            anims.append(squares[ind].animate(run_time=4, rate_func=rate_func).shift(4*DOWN))\n        \n        self.wait()\n        self.play(\n            *anims, \n            UpdateFromAlphaFunc(\n                progress, \n                lambda mobj, alpha: mobj[\"marker\"].move_to(mobj[\"line\"].point_from_proportion(alpha)),\n                run_time=4,\n                rate_func=linear,\n            )\n        )\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nfrom manim_ml.neural_network import Convolutional2DLayer, FeedForwardLayer, NeuralNetwork\n\n# This changes the resolution of our rendered videos\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n# Here we define our basic scene\nclass BasicScene(ThreeDScene):\n\n    # The code for generating our scene goes here\n    def construct(self):\n        # Make the neural network\n        nn = NeuralNetwork([\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the neural network\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make a forward pass animation\n        forward_pass = nn.make_forward_pass_animation()\n        # Play animation\n        self.play(forward_pass)"
  },
  {
    "text": "class BasicScene(ThreeDScene):\n\n    def construct(self):\n        # Your code goes here\n        text = Text(\"Your first scene!\")\n        self.add(text)"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nnn = NeuralNetwork([\n    FeedForwardLayer(num_nodes=3),\n    FeedForwardLayer(num_nodes=5),\n    FeedForwardLayer(num_nodes=3)\n])\nself.add(nn)"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n# Make the neural network\nnn = NeuralNetwork([\n    FeedForwardLayer(num_nodes=3),\n    FeedForwardLayer(num_nodes=5),\n    FeedForwardLayer(num_nodes=3)\n])\nself.add(nn)\n# Make the animation\nforward_pass_animation = nn.make_forward_pass_animation()\n# Play the animation\nself.play(forward_pass_animation)"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 7, 3, filter_spacing=0.32), # Note the default stride is 1. \n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n        Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n        FeedForwardLayer(3),\n        FeedForwardLayer(3),\n    ],\n    layer_spacing=0.25,\n)\n# Center the neural network\nnn.move_to(ORIGIN)\nself.add(nn)\n# Make a forward pass animation\nforward_pass = nn.make_forward_pass_animation()"
  },
  {
    "text": "import numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer, ImageLayer\n\nimage = Image.open(\"digit.jpeg\") # You will need to download an image of a digit. \nnumpy_image = np.asarray(image)\n\nnn = NeuralNetwork([\n        ImageLayer(numpy_image, height=1.5),\n        Convolutional2DLayer(1, 7, 3, filter_spacing=0.32), # Note the default stride is 1. \n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n        Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n        FeedForwardLayer(3),\n        FeedForwardLayer(3),\n    ],\n    layer_spacing=0.25,\n)\n# Center the neural network\nnn.move_to(ORIGIN)\nself.add(nn)\n# Make a forward pass animation\nforward_pass = nn.make_forward_pass_animation()"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, Convolutional2DLayer, MaxPooling2DLayer\n# Make neural network\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 8),\n        Convolutional2DLayer(3, 6, 3),\n        MaxPooling2DLayer(kernel_size=2),\n        Convolutional2DLayer(5, 2, 2),\n    ],\n    layer_spacing=0.25,\n)\n# Center the nn\nnn.move_to(ORIGIN)\nself.add(nn)\n# Play animation\nforward_pass = nn.make_forward_pass_animation()\nself.wait(1)\nself.play(forward_pass)"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, Convolutional2DLayer, FeedForwardLayer\n# Make nn\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 7, filter_spacing=0.32),\n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"),\n        FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n    ],\n    layer_spacing=0.25,\n)\nself.add(nn)\n# Play animation\nforward_pass = nn.make_forward_pass_animation()\nself.play(forward_pass)"
  },
  {
    "text": "from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations.dropout import make_neural_network_dropout_animation\n# Make nn\nnn = NeuralNetwork([\n        FeedForwardLayer(3),\n        FeedForwardLayer(5),\n        FeedForwardLayer(3),\n        FeedForwardLayer(5),\n        FeedForwardLayer(4),\n    ],\n    layer_spacing=0.4,\n)\n# Center the nn\nnn.move_to(ORIGIN)\nself.add(nn)\n# Play animation\nself.play(\n    make_neural_network_dropout_animation(\n        nn, dropout_rate=0.25, do_forward_pass=True\n    )\n)\nself.wait(1)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass NeuralNetworkScene(Scene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def construct(self):\n        # Make the Layer object\n        layers = [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        nn = NeuralNetwork(layers)\n        nn.scale(2)\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        forward_propagation_animation = nn.make_forward_pass_animation(\n            run_time=5, passing_flash=True\n        )\n\n        self.play(forward_propagation_animation)"
  },
  {
    "text": "from manim import *\n\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.math_operation_layer import MathOperationLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        nn = NeuralNetwork({\n            \"feed_forward_1\": FeedForwardLayer(3),\n            \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n            \"feed_forward_3\": FeedForwardLayer(3),\n            \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n        })\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)"
  },
  {
    "text": "from manim import *\n\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.math_operation_layer import MathOperationLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        nn = NeuralNetwork({\n            \"feed_forward_1\": FeedForwardLayer(3),\n            \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n            \"feed_forward_3\": FeedForwardLayer(3),\n            \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n        })\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)"
  },
  {
    "text": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            Convolutional2DLayer(1, 5, 5, 1, 1),\n            Convolutional2DLayer(4, 5, 5, 1, 1),\n            Convolutional2DLayer(2, 5, 5),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.50)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(4, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(2, 5, 5, filter_spacing=0.32),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image),\n            Convolutional2DLayer(1, 6, 1, padding=1),\n            Convolutional2DLayer(3, 6, 3),\n            FeedForwardLayer(3),\n            FeedForwardLayer(1),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=6,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=6,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        self.add(nn)\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=20)"
  },
  {
    "text": "from manim import *\nfrom PIL import Image\nimport numpy as np\nfrom manim_ml.neural_network import Convolutional2DLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork({\n            \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n            \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n            \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1)\n        })\n        # Add the residual connection\n        nn.add_connection(\"layer1\", \"layer3\")\n        # Make the animation\n        self.play(nn.make_forward_pass_animation())\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            # Play animation\n            self.play(nn.make_forward_pass_animation())\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(1.1)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        # nn.rotate(-PI/2)\n        # nn.all_layers[0].image_mobject.rotate(PI/2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        # nn.all_layers[-1].image_mobject.rotate(PI/2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([0, -1.4, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(0.52)\n        code_snippet.shift([0, 1.25, 0])\n        # code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.0),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.0),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(0.65)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.all_layers[0].image_mobject.rotate(PI / 2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.all_layers[-1].image_mobject.rotate(PI / 2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.0, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()"
  },
  {
    "text": "from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 20.0\nconfig.frame_width = 20.0\n\nROOT_DIR = Path(__file__).parents[2]\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=4.5),\n                Convolutional2DLayer(1, 28),\n                Convolutional2DLayer(6, 28, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(16, 10, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                FeedForwardLayer(8),\n                FeedForwardLayer(3),\n                FeedForwardLayer(2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # Group it all\n        # group = Group(nn, code)\n        # group.move_to(ORIGIN)\n        nn.move_to(ORIGIN)\n        # Play animation\n        # forward_pass = nn.make_forward_pass_animation()\n        # self.wait(1)\n        # self.play(forward_pass)"
  },
  {
    "text": "from manim import *\n\nfrom manim_ml.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers.parent_layers import NeuralNetworkLayer, ConnectiveLayer, ThreeDLayer\nimport manim_ml\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 10.5\nconfig.frame_width = 10.5\n\nclass NeocognitronFilter(VGroup):\n    \"\"\"\n        Filter connecting the S and C Cells of a neocognitron layer.\n    \"\"\"\n\n    def __init__(\n        self,\n        input_cell, \n        output_cell, \n        receptive_field_radius, \n        outline_color=BLUE,\n        active_color=ORANGE, \n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.outline_color = outline_color\n        self.active_color = active_color\n        self.input_cell = input_cell\n        self.output_cell = output_cell\n        # Draw the receptive field\n        # Make the points of a equilateral triangle in the plane of the \n        # cell about a random center\n        # center_point = input_cell.get_center()\n        shift_amount_x = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        # center_point += np.array([shift_amount_x, shift_amount_y, 0])\n        # # Make the triangle points\n        # side_length = np.sqrt(3) * receptive_field_radius\n        # normal_vector = np.cross(\n        #     input_cell.get_left() - input_cell.get_center(),\n        #     input_cell.get_top() - input_cell.get_center(),\n        # )\n        # Get vector in the plane of the cell\n        # vector_in_plane = input_cell.get_left() - input_cell.get_center()\n        # point_a = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_b = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_c = center_point + vector_in_plane * receptive_field_radius\n        # self.receptive_field = Circle.from_three_points(\n        #     point_a, \n        #     point_b,\n        #     point_c,\n        #     color=outline_color,\n        #     stroke_width=2.0,\n        # )\n        self.receptive_field = Circle(\n            radius=receptive_field_radius,\n            color=outline_color,\n            stroke_width=3.0,\n        )\n        self.add(self.receptive_field)\n        # Move receptive field to a random point within the cell\n        # minus the radius of the receptive field\n        self.receptive_field.move_to(\n            input_cell\n        )\n        # Shift a random amount in the x and y direction within \n        self.receptive_field.shift(\n            np.array([shift_amount_x, shift_amount_y, 0])\n        )\n        # Choose a random point on the c_cell\n        shift_amount_x = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        self.dot = Dot(\n            color=outline_color,\n            radius=0.04\n        )\n        self.dot.move_to(output_cell.get_center() + np.array([shift_amount_x, shift_amount_y, 0]))\n        self.add(self.dot)\n        # Make lines connecting receptive field to the dot\n        self.lines = VGroup()\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() + np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() - np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.add(self.lines)\n\n    def make_filter_pulse_animation(self, **kwargs):\n        succession = Succession(\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n            ShowPassingFlash(\n                self.lines.copy().set_color(self.active_color),\n                time_width=0.5,\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n        )\n\n        return succession\n\nclass NeocognitronLayer(NeuralNetworkLayer, ThreeDLayer):\n    \n    def __init__(\n        self, \n        num_cells, \n        cell_height,\n        receptive_field_radius,\n        layer_name,\n        active_color=manim_ml.config.color_scheme.active_color,\n        cell_color=manim_ml.config.color_scheme.secondary_color,\n        outline_color=manim_ml.config.color_scheme.primary_color,\n        show_outline=True,\n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.num_cells = num_cells\n        self.cell_height = cell_height\n        self.receptive_field_radius = receptive_field_radius\n        self.layer_name = layer_name\n        self.active_color = active_color\n        self.cell_color = cell_color\n        self.outline_color = outline_color\n        self.show_outline = show_outline\n\n        self.plane_label = Text(layer_name).scale(0.4)\n\n    def make_cell_plane(self, layer_name, cell_buffer=0.1, stroke_width=2.0):\n        \"\"\"Makes a plane of cells. \n        \"\"\"\n        cell_plane = VGroup()\n        for cell_index in range(self.num_cells):\n            # Draw the cell box\n            cell_box = Rectangle(\n                width=self.cell_height,\n                height=self.cell_height,\n                color=self.cell_color,\n                fill_color=self.cell_color,\n                fill_opacity=0.3,\n                stroke_width=stroke_width,\n            )\n            if cell_index > 0:\n                cell_box.next_to(cell_plane[-1], DOWN, buff=cell_buffer)\n            cell_plane.add(cell_box)\n        # Draw the outline\n        if self.show_outline:\n            self.plane_outline = SurroundingRectangle(\n                cell_plane,\n                color=self.cell_color,\n                buff=cell_buffer,\n                stroke_width=stroke_width,\n            )\n            cell_plane.add(\n                self.plane_outline\n            )\n        # Draw a label above the container box\n        self.plane_label.next_to(cell_plane, UP, buff=0.2)\n        cell_plane.add(self.plane_label)\n\n        return cell_plane\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        # Make the Cell layer\n        self.cell_plane = self.make_cell_plane(self.layer_name)\n        self.add(self.cell_plane)\n        \n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        # # Pulse and un pulse the cell plane rectangle\n        flash_outline_animations = []\n        for cell in self.cell_plane:\n            flash_outline_animations.append(\n                Succession(\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.active_color,\n                        run_time=0.25\n                    ),\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.outline_color,\n                        run_time=0.25\n                    )\n                )\n            )\n        \n        return AnimationGroup(\n            *flash_outline_animations,\n            lag_ratio=0.0\n        )\n\nclass NeocognitronToNeocognitronLayer(ConnectiveLayer):\n    input_class = NeocognitronLayer\n    output_class = NeocognitronLayer\n\n    def __init__(self, input_layer, output_layer, **kwargs):\n        super().__init__(input_layer, output_layer, **kwargs)\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        self.filters = []\n        for cell_index in range(input_layer.num_cells):\n            input_cell = input_layer.cell_plane[cell_index]\n            # Randomly choose a cell from the output layer\n            output_cell = output_layer.cell_plane[\n                np.random.randint(0, output_layer.num_cells)\n            ]\n            # Make the filter\n            filter = NeocognitronFilter(\n                input_cell=input_cell,\n                output_cell=output_cell,\n                receptive_field_radius=input_layer.receptive_field_radius,\n                outline_color=self.input_layer.outline_color\n            )\n            # filter = NeocognitronFilter(\n            #     outline_color=input_layer.outline_color\n            # )\n            self.filters.append(filter)\n\n        self.add(VGroup(*self.filters))\n\n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        filter_pulses = []\n        for filter in self.filters:\n            filter_pulses.append(\n                filter.make_filter_pulse_animation()\n            )\n        return AnimationGroup(\n            *filter_pulses\n        )\n\nmanim_ml.neural_network.layers.util.register_custom_connective_layer(\n    NeocognitronToNeocognitronLayer,\n)\n\nclass Neocognitron(NeuralNetwork):\n\n    def __init__(\n        self, \n        camera,\n        cells_per_layer=[4, 5, 4, 4, 3, 3, 5, 5],\n        cell_heights=[0.8, 0.8, 0.8*0.75, 0.8*0.75, 0.8*0.75**2, 0.8*0.75**2, 0.8*0.75**3, 0.02],\n        layer_names=[\"S1\", \"C1\", \"S2\", \"C2\", \"S3\", \"C3\", \"S4\", \"C4\"],\n        receptive_field_sizes=[0.2, 0.2, 0.2*0.75, 0.2*0.75, 0.2*0.75**2, 0.2*0.75**2, 0.2*0.75**3, 0.0],\n    ):\n        self.cells_per_layer = cells_per_layer\n        self.cell_heights = cell_heights\n        self.layer_names = layer_names\n        self.receptive_field_sizes = receptive_field_sizes\n        # Make the neo-cognitron input layer\n        input_layers = []\n        input_layers.append(\n            NeocognitronLayer(\n                1,\n                1.5,\n                0.2,\n                \"U0\",\n                show_outline=False,\n            )\n        )\n        # Make the neo-cognitron layers\n        for i in range(len(cells_per_layer)):\n            layer = NeocognitronLayer(\n                cells_per_layer[i],\n                cell_heights[i],\n                receptive_field_sizes[i],\n                layer_names[i]\n            )\n            input_layers.append(layer)\n        \n        # Make all of the layer labels fixed in frame\n        for layer in input_layers:\n            if isinstance(layer, NeocognitronLayer):\n                # camera.add_fixed_orientation_mobjects(layer.plane_label)\n                pass\n\n        all_layers = []\n        for layer_index in range(len(input_layers) - 1):\n            input_layer = input_layers[layer_index]\n            all_layers.append(input_layer)\n            output_layer = input_layers[layer_index + 1]\n            connective_layer = NeocognitronToNeocognitronLayer(\n                input_layer,\n                output_layer\n            )\n            all_layers.append(connective_layer)\n        all_layers.append(input_layers[-1])\n\n        def custom_layout_func(neural_network):\n            # Insert the connective layers\n            # Pass the layers to neural network super class\n            # Rotate pairs of layers\n            layer_index = 1\n            while layer_index < len(input_layers):\n                prev_layer = input_layers[layer_index - 1]\n                s_layer = input_layers[layer_index]\n                s_layer.next_to(prev_layer, RIGHT, buff=0.0)\n                s_layer.shift(RIGHT * 0.4)\n                c_layer = input_layers[layer_index + 1]\n                c_layer.next_to(s_layer, RIGHT, buff=0.0)\n                c_layer.shift(RIGHT * 0.2)\n                # Rotate the pair of layers\n                group = Group(s_layer, c_layer)\n                group.move_to(np.array([group.get_center()[0], 0, 0]))\n\n                # group.shift(layer_index * 3 * np.array([0, 0, 1.0]))\n                # group.rotate(40 * DEGREES, axis=UP, about_point=group.get_center())\n                # c_layer.rotate(40*DEGREES, axis=UP, about_point=group.get_center())\n                # s_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                # c_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                layer_index += 2\n            neural_network.move_to(ORIGIN)\n\n        super().__init__(\n            all_layers,\n            layer_spacing=0.5,\n            custom_layout_func=custom_layout_func\n        )\n\nclass Scene(ThreeDScene):\n\n    def construct(self):\n        neocognitron = Neocognitron(self.camera)\n        neocognitron.shift(DOWN*0.5)\n        self.add(neocognitron)\n        title = Text(\"Neocognitron\").scale(1)\n        self.add_fixed_in_frame_mobjects(title)\n        title.next_to(neocognitron, UP, buff=0.4)\n        self.add(title)\n        \"\"\"\n        self.play(\n            neocognitron.make_forward_pass_animation()\n        )\n        \"\"\"\n        print(self.camera.gamma)\n        print(self.camera.theta)\n        print(self.camera.phi)\n        neocognitron.rotate(90*DEGREES, axis=RIGHT)\n        neocognitron.shift(np.array([0, 0, -0.2]))\n        # title.rotate(90*DEGREES, axis=RIGHT)\n        # self.set_camera_orientation(phi=-15*DEGREES)\n        # vec = np.array([0.0, 0.2, 0.0])\n        # vec /= np.linalg.norm(vec)\n        # x, y, z = vec[0], vec[1], vec[2]\n        # theta = np.arccos(z)\n        # phi = np.arctan(y / x)\n        self.set_camera_orientation(phi=90 * DEGREES, theta=-70*DEGREES, gamma=0*DEGREES)\n        # self.set_camera_orientation(theta=theta, phi=phi)\n\n        forward_pass = neocognitron.make_forward_pass_animation()\n        self.play(forward_pass)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FibonacciPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        colors = [\n            LIGHT_BLUE_COLOR, \n            LIGHT_RED_COLOR, \n            LIGHT_ORANGE_COLOR, \n            AQUA_GREEN_COLOR, \n            LIGHT_PURPLE_COLOR, \n            LIGHT_BLUE_COLOR\n        ]\n        sequence = [0, 1, 1, 2, 3, 5, 8]\n        pattern_text = Tex(\"0, 1, 1, 2, 3, 5, 8, 13, ...\", color=TEXT_COLOR).scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n        previous_arc_box = None\n\n        self.add(title)\n        self.play(FadeIn(Group(pattern_text)), run_time=0.8)\n        self.wait(1)\n\n        for i in range(6):\n            start = -2.1 + i * 0.85\n            end = -3.25 + i * 0.85\n\n            arc_text = Tex(f\"{sequence[i]}+{sequence[i+1]}\", color=colors[i])\n            arc_text.scale(0.8)\n\n            if i % 2 == 0:\n                y1 = 0.5\n                y2 = 0.5\n                direction = UP\n            else:\n                y1 = -0.6\n                y2 = -0.39\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y1, 0], [end, y1, 0], color=colors[i])\n            arc.flip(UP)\n\n            if i % 2 == 1:\n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text.next_to(arc, direction)\n            arc_box = Line(np.array([end - 0.455, y2, 0]), np.array([start - 0.555, y2, 0]), color=colors[i])\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc, arc_box)), run_time=0.25)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    Transform(previous_arc_box.copy().set_opacity(0), arc_box),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.4\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            previous_arc_box = arc_box\n            self.wait(0.7)\n        \n        text = Tex(\"Fibonacci\", color=TEXT_COLOR)\n        text.shift(DOWN * 3.5)\n        text.scale(2)\n\n        self.play(Write(text))\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)))"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            LIGHT_BLUE_COLOR, \n            LIGHT_RED_COLOR, \n            LIGHT_ORANGE_COLOR, \n            AQUA_GREEN_COLOR, \n            LIGHT_PURPLE_COLOR\n        ]\n        sequence = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n        directions = [DOWN, RIGHT, UP, LEFT]\n        corners = [UR, UL, DL, DR]\n        angles = [PI, 3 * PI / 2, 2 * PI, PI / 2]\n        animations = []\n        squares = Group(\n            FibonacciSquare(sequence[0], colors[2]),\n            FibonacciSquare(sequence[1], colors[3]),\n            FibonacciSquare(sequence[2], colors[1]),\n            FibonacciSquare(sequence[3], colors[0]),\n            FibonacciSquare(sequence[4], colors[4]),\n            FibonacciSquare(sequence[5], colors[3]),\n            FibonacciSquare(sequence[6], colors[2]),\n            FibonacciSquare(sequence[7], colors[1]),\n            FibonacciSquare(sequence[8], colors[0])\n        )\n        squares.shift(1.5 * RIGHT + 2.5 * UP)\n\n        for i in range(8):\n            squares[i + 1].next_to(squares[i], directions[(i + 1) % 4], 0, directions[i % 4])\n\n        for square in squares:\n            animations.append(Create(square[0]))\n            animations.append(Write(square[1]))\n\n        self.play(LaggedStart(*animations, lag_ratio=0.2))\n\n        for i in range(9):\n            if i != 0: \n                self.remove(dot)\n\n            arc_angle = ValueTracker(0.0)\n            arc = always_redraw(\n                lambda: Arc(\n                    radius=sequence[i] / 5, \n                    arc_center=squares[i].get_corner(corners[i % 4]), \n                    color=TEXT_COLOR, \n                    start_angle=angles[i % 4], \n                    angle=arc_angle.get_value()\n                )\n            )\n            dot = always_redraw(\n                lambda: Dot(radius=0.05, color=TEXT_COLOR)\n                    .move_to(arc.get_end())\n            )\n\n            self.add(arc, dot)\n            self.play(\n                arc_angle.animate.set_value(PI / 2), \n                rate_func=linear, \n                run_time=max(0.3, sequence[i] / 34)\n            )\n            arc.clear_updaters()\n        \n        self.wait(0.5)\n        self.play(*[FadeOut(mobject) for mobject in self.mobjects[:19]], FadeOut(dot))\n        self.wait(1.5)\n        self.play(FadeOut(Group(*self.mobjects)))"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass Introduction(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = VGroup(\n            Tex(\"Sequ\u00eancias\"), \n            Tex(\"Num\u00e9ricas\")\n        )\n        title.arrange(DOWN)\n\n        inner_box = Square(2.7, stroke_color=WHITE)\n        outer_box = Square(3.7, color=RED, fill_opacity=1, stroke_color=WHITE)\n\n        number_group_1 = ImageMobject(\"./assets/NumberGroup1.png\")\n        number_group_1.next_to(outer_box, LEFT)\n        number_group_1.shift(7 * UP + 1.7 * RIGHT)\n        number_group_1.scale(0.4)\n\n        number_group_2 = ImageMobject(\"./assets/NumberGroup2.png\")\n        number_group_2.next_to(outer_box, RIGHT)\n        number_group_2.shift(7 * UP + 2.1 * LEFT)\n        number_group_2.scale(0.4)\n\n        rectangle_group_1 = Rectangle(color=RED, height=0.05, width=2, fill_opacity=1)\n        rectangle_group_1.next_to(outer_box, LEFT)\n        rectangle_group_1.shift(0.6 * UP + 0.2 * RIGHT)\n\n        rectangle_group_2 = Rectangle(color=RED, height=0.05, width=2.5, fill_opacity=1)\n        rectangle_group_2.next_to(outer_box, RIGHT)\n        rectangle_group_2.shift(0.6 * DOWN + 0.2 * LEFT)\n        \n\n        self.play(\n            FadeIn(rectangle_group_1),\n            FadeIn(rectangle_group_2),\n            FadeIn(outer_box),\n            FadeIn(inner_box),\n            FadeIn(title)\n        )\n        self.play(\n            number_group_1.animate.shift(6 * DOWN), \n            rate_func=rate_functions.rush_from\n        )\n        self.wait(0.8)\n        self.play(\n            number_group_2.animate.shift(7.2 * DOWN), \n            rate_func=rate_functions.rush_from, \n            run_time=1.2\n        )\n        self.wait(1.5)\n        self.play(*[\n            mobject.animate(rate_func=running_start, run_time=1.3).shift(LEFT * 15) \n            for mobject in self.mobjects\n        ])\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        pattern_text = Tex(\"1, 3, 9, 27, 81, 243, ...\", color=TEXT_COLOR).scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n        \n        self.add(title)\n        self.play(FadeIn(pattern_text), run_time=0.8)\n        self.wait(1)\n\n        for i in range(5):\n            start = -2.6 + i * 0.85\n            end = start - 0.8\n\n            if i > 2:\n                start += 0.4\n                end += 0.3\n            \n            if i > 3:\n                start += 0.6\n                end += 0.3\n\n            if i % 2 == 0:\n                y = 0.5\n                direction = UP\n            else:\n                y = -0.6\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y, 0], [end, y, 0], color=LIGHT_BLUE_COLOR)\n            arc.flip(UP)\n            \n            if i % 2 == 1:\n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text = Tex(\"x3\", color=LIGHT_BLUE_COLOR)\n            arc_text.scale(0.8)\n            arc_text.next_to(arc, direction)\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc)), run_time=0.25)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.4\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            self.wait(0.5)\n\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects[1:])))\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        pattern_text = Tex(\"1, 3, 9, 27, 81, 243, ...\", color=TEXT_COLOR).scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n        \n        self.add(title)\n        self.play(FadeIn(pattern_text), run_time=0.8)\n        self.wait(1)\n\n        for i in range(5):\n            start = -2.6 + i * 0.85\n            end = start - 0.8\n\n            if i > 2:\n                start += 0.4\n                end += 0.3\n            \n            if i > 3:\n                start += 0.6\n                end += 0.3\n\n            if i % 2 == 0:\n                y = 0.5\n                direction = UP\n            else:\n                y = -0.6\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y, 0], [end, y, 0], color=LIGHT_BLUE_COLOR)\n            arc.flip(UP)\n            \n            if i % 2 == 1:\n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text = Tex(\"x3\", color=LIGHT_BLUE_COLOR)\n            arc_text.scale(0.8)\n            arc_text.next_to(arc, direction)\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc)), run_time=0.25)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.4\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            self.wait(0.5)\n\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects[1:])))\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SumPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        pattern_text = Tex(\"1, 2, 3, 4, 5, 6, 7, 8, ...\", color=TEXT_COLOR)\n        pattern_text.scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n\n        self.play(\n            FadeIn(title), \n            FadeIn(pattern_text), \n            run_time=0.5\n        )\n        self.wait(0.3)\n        self.play(Circumscribe(pattern_text[0][0], color=LIGHT_RED_COLOR, run_time=2.5))\n\n        for i in range(7):\n            start = -2.7 + i * 0.85\n            end = start - 0.8\n\n            if i % 2 == 0:\n                y = 0.5\n                direction = UP\n            else:\n                y = -0.5\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y, 0], [end, y, 0], color=LIGHT_RED_COLOR)\n            arc.flip(UP)\n\n            if i % 2 == 1: \n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text = Tex(\"+1\", color=LIGHT_RED_COLOR)\n            arc_text.scale(0.8)\n            arc_text.next_to(arc, direction)\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc)), run_time=0.2)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.3\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            self.wait(0.5)\n\n        self.wait(0.5)\n        self.play(FadeOut(Group(*self.mobjects[1:]), run_time=0.5))\n        self.remove(*self.mobjects)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\ndef ChocolateSquare():\n    return VGroup(\n                Square(1, color=\"#a26953\", fill_opacity=1, stroke_color=\"#814c3c\"),\n                Line((UP + RIGHT) / 2, (DOWN + LEFT) / 2, color=\"#814c3c\"),\n                Line((UP + LEFT) / 2, (DOWN + RIGHT) / 2, color=\"#814c3c\"),\n                Square(0.5, color=\"#814c3c\", fill_opacity=1),\n            )\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass ChocolateFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"1 de um total de 12 peda\u00e7os\", color=LIGHT_RED_COLOR)\n        title.scale(1.3)\n        frac = MathTex(r\"\\frac{1}{12}\", color=LIGHT_RED_COLOR)\n        frac.scale(1.8)\n        chocolate_row = VGroup(\n            ChocolateSquare(),\n            ChocolateSquare(),\n            ChocolateSquare(),\n        )\n        chocolate_row.arrange(RIGHT, buff=0)\n        chocolate_bar = VGroup(\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n        )\n        chocolate_bar.arrange(DOWN, buff=0)\n        Group(title, chocolate_bar, frac).arrange(DOWN, buff=0.5)\n        chocolate_bar.shift(9 * RIGHT)\n\n        self.play(chocolate_bar.animate.shift(9 * LEFT))\n        self.play(\n            LaggedStart(\n                Write(title.shift(0.3 * UP)), \n                chocolate_bar[0][0].animate.shift((LEFT + UP) / 2),\n                lag_ratio=0.2,\n                run_time=1.8\n            )\n        )\n        self.play(Write(frac), run_time=0.7)\n        self.play(\n            chocolate_bar[2][2].animate.shift(RIGHT * 1.5),\n            chocolate_bar[0][0].animate.shift((RIGHT + DOWN) / 2),\n            run_time=0.8\n        )\n        self.wait(0.5)\n        self.play(chocolate_bar[2][2].animate.shift(LEFT * 1.5), run_time=0.5)\n        self.play(Group(*self.mobjects).animate.scale(0), run_time=0.7)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass EqualDivisions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividida em partes iguais\", color=BLACK)\n        title.scale(1.5)\n        title.shift(4 * UP)\n        title[0][10:].set_color(\"#a346eb\")\n        rect = Rectangle(color=LIGHT_RED_COLOR, height=3, width=4, fill_opacity=0.3)\n        rect_vdiv = Line(rect.get_top(), rect.get_bottom(), color=LIGHT_RED_COLOR)\n        rect_hdiv = Line(rect.get_left(), rect.get_right(), color=LIGHT_RED_COLOR)\n        circ = Circle(1.5, color=LIGHT_GREEN_COLOR, fill_opacity=0.3)\n        circ_div = Line(circ.get_top(), circ.get_bottom(), color=LIGHT_GREEN_COLOR)\n        rect_divisions = VGroup(\n            rect_vdiv.copy().shift(RIGHT),\n            rect_vdiv.copy(),\n            rect_vdiv.copy().shift(LEFT),\n            rect_hdiv.copy().shift(1/2 * UP),\n            rect_hdiv.copy().shift(- 1/2 * UP)\n        )\n        circ_divisions = VGroup(*[circ_div.copy().rotate(i * 45 * DEGREES) for i in range(8)])\n        circ_n_rect = VGroup(\n            VGroup(rect, rect_divisions), \n            VGroup(circ, circ_divisions)\n        )\n        circ_n_rect.arrange(DOWN, buff=1)\n\n        self.play(\n            Create(rect),\n            Create(circ),\n            run_time=1.5\n        )\n        self.play(Create(rect_divisions))\n        self.play(Create(circ_divisions), run_time=1.8)\n        self.play(circ_n_rect.animate.shift(DOWN), run_time=0.2)\n        self.play(Write(title), run_time=0.8)\n        self.wait(0.5)\n        self.play(\n            circ_n_rect.animate.shift(9 * LEFT), \n            title.animate.shift(9 * LEFT),\n            run_time=0.8\n        )\n        self.remove(circ_n_rect, title)\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FigureOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fig = VGroup(\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1),\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1)\n                .rotate(PI),\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1),\n            Triangle(stroke_color=BLACK)\n                .rotate(PI),\n            Triangle(stroke_color=BLACK)\n        )\n        fig.arrange(RIGHT, buff=0, aligned_edge=LEFT)\n        frac = MathTex(r\"\\frac{3}{5}\", color=BLACK)\n        frac.next_to(fig, DOWN, buff=0)\n        frac.scale(1.4)\n        text = Text(\"12345\", font_size=36)\n        text.set_color(BLACK)\n        text[0].next_to(fig[0], ORIGIN, buff=0)\n        text[0].shift(0.2 * DOWN)\n        text[1].next_to(fig[1], ORIGIN, buff=0)\n        text[1].shift(0.2 * UP)\n        text[2].next_to(fig[2], ORIGIN, buff=0)\n        text[2].shift(0.2 * DOWN)\n        text[3].next_to(fig[3], ORIGIN, buff=0)\n        text[3].shift(0.2 * UP)\n        text[4].next_to(fig[4], ORIGIN, buff=0)\n        text[4].shift(0.2 * DOWN)\n        fig.shift(9 * RIGHT)\n        frac[0][0].set_color(LIGHT_ORANGE_COLOR)\n        frac[0][0].shift(0.1 * DOWN)\n        frac[0][1].scale(2)\n        text[3:].shift(0.5 * UP)\n\n        self.play(fig.animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(text[0:3]), run_time=0.7)\n        self.play(\n            fig.animate.shift(0.5 * UP), \n            text[0:3].animate.shift(0.5 * UP), \n            run_time=0.6\n        )\n        self.play(Write(frac[0][:2]), run_time=0.7)\n        self.play(FadeOut(text[0:3]))\n        self.play(Write(text))\n        self.play(Write(frac[0][2:]), run_time=0.7)\n        self.play(FadeOut(text))\n        self.wait(0.3)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FigureTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fig = VGroup(\n            VGroup(\n                Rectangle(height=2, width=1, stroke_color=BLACK),\n                VGroup(\n                    Rectangle(height=1, width=2, stroke_color=BLACK),\n                    Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                ).arrange(DOWN, buff=0),\n                Rectangle(height=2, width=1, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n            ).arrange(RIGHT, buff=0),\n            VGroup(\n                Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n            ).arrange(RIGHT, buff=0),\n            VGroup(\n                Rectangle(height=2, width=1, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                Rectangle(height=2, width=1, stroke_color=BLACK),\n                VGroup(\n                    Rectangle(height=1, width=2, stroke_color=BLACK),\n                    Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                ).arrange(DOWN, buff=0)\n            ).arrange(RIGHT, buff=0)\n        ).arrange(DOWN, buff=0)\n        text = Text(\"123456\", font_size=36)\n        text.set_color(BLACK)\n        frac = MathTex(r\"\\frac{6}{10}\", color=BLACK)\n        frac.next_to(fig, RIGHT, buff=0)\n        frac.scale(1.4)\n        text[0].next_to(fig[0][1][1], ORIGIN, buff=0)\n        text[1].next_to(fig[0][2], ORIGIN, buff=0)\n        text[2].next_to(fig[1][0], ORIGIN, buff=0)\n        text[3].next_to(fig[1][1], ORIGIN, buff=0)\n        text[4].next_to(fig[2][0], ORIGIN, buff=0)\n        text[5].next_to(fig[2][2][1], ORIGIN, buff=0)\n        frac[0][0].set_color(LIGHT_RED_COLOR)\n        frac[0][0].shift(0.1 * DOWN)\n        frac[0][1].scale(1.5)\n        fig.shift(9 * RIGHT)\n\n        self.play(fig.animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(0.8)\n        self.play(Write(text), run_time=0.7)\n        self.play(\n            fig.animate.shift(LEFT), \n            text.animate.shift(LEFT), \n            run_time=0.6\n        )\n        self.play(Write(frac[0][:2]), run_time=0.5)\n        self.play(FadeOut(text), run_time=0.7)\n\n        text = Text(\"12345678910\", font_size=36)\n        text.set_color(BLACK)\n        text[0].next_to(fig[0][0], ORIGIN, buff=0)\n        text[1].next_to(fig[0][1][0], ORIGIN, buff=0)\n        text[2].next_to(fig[0][1][1], ORIGIN, buff=0)\n        text[3].next_to(fig[0][2], ORIGIN, buff=0)\n        text[4].next_to(fig[1][0], ORIGIN, buff=0)\n        text[5].next_to(fig[1][1], ORIGIN, buff=0)\n        text[6].next_to(fig[2][0], ORIGIN, buff=0)\n        text[7].next_to(fig[2][1], ORIGIN, buff=0)\n        text[8].next_to(fig[2][2][0], ORIGIN, buff=0)\n        text[9:].next_to(fig[2][2][1], ORIGIN, buff=0)\n\n        self.play(Write(text))\n        self.play(Write(frac[0][2:]), run_time=0.5)\n        self.play(FadeOut(text), run_time=0.7)\n        self.wait(0.3)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)\n\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\ndef Pizza():\n    return VGroup(\n        Circle(1.3, color=\"#f7a139\", fill_opacity=1),\n        Circle(1.1, color=\"#e63838\", fill_opacity=1),\n        Circle(1, color=\"#ffd52c\", fill_opacity=1),\n        Pepperonni().shift(0.25 * UP),\n        Pepperonni().shift(0.16 * DOWN + 0.25 * RIGHT),\n        Pepperonni().shift(0.16 * DOWN + 0.25 * LEFT),\n        Pepperonni().shift(0.55 * UP + 0.55 * RIGHT),\n        Pepperonni().shift(0.55 * DOWN + 0.55 * RIGHT),\n        Pepperonni().shift(0.55 * UP + 0.55 * LEFT),\n        Pepperonni().shift(0.55 * DOWN + 0.55 * LEFT),\n        Pepperonni().shift(0.75 * UP),\n        Pepperonni().shift(0.75 * RIGHT),\n        Pepperonni().shift(0.75 * DOWN),\n        Pepperonni().shift(0.75 * LEFT),\n    )\n        \ndef Pepperonni():\n    return VGroup(\n        Circle(0.18, color=\"#d73d3d\", fill_opacity=1),\n        Circle(0.02, color=\"#f05454\", fill_opacity=1).shift(0.07 * (UP + LEFT)),\n        Circle(0.02, color=\"#f05454\", fill_opacity=1).shift(0.07 * (UP + RIGHT)),\n        Circle(0.03, color=\"#f05454\", fill_opacity=1).shift(0.07 * (DOWN))\n    )\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PizzaFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        pizzas = VGroup(\n            Pizza(),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI, 1.5 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 1.5 * PI, PI, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI / 2, 0, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 0, PI / 2, color=DARK_RED_COLOR), 7),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10),\n                DashedVMobject(Line(1.3 * RIGHT, 1.3 * LEFT, color=DARK_RED_COLOR), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI, 11/6 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 11/6 * PI, PI, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR)\n                    .rotate(2 * PI / 6), 10),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR)\n                    .rotate(4 * PI / 6), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, 6 * PI / 7, 17/14 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 17/14 * PI, 6 * PI / 7, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(2 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(4 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(6 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(8 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(10 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(12 * PI / 7, about_point=ORIGIN),\n            )\n        )\n        pizzas.scale(0.9)\n        pizzas.arrange(DOWN)\n\n        self.play(\n            LaggedStart(\n                *[SpinInFromNothing(pizza) for pizza in pizzas], \n                lag_ratio=0.2,\n                run_time=1.8\n            )\n        )\n        self.play(pizzas.animate.shift(LEFT), run_time=0.5)\n\n        arrows = []\n\n        for i in range(5):\n            arrows.append(Arrow(pizzas[i].get_right(), pizzas[i].get_right() + 1.5 * RIGHT, color=LIGHT_PURPLE_COLOR))\n\n        text1 = MathTex(\"1\", color=BLACK)\n        text1.next_to(arrows[0], RIGHT)\n        text2 = MathTex(r\"\\frac{1}{2}\", color=BLACK)\n        text2.next_to(arrows[1], RIGHT)\n        text3 = MathTex(r\"\\frac{3}{4}\", color=BLACK)\n        text3.next_to(arrows[2], RIGHT)\n        text4 = MathTex(r\"\\frac{3}{6}\", color=BLACK)\n        text4.next_to(arrows[3], RIGHT)\n        text5 = MathTex(r\"\\frac{4}{7}\", color=BLACK)\n        text5.next_to(arrows[4], RIGHT)\n        texts = [text1, text2, text3, text4, text5]\n\n        for i in range(5):\n            self.play(\n                DrawBorderThenFill(arrows[i]), \n                Write(texts[i]), \n                run_time=0.7\n            )\n\n        self.wait(1)\n        self.play(\n            *[pizza.animate.scale(0) for pizza in pizzas if pizza != pizzas[2]],\n            *[FadeOut(arrow) for arrow in arrows if arrow != arrows[2]],\n            *[FadeOut(text) for text in texts if text != texts[2]],\n            run_time=0.8\n        )\n        self.play(\n            Group(pizzas[2], arrows[2]).animate.rotate(-PI / 2).shift(0.2 * RIGHT + UP),\n            texts[2].animate.shift(2 * LEFT + 2 * DOWN),\n            run_time=0.8\n        )\n\n        arrow_num = Arrow(text3[0][0].get_left(), text3[0][0].get_left() + LEFT, color=LIGHT_RED_COLOR)\n        arrow_den = Arrow(text3[0][2].get_right(), text3[0][2].get_right() + RIGHT, color=GREEN_COLOR)\n        text_num = Tex(\"Numerador\", color=LIGHT_RED_COLOR)\n        text_num.next_to(arrow_num, LEFT)\n        text_den = Tex(\"Denominador\", color=GREEN_COLOR)\n        text_den.next_to(arrow_den, RIGHT)\n\n        self.play(\n            DrawBorderThenFill(arrow_num), \n            Write(text_num), \n            text3[0][0].animate.set_color(LIGHT_RED_COLOR)\n        )\n        self.play(\n            DrawBorderThenFill(arrow_den), \n            Write(text_den), \n            text3[0][2].animate.set_color(GREEN_COLOR)\n        )\n        self.wait(1)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)\n\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef Division(numerator, denominator):\n    result = numerator // denominator\n    integerPart = int(result * denominator)\n    remainder = numerator - integerPart\n    \n    gp = VGroup(\n        VGroup(\n            MathTex(str(numerator), color=LIGHT_PURPLE_COLOR),\n            VGroup(\n                Line((0, 0, 0), (0, 0.6, 0), color=LIGHT_PURPLE_COLOR),\n                Line((0, 0, 0), (0.6, 0, 0), color=LIGHT_PURPLE_COLOR),\n                MathTex(str(denominator), color=LIGHT_PURPLE_COLOR).shift(0.3 * UP + 0.32 * RIGHT)\n            ) \n        ).arrange(RIGHT),\n        VGroup(\n            MathTex(\"-\", color=SAND_COLOR),\n            MathTex(r\"\\frac{\" + str(integerPart) + \"}{\" + str(remainder) + \"}\", color=SAND_COLOR),\n            MathTex(str(result), color=SAND_COLOR)\n        ).arrange(RIGHT)\n    )\n\n    gp[1].shift(0.5 * LEFT + 0.9 * DOWN)\n    gp[1][0].shift(0.3 * UP)\n    gp[1][1][0][1].scale(2).shift(0.03 * UP)\n    gp[1][2].shift(0.3 * UP + 0.22 * RIGHT)\n\n    return gp\n\nclass FiveDivision(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(5, 1)\n        by_one.scale(1.4)\n        by_two = Division(5, 2)\n        by_two.scale(1.4)\n        by_three = Division(5, 3)\n        by_three.scale(1.4)\n        by_four = Division(5, 4)\n        by_four.scale(1.4)\n        by_five = Division(5, 5)\n        by_five.scale(1.4)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=1),\n            by_five\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_five, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            lag_ratio=0.3,\n            run_time=1.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass HowManyPrimes(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        text_1 = VGroup(\n            Text(\"Existem infinitos\", color=TEXT_COLOR),\n            Text(\"n\u00fameros primos!\", color=TEXT_COLOR)\n        )\n        text_1[0][7:].set(color=LIGHT_PURPLE_COLOR)\n        text_1.scale(1.4)\n        text_1.arrange(DOWN, buff=0.5)\n\n        self.play(Write(text_1), run_time=0.7)\n        self.wait(1)\n        self.play(text_1.animate.scale(0), run_time=0.7)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nclass QuestionOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal_1 = ImageMobject(\"./assets/Asset 2 - Flipped.png\")\n        animal_1.scale(0.4)\n        animal_1.shift(9 * LEFT)\n        animal_2 = ImageMobject(\"./assets/Asset 3.png\")\n        animal_2.scale(0.4)\n        animal_2.shift(9 * RIGHT)\n        animal_3 = ImageMobject(\"./assets/Asset 4.png\")\n        animal_3.scale(0.4)\n        animal_3.shift(9 * RIGHT)\n        speech_1 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_PURPLE_COLOR)\n        speech_1.shift(3 * UP + 8 * LEFT)\n        speech_2 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_RED_COLOR)\n        speech_2.shift(3 * UP + 8 * RIGHT)\n        speech_2.flip(UP)\n        speech_3 = speech_2.copy()\n        speech_3.set(fill_color=GREEN_COLOR)\n        text_1 = VGroup(\n            Text(\"O que s\u00e3o\", color=WHITE),\n            Text(\"n\u00fameros primos?\", color=WHITE)\n        )\n        text_1.scale(0.6)\n        text_1.arrange(DOWN, buff=0.1)\n        text_1.shift(3 * UP + 8 * LEFT)\n        text_2 = VGroup(\n            Text(\"S\u00e3o n\u00fameros que\", color=WHITE),\n            Text(\"t\u00eam somente dois\", color=WHITE),\n            Text(\"divisores,\", color=WHITE)\n        )\n        text_2.scale(0.6)\n        text_2.arrange(DOWN, buff=0.1)\n        text_2.shift(3.03 * UP + 8 * RIGHT)\n        text_2[2].shift(0.1 * DOWN)\n        text_3 = VGroup(\n            Text(\"1 e ele\", color=WHITE),\n            Text(\"mesmo.\", color=WHITE)\n        )\n        text_3.scale(0.6)\n        text_3.arrange(DOWN, buff=0.3)\n        text_3.shift(3.03 * UP + LEFT)\n        text_4 = VGroup(\n            Text(\"O n\u00famero cinco\", color=WHITE),\n            Text(\"\u00e9 primo?\", color=WHITE)\n        )\n        text_4.scale(0.6)\n        text_4.arrange(DOWN, buff=0.2)\n        text_4.shift(3 * UP + 8 * RIGHT)\n\n        self.play(\n            animal_1.animate.shift(7 * RIGHT), \n            speech_1.animate.shift(9 * RIGHT),\n            text_1.animate.shift(9 * RIGHT),\n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            animal_1.animate.shift(9 * LEFT), \n            speech_1.animate.shift(9 * LEFT), \n            text_1.animate.shift(9 * LEFT), \n            animal_2.animate.shift(7 * LEFT), \n            speech_2.animate.shift(9 * LEFT), \n            text_2.animate.shift(9 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            FadeOut(text_2),\n            FadeIn(text_3), \n            run_time=0.5\n        )\n        self.wait(2.5)\n        self.play(\n            animal_2.animate.shift(9 * LEFT), \n            speech_2.animate.shift(9 * LEFT), \n            text_3.animate.shift(9 * LEFT), \n            animal_3.animate.shift(7 * LEFT), \n            speech_3.animate.shift(9 * LEFT), \n            text_4.animate.shift(9 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            animal_3.animate.shift(9 * LEFT), \n            speech_3.animate.shift(8 * LEFT), \n            text_4.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nclass QuestionTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal = ImageMobject(\"./assets/Asset 1.png\")\n        animal.scale(0.4)\n        animal.shift(9 * LEFT)\n        speech = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=BROWN_COLOR)\n        speech.shift(3 * UP + 8 * LEFT)\n        text = VGroup(\n            Text(\"O n\u00famero seis\", color=WHITE),\n            Text(\"\u00e9 primo?\", color=WHITE)\n        )\n        text.scale(0.6)\n        text.arrange(DOWN, buff=0.1)\n        text.shift(3 * UP + 8 * LEFT)\n\n        self.play(\n            animal.animate.shift(7 * RIGHT), \n            speech.animate.shift(9 * RIGHT), \n            text.animate.shift(9 * RIGHT), \n            run_time=0.7\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.7)\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef Division(numerator, denominator):\n    result = numerator // denominator\n    integerPart = int(result * denominator)\n    remainder = numerator - integerPart\n    \n    gp = VGroup(\n        VGroup(\n            MathTex(str(numerator), color=LIGHT_PURPLE_COLOR),\n            VGroup(\n                Line((0, 0, 0), (0, 0.6, 0), color=LIGHT_PURPLE_COLOR),\n                Line((0, 0, 0), (0.6, 0, 0), color=LIGHT_PURPLE_COLOR),\n                MathTex(str(denominator), color=LIGHT_PURPLE_COLOR).shift(0.3 * UP + 0.32 * RIGHT)\n            ) \n        ).arrange(RIGHT),\n        VGroup(\n            MathTex(\"-\", color=SAND_COLOR),\n            MathTex(r\"\\frac{\" + str(integerPart) + \"}{\" + str(remainder) + \"}\", color=SAND_COLOR),\n            MathTex(str(result), color=SAND_COLOR)\n        ).arrange(RIGHT)\n    )\n\n    gp[1].shift(0.5 * LEFT + 0.9 * DOWN)\n    gp[1][0].shift(0.3 * UP)\n    gp[1][1][0][1].scale(2).shift(0.03 * UP)\n    gp[1][2].shift(0.3 * UP + 0.22 * RIGHT)\n\n    return gp\n\nclass SixDivision(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.4)\n        by_two = Division(6, 2)\n        by_two.scale(1.4)\n        by_three = Division(6, 3)\n        by_three.scale(1.4)\n        by_four = Division(6, 4)\n        by_four.scale(1.4)\n        by_five = Division(6, 5)\n        by_five.scale(1.4)\n        by_six = Division(6, 6)\n        by_six.scale(1.4)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_three,\n                by_four\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=1)\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2.5)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SmallerPrime(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal_1 = ImageMobject(\"./assets/Asset 2 - Flipped.png\")\n        animal_1.scale(0.4)\n        animal_1.shift(9 * LEFT)\n        animal_2 = ImageMobject(\"./assets/Asset 3.png\")\n        animal_2.scale(0.4)\n        animal_2.shift(9 * RIGHT)\n        animal_3 = ImageMobject(\"./assets/Asset 1.png\")\n        animal_3.scale(0.4)\n        animal_3.shift(9 * RIGHT)\n        speech_1 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_PURPLE_COLOR)\n        speech_1.shift(3 * UP + 7 * LEFT)\n        speech_2 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_RED_COLOR)\n        speech_2.shift(3 * UP + 7 * RIGHT).flip(UP)\n        speech_3 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=BROWN_COLOR)\n        speech_3.shift(3 * UP + 7 * RIGHT).flip(UP)\n        text_1 = VGroup(\n            Text(\"E qual \u00e9 o menor\", color=WHITE),\n            Text(\"n\u00famero primo?\", color=WHITE)\n        )\n        text_1.scale(0.6)\n        text_1.arrange(DOWN, buff=0.1)\n        text_1.shift(3 * UP + 7 * LEFT)\n        text_2 = VGroup(\n            Text(\"O menor primo\", color=WHITE),\n            Text(\"\u00e9 o dois!\", color=WHITE),\n        )\n        text_2.scale(0.6)\n        text_2.arrange(DOWN, buff=0.1)\n        text_2.shift(3.03 * UP + 7 * RIGHT)\n        text_3 = VGroup(\n            Text(\"O n\u00famero um n\u00e3o\", color=WHITE),\n            Text(\"\u00e9 primo, pois tem\", color=WHITE),\n            Text(\"um s\u00f3 divisor.\", color=WHITE)\n        )\n        text_3.scale(0.6)\n        text_3.arrange(DOWN, buff=0.1)\n        text_3.shift(3.03 * UP + 7 * RIGHT)\n        text_3[1].shift(0.03 * DOWN)\n\n        self.play(\n            animal_1.animate.shift(7 * RIGHT), \n            speech_1.animate.shift(8 * RIGHT),\n            text_1.animate.shift(8 * RIGHT),\n            run_time=0.7\n        )\n        self.wait(1.7)\n        self.play(\n            animal_1.animate.shift(9 * LEFT), \n            speech_1.animate.shift(9 * LEFT),\n            text_1.animate.shift(9 * LEFT),\n            animal_2.animate.shift(7 * LEFT), \n            speech_2.animate.shift(8 * LEFT), \n            text_2.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.wait(1.9)\n        self.play(\n            animal_2.animate.shift(9 * LEFT), \n            speech_2.animate.shift(9 * LEFT),\n            text_2.animate.shift(9 * LEFT),\n            animal_3.animate.shift(7 * LEFT), \n            speech_3.animate.shift(8 * LEFT), \n            text_3.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.4)\n        self.play(\n            animal_3.animate.shift(9 * LEFT), \n            speech_3.animate.shift(9 * LEFT),\n            text_3.animate.shift(9 * LEFT),\n            run_time=0.7\n        )\n        self.remove(*self.mobjects)\n"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass TenPrimes(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        text = Tex(\"Dez primeiros primos\", color=LIGHT_RED_COLOR)\n        text.scale(1.5)\n        primes = VGroup(*[Tex(str(prime), color=LIGHT_BLUE_COLOR) for prime in range(2, 30) if is_prime(prime)])\n        primes.scale(1.5)\n        first_five = VGroup(*primes[0:5])\n        first_five.arrange(RIGHT, buff=0.8)\n        next_five = VGroup(*primes[5:])\n        next_five.arrange(RIGHT, buff=0.5)\n        Group(\n            text,\n            first_five, \n            next_five\n        ).arrange(DOWN, buff=0.8)\n\n        self.play(Write(text), run_time=0.7)\n\n        for prime in primes:\n            self.play(DrawBorderThenFill(prime), run_time=0.3, rate_func=linear)\n\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.scale(0), run_time=0.7)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass WhyPrime(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        numbers = VGroup(\n            Tex(\"2 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"3 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"4 = 2 x 2\", color=LIGHT_BLUE_COLOR),\n            Tex(\"5 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"6 = 2 x 3\", color=LIGHT_BLUE_COLOR),\n            Tex(\"7 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"8 = 2 x 2 x 2\", color=LIGHT_BLUE_COLOR),\n            Tex(\"9 = 3 x 3\", color=LIGHT_BLUE_COLOR),\n            Tex(\"10 = 2 x 5\", color=LIGHT_BLUE_COLOR),\n            Tex(\"11 \u00e9 primo\", color=LIGHT_RED_COLOR)\n        )\n        numbers.scale(1.5)\n        numbers.arrange(DOWN, buff=0.7)\n\n        self.play(Write(numbers), run_time=3)\n        self.wait(2)\n        self.play(Unwrite(numbers, reverse=False))"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass AlgebraOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = MathOperation(\"./assets/Asset 1.png\", \"+ 6 = 12\")\n        operation_2 = Tex(r\"\\textbf{6} + 6 = 12\", color=BLACK)\n        operation_2[0][0].set(color=ORANGE_COLOR)\n        operation_2.scale(1.8)\n        conclusion_1 = MathOperation(\"./assets/Asset 1.png\", \"= 6\")\n        conclusion_1.scale(0.8)\n        Group(\n            operation_1,\n            operation_2,\n            conclusion_1\n        ).arrange(DOWN, buff=0.7)\n        \n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(SpinInFromNothing(conclusion_1))\n        self.wait(1)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass AlgebraThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = MathOperation(\"./assets/Asset 3.png\", \"* 6 = 24\")\n        operation_2 = Tex(r\"\\textbf{a} * 6 = 24\", color=BLACK)\n        operation_2[0][0].set(color=ORANGE_COLOR)\n        operation_2.scale(1.8)\n        operation_3 = Tex(r\"\\textbf{4} * 6 = 24\", color=BLACK)\n        operation_3[0][0].set(color=ORANGE_COLOR)\n        operation_3.scale(1.8)\n        conclusion_1 = MathOperation(\"./assets/Asset 3.png\", \"= 4\")\n        conclusion_2 = Tex(r\"\\textbf{a} = 4\", color=BLACK)\n        conclusion_2[0][0].set(color=ORANGE_COLOR)\n        conclusion_1.scale(0.8)\n        conclusion_2.scale(1.8)\n        Group(\n            operation_1,\n            operation_2,\n            operation_3,\n            Group(conclusion_1, conclusion_2).arrange(RIGHT, buff=0.5)\n        ).arrange(DOWN, buff=0.7)\n        \n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(Transform(operation_2.copy(), operation_3))\n        self.wait(1)\n        self.play(\n            SpinInFromNothing(conclusion_1),\n            SpinInFromNothing(conclusion_2)\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\ndef LetterOperation(expression, expression_result):\n    inner_group = Group(\n        Tex(expression, color=TEXT_COLOR).scale(1.8),\n        Tex(expression_result, color=TEXT_COLOR).scale(1.8),\n    ).arrange(DOWN, buff=0.8)\n    box = DashedVMobject(\n        SurroundingRectangle(inner_group, color=AQUA_BLUE_COLOR, buff=0.5),\n        num_dashes=25,\n        dashed_ratio=0.7\n    )\n    outer_group = Group(\n        box,\n        inner_group\n    )\n\n    return outer_group\n\nclass AlgebraWithLetters(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = LetterOperation(\"x + 3 = 5\", \"x = 2\")\n        operation_2 = LetterOperation(\"9 - d = 2\", \"d = 7\")\n        operation_3 = LetterOperation(\"2 . a = 6\", \"a = 3\")\n        Group(\n            operation_1, \n            operation_2, \n            operation_3\n        ).arrange(DOWN, buff=1)\n        \n        self.play(SpinInFromNothing(operation_1), run_time=0.7)\n        self.wait(3)\n        self.play(SpinInFromNothing(operation_2), run_time=0.7)\n        self.wait(3)\n        self.play(SpinInFromNothing(operation_3), run_time=0.7)\n        self.wait(4)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nclass NoGradientBarChart(BarChart):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _update_colors(self):\n        for i in range(len(self.bar_colors)):\n            self.bars[i].set(color=self.bar_colors[i])\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        table = Table(\n            [\n                [\"Pablo\", \"Banana\"],\n                [\"Gabriela\", \"Morango\"],\n                [\"Bianca\", \"Laranja\"],\n                [\"Murilo\", \"Morango\"],\n                [\"Heitor\", \"Banana\"],\n                [\"Isabela\", \"Banana\"],\n            ],\n            col_labels=[Text(\"Nome\"), Text(\"Fruta Favorita\")],\n            include_outer_lines=True\n        )\n        table.get_vertical_lines().set(color=BLACK)\n        table.get_horizontal_lines().set(color=BLACK)\n        table.get_entries().set(color=BLACK)\n        table.scale(0.5)\n        chart = BarChart(\n            [0, 0, 0],\n            y_range=[0, 3, 1],\n            x_length=6,\n            y_length=4,\n            axis_config={\"color\": BLACK, \"include_ticks\": False},\n            bar_colors=[LIGHT_YELLOW_COLOR, LIGHT_ORANGE_COLOR, LIGHT_RED_COLOR],\n            bar_fill_opacity=1,\n            bar_names=[\"Banana\", \"Laranja\", \"Morango\"]\n        )\n        chart.x_axis.set(color=BLACK)\n        chart.y_axis.set(color=BACKGROUND_COLOR)\n        chart[2][0][1].set(color=BLACK)\n        Group(table, chart).arrange(DOWN, buff=2)\n        x_label = Tex(\"Frutas favoritas\", color=BLACK)\n        x_label.scale(0.7)\n        x_label.next_to(chart, DOWN)\n        x_label.shift(0.2 * RIGHT)\n        y_label = Tex(\"Quantidade de pessoas\", color=BLACK)\n        y_label.scale(0.7)\n        y_label.rotate(PI/2)\n        y_label.next_to(chart, LEFT)\n        y_label.shift(0.2 * UP)\n        table.shift(9 * RIGHT)\n        lines = VGroup(\n            Line(chart.coords_to_point(0, 1, 0), chart.coords_to_point(3, 1, 0), color=BLACK, stroke_width=1),\n            Line(chart.coords_to_point(0, 2, 0), chart.coords_to_point(3, 2, 0), color=BLACK, stroke_width=1),\n            Line(chart.coords_to_point(0, 3, 0), chart.coords_to_point(3, 3, 0), color=BLACK, stroke_width=1)\n        )\n\n        self.play(table.animate.shift(9 * LEFT), run_time=0.7)\n        self.wait(1)\n        self.play(\n            FadeIn(lines),\n            FadeIn(chart), \n            FadeIn(x_label), \n            FadeIn(y_label), \n            run_time=0.4\n        )\n        self.wait(1)\n\n        banana_cells = Group(\n            table.get_highlighted_cell((2, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((2, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 2), color=LIGHT_YELLOW_COLOR)\n        )\n        add_to_back(self, banana_cells)\n\n        self.play(FadeIn(banana_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 0, 0]), run_time=1.3)\n        self.play(FadeOut(banana_cells), run_time=0.5)\n\n        orange_cells = Group(\n            table.get_highlighted_cell((4, 1), color=LIGHT_ORANGE_COLOR),\n            table.get_highlighted_cell((4, 2), color=LIGHT_ORANGE_COLOR)\n        )\n        add_to_back(self, orange_cells)\n\n        self.play(FadeIn(orange_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 1, 0]), run_time=0.7)\n        self.play(FadeOut(orange_cells), run_time=0.5)\n\n        strawberry_cells = Group(\n            table.get_highlighted_cell((3, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((3, 2), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 2), color=LIGHT_RED_COLOR)\n        )\n        add_to_back(self, strawberry_cells)\n\n        self.play(FadeIn(strawberry_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 1, 2]), run_time=1)\n        self.play(FadeOut(strawberry_cells), run_time=0.5)\n\n        self.wait(2)\n\n        self.play(\n            FadeOut(lines),\n            FadeOut(chart), \n            FadeOut(x_label), \n            FadeOut(y_label), \n            run_time=0.4\n        )\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        table = Table(\n            [\n                [\"Pablo\", \"Banana\"],\n                [\"Gabriela\", \"Morango\"],\n                [\"Bianca\", \"Laranja\"],\n                [\"Murilo\", \"Morango\"],\n                [\"Heitor\", \"Banana\"],\n                [\"Isabela\", \"Banana\"],\n            ],\n            col_labels=[Text(\"Nome\"), Text(\"Fruta Favorita\")],\n            include_outer_lines=True\n        )\n        table.get_vertical_lines().set(color=BLACK)\n        table.get_horizontal_lines().set(color=BLACK)\n        table.get_entries().set(color=BLACK)\n        table.scale(0.5)\n        circle = Circle(2, color=BLACK)\n        legend = VGroup(\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_YELLOW_COLOR), \n                Tex(\"Banana\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT),\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_ORANGE_COLOR), \n                Tex(\"Laranja\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT),\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_RED_COLOR), \n                Tex(\"Morango\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT)\n        ).arrange(DOWN, aligned_edge=LEFT)\n        table.shift(3.3 * UP)\n        graph = Group(circle, legend)\n        legend.shift(3 * RIGHT)\n        graph.shift(3.4 * DOWN)\n        basic_line = Line(circle.get_center(), circle.get_top(), color=BLACK)\n        auxiliary_lines = VGroup(\n            basic_line.copy(),\n            basic_line.copy().rotate(PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(2 * PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(PI, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(4 * PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(5 * PI / 3, about_point=basic_line.get_bottom())\n        )\n        banana_angle = ValueTracker(0)\n        banana_max_angle = PI\n        banana_sector = always_redraw(lambda: \n            AnnularSector(0, 2, banana_angle.get_value(), PI/2, stroke_width=0, color=LIGHT_YELLOW_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n        strawberry_angle = ValueTracker(0)\n        strawberry_max_angle = 2 * PI / 3\n        strawberry_sector = always_redraw(lambda: \n            AnnularSector(0, 2, strawberry_angle.get_value(), 6*PI/4, stroke_width=0, color=LIGHT_RED_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n        orange_angle = ValueTracker(0)\n        orange_max_angle = PI / 3\n        orange_sector = always_redraw(lambda:\n            AnnularSector(0, 2, orange_angle.get_value(), 13*PI/6, stroke_width=0, color=LIGHT_ORANGE_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n\n        self.add(table)\n        self.play(FadeIn(graph), run_time=0.5)\n        self.play(FadeIn(auxiliary_lines), run_time=0.5)\n        self.wait(1)\n        \n        banana_cells = Group(\n            table.get_highlighted_cell((2, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((2, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 2), color=LIGHT_YELLOW_COLOR)\n        )\n        add_to_back(self, banana_cells, banana_sector)\n\n        self.play(FadeIn(banana_cells), run_time=0.5)\n        self.play(banana_angle.animate.set_value(banana_max_angle), run_time=2)\n        self.play(FadeOut(banana_cells), run_time=0.5)\n\n        banana_sector.clear_updaters()\n        strawberry_cells = Group(\n            table.get_highlighted_cell((3, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((3, 2), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 2), color=LIGHT_RED_COLOR)\n        )\n        add_to_back(self, strawberry_cells, strawberry_sector)\n\n\n        self.play(FadeIn(strawberry_cells), run_time=0.5)\n        self.play(strawberry_angle.animate.set_value(strawberry_max_angle), run_time=1.5)\n        self.play(FadeOut(strawberry_cells), run_time=0.5) \n\n        strawberry_sector.clear_updaters()\n        orange_cells = Group(\n            table.get_highlighted_cell((4, 1), color=LIGHT_ORANGE_COLOR),\n            table.get_highlighted_cell((4, 2), color=LIGHT_ORANGE_COLOR)\n        )\n        add_to_back(self, orange_cells, orange_sector)\n\n        self.play(FadeIn(orange_cells), run_time=0.5)\n        self.play(orange_angle.animate.set_value(orange_max_angle), run_time=1)\n        self.play(\n            FadeOut(auxiliary_lines[1]),\n            FadeOut(auxiliary_lines[2]),\n            FadeOut(auxiliary_lines[4]),\n            FadeOut(orange_cells), \n            run_time=0.5\n        )\n\n        orange_sector.clear_updaters()      \n\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.7)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Lucro mensal em reais\", color=BLACK)\n        axes = Axes(\n            (0, 7), \n            (0, 9000, 1000), \n            x_length=7, \n            y_length=7, \n            axis_config={\"color\": BLACK, \"include_tip\": False},\n            y_axis_config={\"include_numbers\": True},\n            x_axis_config={\"numbers_to_include\": [1, 2, 3, 4, 5, 6]}\n        )\n        axes.y_axis.set(color=BLACK)\n        axes.x_axis.add_labels({\n            1: Tex(\"Janeiro\", color=BLACK),\n            2: Tex(\"Fevereiro\", color=BLACK),\n            3: Tex(\"Mar\u00e7o\", color=BLACK),\n            4: Tex(\"Abril\", color=BLACK),\n            5: Tex(\"Maio\", color=BLACK),\n            6: Tex(\"Junho\", color=BLACK)\n        }, font_size=24)\n        axes.shift(0.5 * RIGHT)\n        title.next_to(axes, UP, buff=0.3)\n        title.shift(0.5 * RIGHT)\n        auxiliary_lines = VGroup(\n            Line(axes.coords_to_point(0, 1000, 0), axes.coords_to_point(7, 1000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 2000, 0), axes.coords_to_point(7, 2000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 3000, 0), axes.coords_to_point(7, 3000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 4000, 0), axes.coords_to_point(7, 4000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 5000, 0), axes.coords_to_point(7, 5000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 6000, 0), axes.coords_to_point(7, 6000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 7000, 0), axes.coords_to_point(7, 7000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 8000, 0), axes.coords_to_point(7, 8000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 9000, 0), axes.coords_to_point(7, 9000, 0), color=BLACK, stroke_width=1)\n        )\n        points = VGroup(\n            Dot(axes.coords_to_point(1, 5000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(2, 3000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(3, 7000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(4, 8000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(5, 6000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(6, 5000, 0), color=LIGHT_BLUE_COLOR)\n        )\n        lines = VGroup()\n\n        self.play(\n            Write(title),\n            Write(axes), \n            run_time=1\n        )\n        self.play(\n            LaggedStart(\n                *[Create(point) for point in points],\n                lag_ratio=0.2,\n                run_time=1\n            )\n        )\n\n        add_to_back(self, auxiliary_lines)\n        self.play(FadeIn(auxiliary_lines), run_time=0.5)\n\n        for i in range(5):\n            lines += Line(points[i], points[i + 1], color=LIGHT_BLUE_COLOR)\n            self.play(Create(lines[i]), run_time=0.2)\n\n        # Jan to Feb\n        self.play(\n            points[0].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[1].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[0].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[0].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[1].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[0].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n        # Feb to Apr\n        self.play(\n            points[1].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[2].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[3].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[1].animate.set(color=LIGHT_RED_COLOR),\n            lines[2].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[1].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[2].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[3].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[1].animate.set(color=LIGHT_BLUE_COLOR),\n            lines[2].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n        # Apr to June\n        self.play(\n            points[3].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[4].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[5].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[3].animate.set(color=LIGHT_RED_COLOR),\n            lines[4].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[3].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[4].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[5].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[3].animate.set(color=LIGHT_BLUE_COLOR),\n            lines[4].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{2}{3}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{4}{6}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=3)\n        arrow_up = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up = Tex(r\"Multiplicado por 2\", color=LIGHT_BLUE_COLOR)\n        text_up.next_to(arrow_up, UP)\n        text_down = Tex(r\"Multiplicado por 2\", color=LIGHT_BLUE_COLOR)\n        text_down.next_to(arrow_down, DOWN)\n        equal = MathTex(\"=\", color=LIGHT_BLUE_COLOR)\n        equal.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up),\n            Write(text_up, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down),\n            Write(text_down, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal), run_time=0.5)\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingNonEquivalent(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{3}{6}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{9}{12}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=3)\n        arrow_up = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_RED_COLOR\n        ).add_tip()\n        text_up = Tex(r\"Multiplicado por 3\", color=LIGHT_BLUE_COLOR)\n        text_up.next_to(arrow_up, UP)\n        text_down = Tex(r\"Multiplicado por 2\", color=LIGHT_RED_COLOR)\n        text_down.next_to(arrow_down, DOWN)\n        equal = MathTex(r\"\\neq\", color=LIGHT_RED_COLOR)\n        equal.shift(0.1 * LEFT)\n        equal.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up),\n            Write(text_up, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down),\n            Write(text_down, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal), run_time=0.5)\n        self.wait(0.5)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingTwoSteps(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{4}{8}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{5}{10}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=2)\n        arrow_up_1 = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_1 = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_up_1.scale(0.7)\n        text_up_1.next_to(arrow_up_1, UP)\n        text_down_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_down_1.scale(0.7)\n        text_down_1.next_to(arrow_down_1, DOWN)\n        equal_1 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_1.shift(1.5 * LEFT)\n        equal_1.scale(2)\n        arrow_up_2 = ArcBetweenPoints(\n            fractions[1].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[2].get_top() + 0.2 * UP, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_2 = ArcBetweenPoints(\n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[2].get_bottom() + 0.2 * DOWN, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_up_2.scale(0.7)\n        text_up_2.next_to(arrow_up_2, UP, buff=0.2)\n        text_down_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_down_2.scale(0.7)\n        text_down_2.next_to(arrow_down_2, DOWN, buff=0.2)\n        equal_2 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_2.shift(1.1 * RIGHT)\n        equal_2.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up_1),\n            Write(text_up_1, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_1),\n            Write(text_down_1, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_1), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_1), \n            FadeOut(arrow_down_1), \n            FadeOut(text_up_1), \n            FadeOut(text_down_1), \n            run_time=0.7\n        )\n        self.play(\n            Write(arrow_up_2),\n            Write(text_up_2, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_2),\n            Write(text_down_2, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_2), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_2), \n            FadeOut(arrow_down_2), \n            FadeOut(text_up_2), \n            FadeOut(text_down_2), \n            run_time=0.7\n        )\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SixDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.3)\n        by_two = Division(6, 2)\n        by_two.scale(1.3)\n        by_three = Division(6, 3)\n        by_three.scale(1.3)\n        by_four = Division(6, 4)\n        by_four.scale(1.3)\n        by_five = Division(6, 5)\n        by_five.scale(1.3)\n        by_six = Division(6, 6)\n        by_six.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass TenDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(10, 1)\n        by_one.scale(1.3)\n        by_two = Division(10, 2)\n        by_two.scale(1.3)\n        by_three = Division(10, 3)\n        by_three.scale(1.3)\n        by_four = Division(10, 4)\n        by_four.scale(1.3)\n        by_five = Division(10, 5)\n        by_five.scale(1.3)\n        by_six = Division(10, 6)\n        by_six.scale(1.3)\n        by_seven = Division(10, 7)\n        by_seven.scale(1.3)\n        by_eight = Division(10, 8)\n        by_eight.scale(1.3)\n        by_nine = Division(10, 9)\n        by_nine.scale(1.3)\n        by_ten = Division(10, 10)\n        by_ten.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n                by_three\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_four,\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_seven,\n                by_eight,\n                by_nine\n            ).arrange(RIGHT, buff=0.5),\n            by_ten\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_five, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_ten, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            FadeIn(by_seven),\n            FadeIn(by_eight),\n            FadeIn(by_nine),\n            FadeIn(by_ten),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
  },
  {
    "text": "from manim_physics import *\n\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(wire)\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)"
  },
  {
    "text": "       from manim import *\n\nfrom manim_physics import *\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(\n            wire,\n            x_range=[-4, 4],\n            y_range=[-4, 4],\n        )\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)"
  },
  {
    "text": "from manim import *\n\nfrom manim_physics import *\n\nclass RayExampleScene(Scene):\n    def construct(self):\n        lens_style = {\"fill_opacity\": 0.5, \"color\": BLUE}\n        a = Lens(-5, 1, **lens_style).shift(LEFT)\n        a2 = Lens(5, 1, **lens_style).shift(RIGHT)\n        b = [\n            Ray(LEFT * 5 + UP * i, RIGHT, 8, [a, a2], color=RED)\n            for i in np.linspace(-2, 2, 10)\n        ]\n        self.add(a, a2, *b)"
  },
  {
    "text": "from manim import *\n\nfrom manim_physics import *\n# use a SpaceScene to utilize all specific rigid-mechanics methods\nclass TwoObjectsFalling(SpaceScene):\n    def construct(self):\n        circle = Circle().shift(UP)\n        circle.set_fill(RED, 1)\n        circle.shift(DOWN + RIGHT)\n\n        rect = Square().shift(UP)\n        rect.rotate(PI / 4)\n        rect.set_fill(YELLOW_A, 1)\n        rect.shift(UP * 2)\n        rect.scale(0.5)\n\n        ground = Line([-4, -3.5, 0], [4, -3.5, 0])\n        wall1 = Line([-4, -3.5, 0], [-4, 3.5, 0])\n        wall2 = Line([4, -3.5, 0], [4, 3.5, 0])\n        walls = VGroup(ground, wall1, wall2)\n        self.add(walls)\n\n        self.play(\n            DrawBorderThenFill(circle),\n            DrawBorderThenFill(rect),\n        )\n        self.make_rigid_body(rect, circle)  # Mobjects will move with gravity\n        self.make_static_body(walls)  # Mobjects will stay in place\n        self.wait(5)\n        # during wait time, the circle and rect would move according to the simulate updater"
  },
  {
    "text": "from manim import *\n\nfrom manim_physics import *\n\nclass MultiPendulumExample(SpaceScene):\n    def construct(self):\n        p = MultiPendulum(RIGHT, LEFT)\n        self.add(p)\n        self.make_rigid_body(*p.bobs)\n        p.start_swinging()\n        self.add(TracedPath(p.bobs[-1].get_center, stroke_color=BLUE))\n        self.wait(10)"
  },
  {
    "text": "\nfrom manim import *\n\nfrom manim_physics import *\nclass PendulumExample(SpaceScene):\n    def construct(self):\n        pends = VGroup(*[Pendulum(i) for i in np.linspace(1, 5, 7)])\n        self.add(pends)\n        for p in pends:\n            self.make_rigid_body(*p.bobs)\n            p.start_swinging()\n        self.wait(10)"
  },
  {
    "text": "from manim import *\n\nclass LinearWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(60 * DEGREES, -45 * DEGREES)\n        wave = LinearWave()\n        self.add(wave)\n        wave.start_wave()\n        self.wait()\n        wave.stop_wave()"
  },
  {
    "text": "from manim import *\n\nclass RadialWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(60 * DEGREES, -45 * DEGREES)\n        wave = RadialWave(\n            LEFT * 2 + DOWN * 5,  # Two source of waves\n            RIGHT * 2 + DOWN * 5,\n            checkerboard_colors=[BLUE_D],\n            stroke_width=0,\n        )\n        self.add(wave)\n        wave.start_wave()\n        self.wait()\n        wave.stop_wave()"
  },
  {
    "text": "\nfrom manim import *\n\nfrom manim_physics import *\n\nclass StandingWaveExampleScene(Scene):\n    def construct(self):\n        wave1 = StandingWave(1)\n        wave2 = StandingWave(2)\n        wave3 = StandingWave(3)\n        wave4 = StandingWave(4)\n        waves = VGroup(wave1, wave2, wave3, wave4)\n        waves.arrange(DOWN).move_to(ORIGIN)\n        self.add(waves)\n        for wave in waves:\n            wave.start_wave()\n        self.wait()"
  },
  {
    "text": "from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)"
  },
  {
    "text": "from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)"
  },
  {
    "text": "from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)"
  },
  {
    "text": "from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)"
  },
  {
    "text": "from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef positive() -> Mobject:\n    return circle_with_text(0.25, \"+\", RED_A, 32, BLACK, 4, RED_A)\n\n\ndef negative() -> Mobject:\n    return circle_with_text(0.25, \"-\", BLUE_A, 32, BLACK, 4, BLUE_A)"
  },
  {
    "text": "from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\n\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n\ndef oxygen() -> Mobject:\n    list = []\n    start = 0.3\n    end = 0.6\n    list.append(Line(start=LEFT * start, end=LEFT * end))\n    list.append(Line(start=RIGHT * start, end=RIGHT * end))\n    list.append(Line(start=UP * start, end=UP * end))\n    list.append(Line(start=DOWN * start, end=DOWN * end))\n    list = map(lambda x: x.set_opacity(0.7), list)\n    return VGroup(circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\ndef metal_oxid(rows: int, cols: int, scale=1.5) -> Mobject:\n    list = []\n    for i in range(rows):\n        for j in range(cols):\n            if (j + i) % 2 == 0:\n                list.append(oxygen().set_x(i / scale).set_y(j / scale))\n            else:\n                list.append(metal().set_x(i / scale).set_y(j / scale))\n    return VGroup(*list).set_x(0).set_y(0)"
  },
  {
    "text": "from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef carbon(small: int = False) -> Mobject:\n    return circle_with_text(\n        0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n        \"C\",\n        GRAY_B,\n        30 if small == 0 else (24 if small == 1 else 27),\n        WHITE,\n        1,\n    ).set_z_index(5 if small == 1 else 10)"
  },
  {
    "text": "from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef carbon_grid(rows: int) -> Mobject:\n    list = []\n    for i in range(rows):\n        list.append(carbon_layer().set_y(i * 1.5))\n    return VGroup(*list).set_x(0).set_y(0)\n\n\ndef carbon(small: int = False) -> Mobject:\n    return circle_with_text(\n        0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n        \"C\",\n        GRAY_B,\n        30 if small == 0 else (24 if small == 1 else 27),\n        WHITE,\n        1,\n    ).set_z_index(5 if small == 1 else 10)\n\n\ndef carbon_layer() -> Mobject:\n    list = []\n    positions = [\n        [-1.2, 0, 0],\n        [-0.45, 0.4, 0],\n        [0.45, 0.4, 0],\n        [1.2, 0, 0],\n        [0.55, -0.3, 0],\n        [-0.55, -0.3, 0],\n    ]\n    small = [2, 1, 1, 2, 0, 0]\n    for i in range(len(positions)):\n        list.append(Line(positions[i], positions[i - 1], color=GREY_B).set_z_index(4))\n        list.append(carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n    list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n    return VGroup(*list)"
  },
  {
    "text": "from manim import *\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n    return animations"
  },
  {
    "text": "from manim import *\n\n\ndef create_dc_motor() -> Mobject:\n    r_inner = Rectangle(GREY_D, 2.8, 0.3).set_fill([RED, BLUE], 1).set_z_index(5).rotate(1)\n    c_inner = Circle(0.68, GREY_B).set_fill(GREY_B, 1).set_z_index(4)\n    c_hidden = Circle(0.75, WHITE).set_fill(WHITE, 1).set_z_index(3)\n    c_middle = Circle(1.6, GREY_D).set_fill(WHITE, 1).set_z_index(2)\n    c_outer = Circle(2, GREY_D).set_fill([RED, BLUE], 1).set_z_index(1).rotate(1 / 4 * np.pi)\n    a = Arc(0.7, 1.2, np.pi - 0.4, color=GOLD_D, stroke_width=10).set_z_index(4)\n    b = Arc(0.7, 0.8, -np.pi + 0.4, color=GOLD_D, stroke_width=10).set_z_index(4)\n    upper_rect = (\n        Rectangle(GREY_D, height=1, width=0.3).set_fill([GREY_C, BLUE], 1).set_z_index(2).set_y(1.09).rotate(np.pi)\n    )\n    lower_rect = Rectangle(GREY_D, height=1, width=0.3).set_fill([GREY_C, RED], 1).set_z_index(2).set_y(-1.09)\n    stand = (\n        Polygon(\n            [-2, -2.2, 0],\n            [2, -2.2, 0],\n            [2, -2, 0],\n            [1.75, -2, 0],\n            [np.sqrt(2), -np.sqrt(2), 0],\n            [-np.sqrt(2), -np.sqrt(2), 0],\n            [-1.75, -2, 0],\n            [-2, -2, 0],\n            color=GREY_D,\n        )\n        .set_fill(GRAY_C, 1)\n        .set_z_index(0)\n    )\n\n    return VGroup(c_inner, c_middle, c_outer, stand, r_inner, a, b, upper_rect, lower_rect, c_hidden)\n\n\nclass DCMotor(Scene):\n    def construct(self):\n\n        rotor = Text(\"Rotor\", color=BLACK).set_x(-5.5).set_y(2)\n        rotor_line = VGroup(\n            DashedVMobject(Line([-6.4, 1.65, 0], [-3.5, 1.65, 0], color=BLACK), num_dashes=12),\n            DashedVMobject(Line([-3.5, 1.65, 0], [-0.5, -0.5, 0], color=BLACK).set_z_index(10)),\n            DashedVMobject(Line([-1.96, 0.545, 0], [-0.5, 0.545, 0], color=BLACK).set_z_index(10), num_dashes=7),\n        )\n        stator = Text(\"Stator\", color=BLACK).set_x(5.5).set_y(-1.1)\n        stator_line = VGroup(\n            DashedVMobject(Line([6.4, -1.45, 0], [3.7, -1.45, 0], color=BLACK), num_dashes=10),\n            DashedVMobject(Line([3.7, -1.45, 0], [1.3 * 1.8, -1.3 * 1.8, 0], color=BLACK).set_z_index(10), num_dashes=7),\n        )\n\n        brushes = Text(\"B\u00fcrsten\", color=BLACK).set_x(5).set_y(3)\n        brushes_line = VGroup(\n            DashedVMobject(Line([6.4, 2.65, 0], [3.7, 2.65, 0], color=BLACK), num_dashes=10),\n            DashedVMobject(Line([3.15, 1.09 * 1.8, 0], [0, 1.09 * 1.8, 0], color=BLACK).set_z_index(3), num_dashes=11),\n            DashedVMobject(Line([3.7, 2.65, 0], [0, -1.09 * 1.8, 0], color=BLACK).set_z_index(3), num_dashes=22),\n        )\n\n        self.camera.background_color = WHITE\n        everything = create_dc_motor()\n        self.add(everything.scale(1.8), rotor, rotor_line, stator, stator_line, brushes, brushes_line)"
  },
  {
    "text": "from manim import *\n\n\ndef create_simple_motor() -> Mobject:\n    c_inner = Circle(1.4, GREY_D).set_fill(GREY_B, 1).set_z_index(3)\n    c_middle = Circle(1.6, GREY_D).set_fill(WHITE, 1).set_z_index(2)\n    c_outer = Circle(2, GREY_D).set_fill(GREY_B, 1).set_z_index(1)\n\n    stand = (\n        Polygon(\n            [-2, -2.2, 0],\n            [2, -2.2, 0],\n            [2, -2, 0],\n            [1.75, -2, 0],\n            [np.sqrt(2), -np.sqrt(2), 0],\n            [-np.sqrt(2), -np.sqrt(2), 0],\n            [-1.75, -2, 0],\n            [-2, -2, 0],\n            color=GREY_D,\n        )\n        .set_fill(GRAY_C, 1)\n        .set_z_index(0)\n    )\n\n    return VGroup(c_inner, c_middle, c_outer, stand)\n\n\nclass SimpleMotor(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        rotor = Text(\"Rotor\", color=BLACK).set_x(-5.5).set_y(2)\n        rotor_line = VGroup(\n            Line([-6.4, 1.65, 0], [-3.5, 1.65, 0], color=BLACK),\n            Line([-3.5, 1.65, 0], [-0.5, 0.5, 0], color=BLACK).set_z_index(10),\n        )\n\n        stator = Text(\"Stator\", color=BLACK).set_x(5.5).set_y(-1.1)\n        stator_line = VGroup(\n            Line([6.4, -1.45, 0], [3.7, -1.45, 0], color=BLACK),\n            Line([3.7, -1.45, 0], [1.3 * 1.8, -1.3 * 1.8, 0], color=BLACK).set_z_index(10),\n        )\n\n        self.add(create_simple_motor(), rotor, rotor_line, stator, stator_line)"
  },
  {
    "text": "from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create an oxygen molecule\n        oxygen_molecule = self.create_oxygen_molecule()\n\n        # Center the oxygen molecule on the screen\n        oxygen_molecule.move_to(ORIGIN)\n\n        # Animate the construction of the molecule\n        self.play(FadeIn(oxygen_molecule))\n        self.wait(1)\n\n        # Rotate the molecule\n        self.play(Rotate(oxygen_molecule, angle=PI))\n        self.wait(1)\n\n        # Scale the molecule\n        self.play(oxygen_molecule.animate.scale(2))\n        self.wait(1)\n\n        # Disappearance of the molecule\n        self.play(FadeOut(oxygen_molecule))\n        self.wait(1)\n\n    def create_oxygen_molecule(self) -> Mobject:\n        # Draw two oxygen atoms\n        oxygen_atom_1 = self.create_atom('O', RED)\n        oxygen_atom_2 = self.create_atom('O', RED)\n\n        # Place the second oxygen to the right of the first\n        oxygen_atom_2.next_to(oxygen_atom_1, RIGHT, buff=1)\n\n        # Draw a double bond between atoms\n        bond_1 = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center()).shift(UP*0.1)\n        bond_2 = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center()).shift(DOWN*0.1)\n\n        # Create a VGroup for the oxygen molecule\n        oxygen_molecule = VGroup(oxygen_atom_1, oxygen_atom_2, bond_1, bond_2)\n        return oxygen_molecule\n\n    def create_atom(self, text, color) -> Mobject:\n        # Draw an atom as a circle with text inside\n        atom_circle = Circle(color=color).set_fill(color, opacity=0.5)\n        atom_text = Text(text, color=WHITE).scale(0.7)\n        atom = VGroup(atom_circle, atom_text)\n        return atom"
  },
  {
    "text": "from manim import *\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a hexagon shape path using the Polygon class\n        hexagon_points = [UP, UR, DR, DOWN, DL, UL]\n        hexagon = Polygon(*hexagon_points, color=BLUE).scale(2)\n        self.play(ShowCreation(hexagon))\n\n        # Create an electron mobject\n        e = electron()\n\n        # Animate the electron follow the hexagon path\n        animations = move_along_complex_path(e, [5], hexagon_points, run_time=6)\n        self.play(AnimationGroup(*animations), run_time=6)\n\n        # Fade out all mobjects\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"
  },
  {
    "text": "from manim import *\n\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm == 0:\n        return v\n    return v / norm\n\n\n# Render with -c \"#ece6e2\"\nclass DraftScene(Scene):\n    def construct(self):\n        logo_green = \"#81b29a\"\n        logo_blue = \"#454866\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n\n        ds_m = MathTex(r\"\\mathbb{M}\", z_index=20).scale(7).set_color(logo_black)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n\n        circle = Circle(color=logo_green, fill_opacity=1, z_index=7).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1, z_index=5).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1, z_index=3).shift(RIGHT)\n\n        vgroup = VGroup(triangle, square, circle, ds_m).scale(0.7)\n        vgroup.move_to(ORIGIN)\n\n        self.add(circle, square, triangle)\n\n        shape_center = VGroup(circle, square, triangle).get_center()\n\n        spiral_run_time = 2.1\n        expansion_factor = 8\n        m_height_over_anim_height = 0.75748\n        m_shape_offset = 4.37\n        m_anim_buff = 0.06\n\n        tracker = ValueTracker(0)\n\n        for mob in [circle, square, triangle]:\n            mob.final_position = mob.get_center()\n            mob.initial_position = (\n                mob.final_position\n                + (mob.final_position - shape_center) * expansion_factor\n            )\n            mob.initial_to_final_distance = np.linalg.norm(\n                mob.final_position - mob.initial_position\n            )\n            mob.move_to(mob.initial_position)\n            mob.current_time = 0\n            mob.starting_mobject = mob.copy()\n\n            def updater(mob, dt):\n                mob.become(mob.starting_mobject)\n                mob.shift(\n                    normalize((shape_center - mob.get_center()))\n                    * mob.initial_to_final_distance\n                    * tracker.get_value()\n                )\n                mob.rotate(TAU * tracker.get_value(), about_point=shape_center)\n                mob.rotate(-TAU * tracker.get_value())\n\n            mob.add_updater(updater)\n\n        self.play(tracker.set_value, 1, run_time=spiral_run_time)\n\n        circle.clear_updaters()\n        square.clear_updaters()\n        triangle.clear_updaters()\n\n        self.wait(0.3)\n\n        self.play(FadeIn(ds_m), rate_func=rate_functions.ease_in_sine)\n        self.wait(0.7)\n\n        ds_m_target = ds_m.generate_target()\n        circle_target = circle.generate_target().shift(RIGHT * m_shape_offset)\n        square_target = square.generate_target().shift(RIGHT * m_shape_offset)\n        triangle_target = triangle.generate_target().shift(RIGHT * m_shape_offset)\n\n        anim = VGroup()\n        for i, ch in enumerate(\"anim\"):\n            tex = Tex(\n                \"\\\\textbf{\" + ch + \"}\",\n                z_index=10,\n                tex_template=TexFontTemplates.gnu_freeserif_freesans,\n            )\n            if i != 0:\n                tex.next_to(anim, buff=0.01)\n            tex.align_to(ds_m, DOWN)\n            anim.add(tex)\n\n        anim.set_color(logo_black).set_height(\n            m_height_over_anim_height * ds_m.get_height()\n        ).next_to(ds_m_target, buff=m_anim_buff).align_to(ds_m, DOWN)\n\n        banner = VGroup(\n            ds_m_target, anim, circle_target, square_target, triangle_target\n        )\n        banner.move_to(ORIGIN)\n\n        ds_m_offset_vec = ds_m_target.get_center() - ds_m.get_center()\n\n        self.play(\n            circle.shift,\n            ds_m_offset_vec,\n            square.shift,\n            ds_m_offset_vec,\n            triangle.shift,\n            ds_m_offset_vec,\n            ds_m.shift,\n            ds_m_offset_vec,\n        )\n\n        tracker.set_value(0)\n        shape_center = VGroup(circle, square, triangle).get_center()\n        for mob in [circle, square, triangle]:\n            mob.starting_mobject = mob.copy()\n            mob.shape_center_offset = mob.get_center() - shape_center\n\n            def updater(mob, dt):\n                center = shape_center + RIGHT * tracker.get_value() * m_shape_offset\n                mob.become(mob.starting_mobject)\n                mob.move_to(center + mob.shape_center_offset)\n\n            mob.add_updater(updater)\n\n        self.play(\n            tracker.set_value,\n            1,\n            FadeIn(anim, lag_ratio=1),\n        )\n        anim.z_index = 20\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n\nclass HamiltonianCycle(Scene):\n    def construct(self):\n        dots = [Dot(z_index=30) for _ in range(20)]\n        for ind, dot in enumerate(dots[:5]):\n            dot.move_to(\n                3.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[5:10]):\n            dot.move_to(\n                2.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[10:15]):\n            dot.move_to(\n                1.5\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[15:]):\n            dot.move_to(\n                0.75\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        lines = (\n            [\n                Line(dots[k].get_center(), dots[(k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n            + [Line(dots[k].get_center(), dots[5 + k].get_center()) for k in range(5)]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 2) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 3) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[10 + k].get_center(), dots[15 + k].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[15 + k].get_center(), dots[15 + (k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n        )\n        vgroup = VGroup(*lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(*[ShowCreation(dot) for dot in dots])\n        self.play(*[ShowCreation(line) for line in lines])\n        self.wait(1)\n        cycle_ind = [\n            0,\n            1,\n            2,\n            7,\n            14,\n            6,\n            13,\n            5,\n            12,\n            9,\n            11,\n            16,\n            17,\n            18,\n            19,\n            15,\n            10,\n            8,\n            3,\n            4,\n        ]\n        cycle_lines = []\n        for k in range(len(cycle_ind)):\n            self.play(\n                dots[cycle_ind[k]].set_color, RED, run_time=0.3, rate_function=linear\n            )\n            new_line = Line(\n                dots[cycle_ind[k]].get_center(),\n                dots[cycle_ind[(k + 1) % len(cycle_ind)]].get_center(),\n                color=RED,\n                stroke_width=5,\n            )\n            cycle_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.65)\n        self.wait(1)\n        self.play(VGroup(vgroup, *cycle_lines).shift, 3 * LEFT)\n        t1 = Tex(\"The graph\")\n        t1.next_to(vgroup, RIGHT)\n        self.play(Write(t1))\n        self.play(\n            ApplyFunction(\n                lambda obj: obj.scale(0.2).next_to(t1, RIGHT).shift(0.4 * UP),\n                VGroup(*lines, *dots).copy(),\n            )\n        )\n        t2 = Tex(\"has a Hamiltonian cycle.\")\n        t2.next_to(t1, DOWN)\n        t2.align_to(t1, LEFT)\n        self.play(Write(t2))\n        self.wait(1)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])"
  },
  {
    "text": "from manim import *\nimport random\nfrom enum import Enum\n\n\nclass SwapMode(Enum):\n    OVER = 1\n    ACROSS = 2\n\n\nclass Array(VGroup):\n    def __init__(self, array, run_time=0.3):\n        super().__init__()\n        self.run_time = run_time\n        self.build_array(array)\n\n    def build_array(self, array):\n        for i, x in enumerate(array):\n            cell = VDict({\"cell\": Square(), \"number\": Integer(x)})\n            if i != 0:\n                cell.next_to(self, RIGHT, buff=0)\n            self.add(cell)\n        self.move_to(ORIGIN)\n\n    def value_at_index(self, index):\n        return self[index][\"number\"].get_value()\n\n    def swap(self, scn, i, j, swap_mode=SwapMode.ACROSS):\n        # Swap in submobjects list\n        temp = self.submobjects[i]\n        self.submobjects[i] = self.submobjects[j]\n        self.submobjects[j] = temp\n\n        # Swap on screen\n        if swap_mode == SwapMode.ACROSS:\n            scn.play(\n                self.submobjects[j].shift,\n                LEFT * self.submobjects[i].get_width(),\n                self.submobjects[i].shift,\n                RIGHT * self.submobjects[j].get_width(),\n                run_time=self.run_time,\n            )\n        elif swap_mode == SwapMode.OVER:\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_height() * UP,\n                run_time=self.run_time / 3,\n            )\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_width() * LEFT,\n                self.submobjects[i].shift,\n                self.submobjects[j].get_width() * RIGHT,\n                run_time=self.run_time / 3,\n            )\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_height() * DOWN,\n                run_time=self.run_time / 3,\n            )\n        else:\n            raise ValueError(f\"Unknown SwapMode {swap_mode}\")\n\n\nclass HeightArray(Array):\n    def __init__(self, array, unit_width=1.5, unit_height=1, run_time=0.3):\n        self.unit_height = unit_height\n        self.unit_width = unit_width\n        super().__init__(array, run_time=run_time)\n\n    def value_at_index(self, index):\n        return self[index].get_height() / self.unit_height\n\n    def build_array(self, array):\n        for i, x in enumerate(array):\n            cell = Rectangle(width=self.unit_width, height=x * self.unit_height)\n            if i != 0:\n                cell.next_to(self, RIGHT, buff=0)\n                cell.align_to(self, DOWN)\n            self.add(cell)\n        self.move_to(ORIGIN)\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        self.sort_array()\n\n    def sort_array(self):\n        arr = list(range(1, 51))\n        random.shuffle(arr)\n        arr_mob = HeightArray(arr, run_time=0.03)\n        if type(arr_mob) == Array:\n            arr_mob.set_width(13)\n        elif isinstance(arr_mob, HeightArray):\n            arr_mob.set_height(7)\n            arr_mob.to_edge(DOWN)\n        self.play(ShowCreation(arr_mob))\n        self.wait()\n\n        i = 1\n        arr_mob[0].set_color(GREEN)\n        while i < len(arr_mob.submobjects):\n            arr_mob[i].set_color(YELLOW)\n            j = i\n            while j > 0 and arr_mob.value_at_index(j - 1) > arr_mob.value_at_index(j):\n                arr_mob.swap(self, j, j - 1)\n                j = j - 1\n            arr_mob[j].set_color(GREEN)\n            i = i + 1\n        self.wait()"
  },
  {
    "text": "import numpy as np\nfrom manim import *\n\n\nclass ComplexPlaneWithFunctionDots(ComplexPlane):\n    class InputDot(Dot):\n        def __init__(self, plane, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def set_value(self, value):\n            self.move_to(self.plane.n2p(value))\n\n            return self\n\n    class OutputDot(Dot):\n        def __init__(self, plane, input_dot, func, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n            self.input_dot = input_dot\n            self.func = func\n\n            self.update_position()\n            always(self.update_position)\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def update_position(self):\n            self.move_to(self.plane.n2p(self.func(self.input_dot.get_value())))\n\n    def get_function_dots(self, func, *, input_config={}, output_config={}):\n        input_dot = self.InputDot(self, **input_config)\n        output_dot = self.OutputDot(self, input_dot, func, **output_config)\n\n        return input_dot, output_dot\n\n\nclass Euler(Scene):\n    def construct(self):\n        plane = ComplexPlaneWithFunctionDots()\n        plane.add_coordinates(*plane.get_default_coordinate_values())\n        self.add(plane)\n\n        theta_dot, z_dot = plane.get_function_dots(\n            lambda z: np.exp(1j * z),\n            input_config={\"color\": RED},\n            output_config={\"color\": YELLOW, \"z_index\": 1},\n        )\n\n        path = TracedPath(z_dot.get_center, min_distance_to_new_point=0)\n\n        formula = MathTex(\"z\", \"=e^{i\", r\"\\theta}\").move_to(5.5 * LEFT + 2.5 * UP)\n        formula[0].set_color(z_dot.get_color())\n        formula[2].set_color(theta_dot.get_color())\n\n        formula_box = Rectangle(\n            width=formula.get_width() + MED_SMALL_BUFF,\n            height=formula.get_height() + MED_SMALL_BUFF,\n        )\n        formula_box.move_to(formula).set_fill(BLACK, opacity=1).set_stroke(\n            BLUE, opacity=1, width=DEFAULT_STROKE_WIDTH / 2\n        )\n\n        formula_group = VGroup(formula_box, formula)\n\n        self.add(path, formula_group, theta_dot, z_dot)\n        self.play(theta_dot.set_value, TAU, run_time=3)\n\n        indicate_path = Circle(color=PINK)\n        self.play(ShowCreationThenDestruction(indicate_path), run_time=3)\n\n        self.play(theta_dot.set_value, 1j, run_time=3)\n        self.play(Rotating(theta_dot, about_point=ORIGIN), run_time=3)\n        self.play(theta_dot.move_to, plane.n2p(0))"
  },
  {
    "text": "from manim import *\nimport colour\n\n\nNUM_DOTS = 250\nFALL_TIME = 1\nRUNTIME = 2.5\nRED = \"#FF4040\"\nBLUE = \"#4040FF\"\n\n\nclass EventMobject(VGroup):\n    def __init__(self, probability, label, color=WHITE, y_coordinate=0):\n        super().__init__()\n        line = Line(\n            start=LEFT * probability * config[\"frame_width\"] * 0.5,\n            end=RIGHT * probability * config[\"frame_width\"] * 0.5,\n            stroke_width=12,\n            color=color,\n        )\n        label = Tex(label, color=color).next_to(line, direction=DOWN)\n\n        self.line = line\n        self.label = label\n        self.event_color = color\n\n        self.add(self.line, self.label)\n\n    def put_start_and_end_on(self, start, end):\n        self.line.put_start_and_end_on(start, end)\n        self.label.next_to(self.line, direction=DOWN)\n\n    def set_label(self, label):\n        self.label = Tex(label, color=self.event_color)\n        self.submobjects[1] = self.label\n\n    def set_color(self, color):\n        super().set_color(color)\n        self.event_color = color\n\n\nclass Label(VDict):\n    def __init__(self, label, color=BLUE):\n        super().__init__()\n        tex = Tex(label, color=color)\n        label_background = Rectangle(\n            height=tex.get_height() + MED_SMALL_BUFF,\n            width=tex.get_width() + MED_SMALL_BUFF,\n            stroke_opacity=0,\n            fill_color=BLACK,\n            fill_opacity=1,\n        ).move_to(tex.get_center())\n        self.add({\"background\": label_background, \"tex\": tex})\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        event_a = EventMobject(0.7, \"$A$\", color=BLUE).shift(\n            UP * 0.1 * config[\"frame_height\"]\n        )\n        events = [event_a]\n\n        p_a = Label(\"P($A$)\").to_corner(UP + RIGHT)\n\n        self.add(event_a, p_a)\n        self.wait(0.5)\n\n        self.raindrop_scene(events, p_a)\n\n        p_not_a = Label(\"P($\\\\neg A$)\").to_corner(UP + RIGHT)\n\n        self.play(\n            event_a.set_color,\n            WHITE,\n            FadeOutAndShift(p_a),\n            FadeInFrom(p_not_a, UP),\n        )\n\n        event_a.event_color = WHITE\n        self.raindrop_scene(events, p_not_a, default_dot_color=BLUE)\n\n        event_a_target = event_a.generate_target()\n        event_a_target.put_start_and_end_on(\n            UP * 0.2 * config[\"frame_height\"]\n            + LEFT * (0.5 * config[\"frame_width\"] - 1),\n            UP * 0.2 * config[\"frame_height\"] + RIGHT * 2.5,\n        )\n        event_a_target.set_color(BLUE)\n\n        event_b = event_a_target.copy()\n        event_b.set_label(\"$B$\")\n        event_b.put_start_and_end_on(\n            UP * 0.0 * config[\"frame_height\"]\n            + RIGHT * (0.5 * config[\"frame_width\"] - 1),\n            UP * 0.0 * config[\"frame_height\"] + LEFT * 2.5,\n        )\n        events.append(event_b)\n        p_a_or_b = Label(\"P($A \\\\cup B$)\").to_corner(UP + RIGHT)\n\n        self.play(\n            MoveToTarget(event_a),\n            FadeIn(event_b),\n            FadeOutAndShift(p_not_a),\n            FadeInFrom(p_a_or_b, UP),\n        )\n        event_a.event_color = BLUE\n        self.raindrop_scene(events, p_a_or_b)\n\n        p_a_and_b = Label(\n            \"P($A \\\\cap B$)\", color=interpolate_color(BLUE, RED, 0.5)\n        ).to_corner(UP + RIGHT)\n        self.play(\n            event_b.set_color,\n            RED,\n            FadeOutAndShift(p_a_or_b),\n            FadeInFrom(p_a_and_b, UP),\n        )\n        event_b.event_color = RED\n\n        self.raindrop_scene(events, p_a_and_b)\n\n        p_a_given_b = Label(\n            \"P($A \\\\mid B$)\", color=interpolate_color(BLUE, RED, 0.5)\n        ).to_corner(UP + RIGHT)\n\n        event_b_target = event_b.generate_target()\n        event_b_target.put_start_and_end_on(\n            UP * event_b.line.get_center()[1] + RIGHT * 0.5 * config[\"frame_width\"],\n            UP * event_b.line.get_center()[1] + LEFT * 0.5 * config[\"frame_width\"],\n        )\n\n        # Scale both events by the same amount.\n        event_b_growth_ratio = (\n            event_b_target.line.get_length() / event_b.line.get_length()\n        )\n        event_a_offset = event_a.line.get_right()[0] - event_b.line.get_right()[0]\n\n        event_a_target = event_a.generate_target()\n        event_a_right = UP * event_a.line.get_center()[1] + RIGHT * (\n            event_b_target.line.get_right()[0] + event_a_offset * event_b_growth_ratio\n        )\n        event_a_target.put_start_and_end_on(\n            event_a_right + LEFT * event_b_target.line.get_length(),\n            event_a_right,\n        )\n        event_a_target.label.move_to(\n            UP * event_a.label.get_center()[1]\n            + RIGHT\n            * (event_a_target.get_right()[0] - config[\"frame_width\"] * 0.5)\n            * 0.5\n        )\n\n        self.play(\n            FadeOutAndShift(p_a_and_b),\n            FadeInFrom(p_a_given_b, UP),\n            MoveToTarget(event_b),\n            MoveToTarget(event_a),\n        )\n\n        self.raindrop_scene(events, p_a_given_b)\n\n        self.wait()\n\n    def raindrop_scene(self, events, label, default_dot_color=WHITE):\n        upper_left_corner = (\n            UP * 0.5 * config[\"frame_height\"] + LEFT * 0.5 * config[\"frame_width\"]\n        )\n\n        tracker = ValueTracker(0)\n        tracker.add_updater(lambda t, dt: t.increment_value(dt))\n        self.add(tracker)\n\n        # Reach the bottom of the screen in 1 second\n        falling_rate = config[\"frame_height\"] / FALL_TIME\n\n        def fall(dot, dt):\n            if tracker.get_value() < dot.falling_delay:\n                return\n            old_center = dot.get_center()\n            dot.shift(DOWN * falling_rate * dt)\n            new_center = dot.get_center()\n\n            for event in events:\n                if (\n                    event.get_left()[0] < old_center[0]\n                    and old_center[0] < event.get_right()[0]\n                    and new_center[1] < event.line.get_center()[1]\n                    and event.line.get_center()[1] < old_center[1]\n                ):\n                    dot_color = np.array(color.Color(dot.get_color()).get_rgb())\n                    event_color = np.array(color.Color(event.event_color).get_rgb())\n                    dot.color_array.append(event_color)\n                    new_color = interpolate(\n                        dot_color, event_color, 1 / len(dot.color_array)\n                    )\n                    dot.set_color(colour.Color(rgb=new_color))\n\n        for _ in range(NUM_DOTS):\n            dot = Dot(color=default_dot_color).move_to(\n                upper_left_corner + random.random() * RIGHT * config[\"frame_width\"]\n            )\n            dot.shift(UP * dot.radius)\n            dot.falling_delay = random.random() * RUNTIME\n            dot.color_array = []\n            dot.add_updater(fall)\n            self.add(dot)\n\n        self.add(*events)\n        self.add(label)\n        self.wait(RUNTIME + FALL_TIME)"
  },
  {
    "text": "from manim import *\nimport pkg_resources\n\nversion_num = \"0.1.1\"\n\n\nclass Ball(LabeledDot):\n    CONFIG = {\"radius\": 0.4, \"fill_opacity\": 1, \"color\": BLUE}\n\n    def __init__(self, lable=r\"\\alpha\", **kwargs):\n        LabeledDot.__init__(self, lable, **kwargs)\n        self.velocity = np.array((2, 1.5, 0))\n\n    def get_top(self):\n        return self.get_center()[1] + self.radius\n\n    def get_bottom(self):\n        return self.get_center()[1] - self.radius\n\n    def get_right_edge(self):\n        return self.get_center()[0] + self.radius\n\n    def get_left_edge(self):\n        return self.get_center()[0] - self.radius\n\n\nclass Box(Rectangle):\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, height=6, width=8, color=GREEN_C, **kwargs)  # Edges\n        self.top = 0.5 * self.height\n        self.bottom = -0.5 * self.height\n        self.right_edge = 0.5 * self.width\n        self.left_edge = -0.5 * self.width\n\n\nclass TwitterScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        version = Tex(f\"v{version_num}\").to_corner(UR).set_color(BLACK)\n        self.add(version)\n\n        box = Box()\n        ball = Ball(lable=Text(\"v0.1.1\").scale(0.3))\n        self.add(box)\n        self.play(Write(ball))\n\n        def update_ball(ball, dt):\n            ball.acceleration = np.array((0, -5, 0))\n            ball.velocity = ball.velocity + ball.acceleration * dt\n            ball.shift(ball.velocity * dt)  # Bounce off ground and roof\n            if ball.get_bottom() <= box.bottom or ball.get_top() >= box.top:\n                ball.velocity[1] = -ball.velocity[1]\n            # Bounce off walls\n            if (\n                ball.get_left_edge() <= box.left_edge\n                or ball.get_right_edge() >= box.right_edge\n            ):\n                ball.velocity[0] = -ball.velocity[0]\n\n        ball.add_updater(update_ball)\n        self.add(ball)\n\n        ball2 = Ball(lable=r\"\\Psi\")\n        self.play(Write(ball2))\n        ball2.add_updater(update_ball)\n\n        ball3 = Ball(lable=r\"\\alpha\")\n        self.play(Write(ball3))\n        ball3.add_updater(update_ball)\n\n        ball4 = Ball(lable=r\"\\lambda\")\n        self.play(Write(ball4))\n        ball4.add_updater(update_ball)\n\n        self.wait(3)\n        cu1 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu1)\n        cu1_small = cu1.copy().scale(0.3).to_edge(RIGHT).shift(2 * UP)\n        self.play(Transform(cu1, cu1_small))\n\n        cu2 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu2)\n        cu2_small = cu2.copy().scale(0.3).to_edge(RIGHT)\n        self.play(Transform(cu2, cu2_small))\n\n        self.wait()\n        #\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(*[FadeOut(x) for x in self.mobjects], FadeIn(banner), run_time=2.5)\n        self.play(banner.expand())\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\ndef lissajous_curve_func(t):\n    return np.array((np.sin(3 * t), np.sin(4 * t) + 2 / 3 * PI, 0))\n\n\nclass MyScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        dot = Dot()\n        dummy_func = ParametricFunction(lissajous_curve_func, t_max=TAU, fill_opacity=0)\n        dummy_func.scale(2).move_to(ORIGIN)\n        func1 = dummy_func.copy().set_stroke(width=18)\n        func1 = CurvesAsSubmobjects(func1)\n        func1.set_color_by_gradient(YELLOW_A, YELLOW_D)\n        func2 = dummy_func.copy().set_color(BLACK).set_stroke(width=20)\n        dot.add_updater(lambda m: m.move_to(dummy_func.get_end()))\n        dummy_func.set_opacity(0)\n        # or dummy_func.fade(1) )\n        self.add(dot)\n        self.play(\n            ShowCreation(dummy_func),\n            ShowCreation(func2),\n            ShowCreation(func1),\n            rate_func=linear,\n            run_time=9,\n        )\n        self.add(func1)\n        self.wait()\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner))\n        self.play(banner.expand())\n        self.wait(3)"
  },
  {
    "text": "from manim import *\nimport random\nimport math\n\n\nclass BinarySearchTree(VGroup):\n    def __init__(\n        self,\n        scene,\n        levels=3,\n        base_offset=0.5,\n        node_radius=0.5,\n        child_offset_factor=1.2,\n        label_scale_factor=1,\n        color_nodes=False,\n        max_value=16,\n        animation_runtime=0.2,\n        insertion_initial_offset=1,\n    ):\n        super().__init__()\n        self.scene = scene\n        self.empty = True\n        self.child_down_offset = DOWN * child_offset_factor\n        self.child_left_offset = LEFT * base_offset * 2 * math.log2(levels)\n        self.node_radius = node_radius\n        self.label_scale_factor = label_scale_factor\n        self.color_nodes = color_nodes\n        self.max_value = max_value\n        self.animation_runtime = animation_runtime\n        self.insertion_initial_offset = insertion_initial_offset\n\n        self.root = self.get_node(None)\n        self.add(self.root)\n\n    def get_node(self, value):\n        node = VDict(\n            {\n                \"node\": Circle(radius=self.node_radius, color=WHITE),\n                \"label\": MathTex(\"\\\\varnothing\" if value is None else str(value)).scale(\n                    self.label_scale_factor\n                ),\n            }\n        )\n        if self.label_scale_factor != 0:\n            node[\"label\"] = MathTex(\n                \"\\\\varnothing\" if value is None else str(value)\n            ).scale(self.label_scale_factor)\n        if value is not None:\n            node_color = interpolate_color(BLUE, RED, value / self.max_value)\n            node.set_stroke(node_color)\n            if self.color_nodes:\n                node.set_fill(node_color, opacity=1)\n            node.color = node_color\n        node.value = value\n        node.left_child = None\n        node.right_child = None\n        return node\n\n    def insert(self, value):\n        node = self.get_node(value)\n        if self.root.value is None:\n            node.move_to(self.root.get_center())\n            self.scene.play(\n                FadeInFrom(node, UP * self.insertion_initial_offset),\n                FadeOut(self.root),\n                run_time=self.animation_runtime,\n            )\n            self.remove(self.root)\n            self.root = node\n            self.add(node)\n            self.empty = False\n            return\n\n        node.move_to(self.root.get_center() + UP * self.insertion_initial_offset)\n        cur_node = self.root\n        child_left_offset = self.child_left_offset.copy()\n        while cur_node is not None:\n            if node.value <= cur_node.value:\n                self.scene.play(\n                    node.move_to,\n                    cur_node.get_center() + 2 * cur_node[\"node\"].radius * LEFT,\n                    run_time=self.animation_runtime,\n                )\n                if cur_node.left_child is not None:\n                    cur_node = cur_node.left_child\n                else:\n                    child_location = (\n                        cur_node.get_center()\n                        + self.child_down_offset\n                        + child_left_offset\n                    )\n                    parent_child_vector = normalize(\n                        child_location - cur_node.get_center()\n                    )\n\n                    edge_start = (\n                        cur_node.get_center() + parent_child_vector * self.node_radius\n                    )\n                    edge_end = child_location - parent_child_vector * self.node_radius\n                    edge = Line(edge_start, edge_end, stroke_color=node.color)\n\n                    self.scene.play(\n                        node.move_to,\n                        child_location,\n                        FadeIn(edge),\n                        run_time=self.animation_runtime,\n                    )\n                    cur_node.left_child = node\n                    self.add(node, edge)\n                    break\n            else:\n                self.scene.play(\n                    node.move_to,\n                    cur_node.get_center() + 2 * cur_node[\"node\"].radius * RIGHT,\n                    run_time=self.animation_runtime,\n                )\n                if cur_node.right_child is not None:\n                    cur_node = cur_node.right_child\n                else:\n                    child_location = (\n                        cur_node.get_center()\n                        + self.child_down_offset\n                        - child_left_offset\n                    )\n                    parent_child_vector = normalize(\n                        child_location - cur_node.get_center()\n                    )\n\n                    edge_start = (\n                        cur_node.get_center() + parent_child_vector * self.node_radius\n                    )\n                    edge_end = child_location - parent_child_vector * self.node_radius\n                    edge = Line(edge_start, edge_end, stroke_color=node.color)\n\n                    self.scene.play(\n                        node.move_to,\n                        child_location,\n                        FadeIn(edge),\n                        run_time=self.animation_runtime,\n                    )\n                    cur_node.right_child = node\n                    self.add(node, edge)\n                    break\n            child_left_offset /= 2\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        tree = BinarySearchTree(self, base_offset=0.75, max_value=16).shift(UP * 2)\n        self.add(tree)\n        label = (\n            Text(\"Great for storing structured data.\").scale(0.8).to_edge(UP, buff=0.1)\n        )\n        self.add(label)\n\n        nums = [8, 4, 2, 1, 3, 6, 5, 7, 12, 10, 9, 11, 14, 13, 15]\n        for i in nums:\n            tree.insert(i)\n\n        self.wait(0.5)\n        self.play(FadeOut(tree))\n        self.remove(label)\n\n        # tree = BinarySearchTree(\n        #     self,\n        #     base_offset=0.9,\n        #     node_radius=0.05,\n        #     child_offset_factor=0.8,\n        #     label_scale_factor=0,\n        #     color_nodes=True,\n        #     max_value=31,\n        #     animation_runtime=0.05,\n        #     insertion_initial_offset=0.6\n        # ).shift(UP * 2.5 + LEFT * 0.5)\n        # self.add(tree)\n        # self.add(\n        #     Text(\"Though random data can get ugly.\").scale(0.8).to_edge(UP, buff=0.1)\n        # )\n\n        # # Though random data can get ugly.\n        # nums = [i + 1 for i in range(31)]\n        # random.seed(0)\n        # random.shuffle(nums)\n        # for i in nums:\n        #     tree.insert(i)\n\n        # self.wait()"
  },
  {
    "text": "import numpy as np\nfrom manim import *\n\nORBIT_WIDTH = 3.2\nORBIT_HEIGHT = 0.4\nPATH_SCALE_FACTOR = 0.5\nORBIT_RATE = 0.23\nWAIT_TIME = 20\nEARTH_START_PROPORTION = 0.738\nSUN_MOVEMENT_RATE = 1.1\nCAMERA_LAG_TIME = 3.4\nDIAGRAM_STROKE_WIDTH = 2\n# EARTH_SUN_X_DISPLACEMENT_MIN = -1.637\nEARTH_SUN_X_DISPLACEMENT_MIN = -1.6094\n# EARTH_SUN_X_DISPLACEMENT_MAX = 1.561\nEARTH_SUN_X_DISPLACEMENT_MAX = 1.5904\nLABEL_SCALE_FACTOR = 0.35\nARROW_SCALE_FACTOR = 0.4\n\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm == 0:\n        return v\n    return v / norm\n\n\nclass DraftScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        orbit_path = Ellipse(\n            width=ORBIT_WIDTH,\n            height=ORBIT_HEIGHT,\n            stroke_opacity=0,\n        )\n        self.add(orbit_path)  # TODO: Remove this\n\n        v = ValueTracker()\n        earth = Dot(color=BLUE, stroke_opacity=0).move_to(\n            orbit_path.point_from_proportion(EARTH_START_PROPORTION)\n        )\n\n        def orbit(earth):\n            alpha = (EARTH_START_PROPORTION + v.get_value() * ORBIT_RATE) % 1\n            earth.move_to(orbit_path.point_from_proportion(alpha))\n\n        earth.add_updater(orbit)\n        self.add(earth)\n\n        # Earth trail\n        last_earth_sun_distance = 0\n\n        def trail_earth(path, dt):\n            path.add_line_to(earth.get_center())\n\n            # Update the camera here, since updaters can't be added to the\n            # camera.\n            if v.get_value() >= CAMERA_LAG_TIME:\n                self.camera_frame.shift(\n                    normalize(sun_shift_direction) * SUN_MOVEMENT_RATE * dt\n                )\n\n            earth_sun_x_displacement = (sun.get_center() - earth.get_center())[0]\n\n            # if (\n            #     abs(earth_sun_x_displacement - EARTH_SUN_X_DISPLACEMENT_MIN) < 0.001\n            #     or abs(earth_sun_x_displacement - EARTH_SUN_X_DISPLACEMENT_MAX) < 0.0015\n            # ):\n            if (\n                earth_sun_x_displacement < EARTH_SUN_X_DISPLACEMENT_MIN\n                or earth_sun_x_displacement > EARTH_SUN_X_DISPLACEMENT_MAX\n            ):\n                diagram = VGroup()\n                ellipse = Ellipse(\n                    width=ORBIT_WIDTH,\n                    height=ORBIT_HEIGHT,\n                    stroke_opacity=1,\n                    stroke_color=WHITE,\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                ).move_to(orbit_path.get_center())\n\n                sun_dot = Dot(\n                    color=WHITE, fill_opacity=0, stroke_width=DIAGRAM_STROKE_WIDTH\n                ).move_to(ellipse.get_center())\n\n                sun_shine = VGroup()\n                for theta in np.linspace(0, 2 * PI, num=8, endpoint=False):\n                    shine = Line(\n                        start=sun_dot.get_center() + sun_dot.radius * RIGHT,\n                        end=sun_dot.get_center() + (sun_dot.radius + 0.07) * RIGHT,\n                        stroke_width=DIAGRAM_STROKE_WIDTH,\n                    )\n                    shine.rotate(theta, about_point=sun_dot.get_center())\n                    sun_shine.add(shine)\n\n                earth_dot = Dot(\n                    color=WHITE, fill_opacity=0, stroke_width=DIAGRAM_STROKE_WIDTH\n                ).move_to(earth.get_center())\n\n                earth_axis_tilt_direction = normalize(UP * 1.5 + LEFT)\n                earth_axis = Line(\n                    start=earth.get_center() + earth_axis_tilt_direction * 0.15,\n                    end=earth.get_center() - earth_axis_tilt_direction * 0.15,\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                self.add(earth_axis)\n\n                earth_label = VGroup()\n                if earth_sun_x_displacement < 0:\n                    date_tex = Tex(\n                        \"JUNE 21\", tex_template=TexFontTemplates.american_typewriter\n                    )\n                    earth_tex = Tex(\n                        \"EARTH\", tex_template=TexFontTemplates.american_typewriter\n                    ).next_to(date_tex, DOWN)\n                    earth_label.add(date_tex, earth_tex)\n                    earth_label.scale(LABEL_SCALE_FACTOR)\n                    earth_label.next_to(earth, RIGHT, buff=0.1)\n                else:\n                    earth_tex = Tex(\n                        \"EARTH\", tex_template=TexFontTemplates.american_typewriter\n                    )\n                    date_tex = Tex(\n                        \"DEC 21\", tex_template=TexFontTemplates.american_typewriter\n                    ).next_to(earth_tex, DOWN)\n                    earth_label.add(date_tex, earth_tex)\n                    earth_label.scale(LABEL_SCALE_FACTOR)\n                    earth_label.next_to(earth, LEFT, buff=0.1)\n                earth_north = (\n                    Tex(\"N\", tex_template=TexFontTemplates.american_typewriter)\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth_dot, earth_axis_tilt_direction, buff=0.1)\n                )\n                earth_north.shift(RIGHT * 0.15)\n\n                sun_label = (\n                    Tex(\"SUN\", tex_template=TexFontTemplates.american_typewriter)\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(sun, LEFT, buff=0.04)\n                )\n                sun_label.shift(UP * 0.07)\n\n                arrows = VGroup()\n                right_arrow = Arrow(\n                    start=LEFT, end=RIGHT * 0.3, stroke_width=DIAGRAM_STROKE_WIDTH\n                )\n                VMobject.scale(right_arrow, ARROW_SCALE_FACTOR)\n                right_arrow.next_to(ellipse, DOWN, buff=0.1)\n                right_arrow.shift(RIGHT * 0.1)\n                arrows.add(right_arrow)\n\n                left_arrow = Arrow(\n                    start=RIGHT, end=LEFT * 0.3, stroke_width=DIAGRAM_STROKE_WIDTH\n                )\n                VMobject.scale(left_arrow, ARROW_SCALE_FACTOR)\n                left_arrow.next_to(ellipse, UP, buff=0.1)\n                left_arrow.shift(LEFT * 0.1)\n                arrows.add(left_arrow)\n\n                diagram.add(\n                    ellipse,\n                    sun_dot,\n                    earth_dot,\n                    earth_label,\n                    sun_label,\n                    arrows,\n                    sun_shine,\n                    earth_north,\n                )\n                self.add(diagram)\n\n            earth_orbit_alpha = (\n                EARTH_START_PROPORTION + v.get_value() * ORBIT_RATE\n            ) % 1\n\n            if any(\n                # abs(earth_orbit_alpha - x) < 0.0075 # low quality\n                abs(earth_orbit_alpha - x) < 0.0019\n                for x in [0.15 + 0.25 * x for x in [0, 1, 2, 3]]\n            ):\n                line1 = Line(\n                    start=sun.get_center(),\n                    end=sun.get_center()\n                    + 0.6 * rotate_vector(-sun_shift_direction, -PI / 8),\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                line2 = Line(\n                    start=sun.get_center(),\n                    end=sun.get_center()\n                    + 0.6 * rotate_vector(-sun_shift_direction, PI / 8),\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                arrow = VGroup(line1, line2)\n                self.add(arrow)\n\n            # Don't label March when the animation first starts.\n            if v.get_value() < 0.3:\n                return\n\n            # if abs(earth_orbit_alpha - 0.3) < 0.007: # low quality\n            if abs(earth_orbit_alpha - 0.3) < 0.0019:  # low quality\n                self.add(\n                    Tex(\n                        \"SETPEMBER 23\",\n                        tex_template=TexFontTemplates.american_typewriter,\n                    )\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth, RIGHT, buff=0.1)\n                    .shift(RIGHT * 0.5 + DOWN * 0.2)\n                )\n            # elif abs(earth_orbit_alpha - 0.8) < 0.008: # low quality\n            elif abs(earth_orbit_alpha - 0.8) < 0.002:  # low quality\n                self.add(\n                    Tex(\n                        \"MARCH 21\",\n                        tex_template=TexFontTemplates.american_typewriter,\n                    )\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth, LEFT, buff=0.1)\n                    .shift(LEFT * 0.6 + DOWN * 0.15)\n                )\n\n        earth_trail = VMobject(stroke_width=DIAGRAM_STROKE_WIDTH)\n        earth_trail.points = np.array([earth.get_center()])\n        earth_trail.add_updater(trail_earth)\n        self.add(earth_trail)\n\n        # Sun\n        sun_shift_direction = ORIGIN - earth.get_center()\n        sun = Dot(color=YELLOW)\n        always_shift(sun, normalize(sun_shift_direction), rate=SUN_MOVEMENT_RATE)\n        always_shift(orbit_path, normalize(sun_shift_direction), rate=SUN_MOVEMENT_RATE)\n        self.add(sun)\n\n        # Sun trail\n        original_earth_center = earth.get_center()\n        sun_trail = Line(\n            original_earth_center, sun.get_center(), stroke_width=DIAGRAM_STROKE_WIDTH\n        )\n\n        def trail_sun(trail):\n            trail.put_start_and_end_on(original_earth_center, sun.get_center())\n\n        sun_trail.add_updater(trail_sun)\n        self.add(sun_trail)\n\n        self.play(v.set_value, WAIT_TIME, run_time=WAIT_TIME, rate_func=linear)"
  },
  {
    "text": "class NewYearPost(MovingCameraScene):\n    def construct(self):\n        self.camera_frame.move_to(3 * UP)\n        text = MathTex(\n            r\" s(t) &=\\left( \\begin{array}{c} \"\n            r\"x(t)\"\n            r\"\\\\ y(t)\"\n            r\"\\end{array} \\right)\"\n            r\"\\\\ &=\\left( \\begin{array}{c} \"\n            r\"v_0 t \\cos(\\theta)\"\n            r\"\\\\ v_0 t \\sin(\\theta) - \\frac{1}{2}gt^2\"\n            r\"\\end{array} \\right)\"\n        )\n\n        text.to_corner(DL).shift(3 * UP)\n\n        def func(t):\n            v0 = 10\n            theta = 0.85 * PI / 2\n            g = 9.81\n            return np.array(\n                (v0 * t * np.cos(theta), v0 * t * np.sin(theta) - 0.5 * g * t ** 2, 0)\n            )\n\n        rocket = ParametricFunction(func, t_max=1, fill_opacity=0).set_color(WHITE)\n        dot = Dot().set_color(WHITE)\n        dot2 = Dot().set_color(WHITE).move_to(rocket.get_end())\n        self.add(dot)\n        self.play(Write(rocket), rate_func=linear)\n        self.add(dot2)\n        all_sparcs = VGroup()\n        for theta in np.random.uniform(0, TAU, 90):\n\n            def func2(t):\n                v0 = 10\n                g = 9.81\n                return np.array(\n                    (\n                        v0 * t * np.cos(theta) + dot2.get_x(),\n                        v0 * t * np.sin(theta) - 0.5 * g * t ** 2 + dot2.get_y(),\n                        0,\n                    )\n                )\n\n            sparcle = ParametricFunction(\n                func2, t_min=0.04, t_max=0.3, fill_opacity=0\n            ).set_color(ORANGE)\n            all_sparcs.add((sparcle))\n        self.play(\n            *[Write(x) for x in all_sparcs.submobjects], run_time=0.8, rate_func=linear\n        )\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 10), np.random.uniform(0, 6, 10))\n        ]\n        self.play(*[Flash(dot) for dot in dots], lag_ratio=0.2)\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 10), np.random.uniform(0, 6, 10))\n        ]\n        self.play(FadeIn(text), *[Flash(dot) for dot in dots], lag_ratio=0.2)\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 30), np.random.uniform(0, 6, 30))\n        ]\n        self.play(*[Flash(dot) for dot in dots], lag_ratio=0.2)\n\n        banner = ManimBanner(dark_theme=True).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner.shift(3 * UP)))\n        self.play(banner.expand())\n        self.play(FadeOut(banner))"
  },
  {
    "text": "from manim import *\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        def line_to_normal(line, rotation_direction=\"CLOCKWISE\"):\n            if rotation_direction == \"CLOCKWISE\":\n                return normalize(\n                    rotate_vector(line.get_end() - line.get_start(), PI / 2)\n                )\n            elif rotation_direction == \"COUNTERCLOCKWISE\":\n                return normalize(\n                    rotate_vector(line.get_end() - line.get_start(), -PI / 2)\n                )\n            else:\n                raise Exception(rotation_direction)\n\n        def get_h(triangle):\n            h = Line(\n                ORIGIN,\n                ORIGIN\n                + normalize(\n                    rotate_vector(\n                        triangle[\"c\"].get_end() - triangle[\"c\"].get_start(), PI / 2\n                    )\n                ),\n            )\n            h.shift(triangle_points[\"C\"] - h.get_start())\n\n            triangle_points[\"D\"] = line_intersection(\n                triangle[\"c\"].get_start_and_end(), h.get_start_and_end()\n            )\n            h_length = get_norm(triangle_points[\"D\"] - triangle_points[\"C\"])\n\n            h.put_start_and_end_on(\n                h.get_start(),\n                h.get_start()\n                + normalize(\n                    rotate_vector(\n                        triangle[\"c\"].get_end() - triangle[\"c\"].get_start(), PI / 2\n                    )\n                )\n                * h_length,\n            )\n            h.shift(triangle_points[\"C\"] - h.get_start())\n            return h\n\n        triangle_points = {\n            \"A\": LEFT * 2.7 + UP * 1.7,\n            \"B\": RIGHT * 2.7 + DOWN * 1.3,\n            \"C\": LEFT * 2.7 + DOWN * 1.3,\n        }\n        lines = [\n            Line(triangle_points[\"A\"], triangle_points[\"B\"]),\n            Line(triangle_points[\"B\"], triangle_points[\"C\"]),\n            Line(triangle_points[\"C\"], triangle_points[\"A\"]),\n        ]\n        triangle = VDict(\n            {\n                \"c\": lines[0],\n                \"a\": lines[1],\n                \"b\": lines[2],\n                \"c_label\": MathTex(\"c\").move_to(\n                    lines[0].get_center() + line_to_normal(lines[0]) * 0.3\n                ),\n                \"a_label\": MathTex(\"a\").move_to(\n                    lines[1].get_center() + line_to_normal(lines[1]) * 0.3\n                ),\n                \"b_label\": MathTex(\"b\").move_to(\n                    lines[2].get_center() + line_to_normal(lines[2]) * 0.3\n                ),\n            }\n        )\n        # self.play(ShowCreation(triangle))\n        self.play(\n            ShowCreation(VGroup(triangle[\"a\"], triangle[\"b\"], triangle[\"c\"])),\n        )\n        self.play(\n            Write(\n                VGroup(triangle[\"a_label\"], triangle[\"b_label\"], triangle[\"c_label\"])\n            ),\n        )\n        self.wait(0.5)\n\n        triangle.add({\"h\": get_h(triangle)})\n        triangle.add(\n            {\n                \"h_label\": MathTex(\"h\").move_to(\n                    triangle[\"h\"].get_center()\n                    + line_to_normal(\n                        triangle[\"h\"], rotation_direction=\"COUNTERCLOCKWISE\"\n                    )\n                    * 0.3\n                )\n            }\n        )\n        self.play(ShowCreation(triangle[\"h\"]))\n        self.play(Write(triangle[\"h_label\"]))\n\n        def get_triangle_area(points, color, opacity=0.7):\n            return (\n                Polygon(*points)\n                .set_fill(color=color, opacity=opacity)\n                .set_stroke(color=color)\n            )\n\n        triangle_area_positions = {\n            \"ABC\": UP * 2.5 + LEFT * 2,\n            \"ADC\": UP * 2.5 + LEFT * 0.1,\n            \"BDC\": UP * 2.5 + RIGHT * 1.6,\n        }\n\n        # Animate full triangle area.\n        ABC_area = get_triangle_area(\n            [triangle_points[\"A\"], triangle_points[\"B\"], triangle_points[\"C\"]], BLUE\n        )\n        self.play(FadeIn(ABC_area))\n        ABC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"ABC\"])\n        self.play(MoveToTarget(ABC_area))\n        self.wait(0.5)\n\n        ADC_area = get_triangle_area(\n            [triangle_points[\"A\"], triangle_points[\"D\"], triangle_points[\"C\"]], ORANGE\n        )\n        ADC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"ADC\"])\n        triangle_area_equals = MathTex(\"=\").next_to(ABC_area.target, RIGHT, buff=0.1)\n\n        BDC_area = get_triangle_area(\n            [triangle_points[\"B\"], triangle_points[\"D\"], triangle_points[\"C\"]], GREEN\n        )\n        triangle_area_plus = MathTex(\"+\").next_to(triangle_area_equals, RIGHT, buff=1.2)\n        BDC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"BDC\"])\n\n        # Animate partial triangle areas.\n        self.play(FadeIn(ADC_area), FadeIn(BDC_area))\n        self.play(\n            MoveToTarget(ADC_area),\n            MoveToTarget(BDC_area),\n            FadeIn(triangle_area_equals),\n            FadeIn(triangle_area_plus),\n        )\n        self.wait(0.8)\n\n        half_a_b = MathTex(\"\\\\frac{1}{2}ab\").move_to(\n            ABC_area.get_center() + RIGHT * 0.3\n        )\n        self.play(ReplacementTransform(ABC_area, half_a_b))\n        self.wait(0.3)\n\n        short_leg_length = Line(\n            triangle_points[\"D\"], triangle_points[\"A\"], stroke_color=ORANGE\n        )\n        short_leg_variable = MathTex(\"x\", color=ORANGE).move_to(\n            triangle_points[\"A\"] + (UP + LEFT) * 0.2\n        )\n        self.play(ShowCreation(short_leg_length), FadeIn(short_leg_variable))\n        self.wait(0.3)\n\n        half_h_x = MathTex(\"\\\\frac{1}{2}hx\").move_to(ADC_area.get_center())\n        self.play(ReplacementTransform(ADC_area, half_h_x))\n        self.wait(0.3)\n\n        long_leg_length = Line(\n            triangle_points[\"D\"], triangle_points[\"B\"], stroke_color=GREEN\n        )\n        long_leg_variable = MathTex(\"y\", color=GREEN).move_to(\n            triangle_points[\"B\"] + (DOWN + RIGHT) * 0.2\n        )\n        self.play(ShowCreation(long_leg_length), FadeIn(long_leg_variable))\n        self.wait(0.3)\n\n        half_h_y = MathTex(\"\\\\frac{1}{2}hy\").move_to(BDC_area.get_center() + LEFT * 0.2)\n        self.play(ReplacementTransform(BDC_area, half_h_y))\n        self.wait(0.8)\n\n        self.play(\n            FadeOut(VGroup(half_a_b[0][0:3])),\n            FadeOut(VGroup(half_h_x[0][0:3])),\n            FadeOut(VGroup(half_h_y[0][0:3])),\n        )\n\n        ab_equals_h_x_plus_y = MathTex(\"ab=h(x+y)\").move_to(UP * 2.46)\n        self.play(\n            ReplacementTransform(\n                VGroup(half_a_b[0][3:]), VGroup(ab_equals_h_x_plus_y[0][0:2])\n            ),\n            ReplacementTransform(triangle_area_equals, ab_equals_h_x_plus_y[0][2]),\n            ReplacementTransform(triangle_area_plus, ab_equals_h_x_plus_y[0][6]),\n            ReplacementTransform(half_h_x[0][3], ab_equals_h_x_plus_y[0][3]),\n            FadeIn(ab_equals_h_x_plus_y[0][4]),\n            ReplacementTransform(half_h_x[0][4], ab_equals_h_x_plus_y[0][5]),\n            ReplacementTransform(half_h_y[0][4], ab_equals_h_x_plus_y[0][7]),\n            ReplacementTransform(half_h_y[0][3], ab_equals_h_x_plus_y[0][3]),\n            FadeIn(ab_equals_h_x_plus_y[0][8]),\n        )\n        self.wait(0.8)\n\n        ab_equals_hc = MathTex(\"ab=hc\")\n        ab_equals_hc.shift(\n            ab_equals_h_x_plus_y[0][0].get_center() - ab_equals_hc[0][0].get_center()\n        )\n        self.play(\n            ReplacementTransform(ab_equals_h_x_plus_y[0][0], ab_equals_hc[0][0]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][1], ab_equals_hc[0][1]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][2], ab_equals_hc[0][2]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][3], ab_equals_hc[0][3]),\n            ReplacementTransform(\n                VGroup(ab_equals_h_x_plus_y[0][4:]), ab_equals_hc[0][4]\n            ),\n            FadeOut(\n                VGroup(\n                    long_leg_length,\n                    long_leg_variable,\n                    short_leg_length,\n                    short_leg_variable,\n                )\n            ),\n        )\n        self.wait(0.5)\n\n        ab_over_h_equals_c = MathTex(\"\\\\frac{ab}{h}=c\").move_to(\n            ab_equals_hc.get_center()\n        )\n        self.play(\n            ReplacementTransform(\n                VGroup(ab_equals_hc[0][0:2]), VGroup(ab_over_h_equals_c[0][0:2])\n            ),\n            FadeIn(ab_over_h_equals_c[0][2]),\n            ReplacementTransform(ab_equals_hc[0][3], ab_over_h_equals_c[0][3]),\n            ReplacementTransform(ab_equals_hc[0][2], ab_over_h_equals_c[0][4]),\n            ReplacementTransform(ab_equals_hc[0][4], ab_over_h_equals_c[0][5]),\n        )\n        self.wait(0.8)\n\n        self.play(\n            ab_over_h_equals_c.animate.shift(LEFT * 2),\n            triangle.animate.shift(LEFT * 3),\n        )\n\n        pythagorean_theorem_text = MathTex(\n            \"\\\\underline{\\\\text{Pythagorean Theorem}}\"\n        ).shift(RIGHT * 3 + UP * 3)\n        pythagorean_theorem = MathTex(\"a^2 + b^2 = c^2\").next_to(\n            pythagorean_theorem_text, DOWN\n        )\n        self.play(Write(pythagorean_theorem_text))\n        self.wait(0.5)\n        self.play(Write(pythagorean_theorem), run_time=1.5)\n        self.wait(0.8)\n\n        pythagorean_substitution = MathTex(\n            \"a^2 + b^2 = \\\\left(\\\\frac{ab}{h}\\\\right)^2\"\n        ).next_to(pythagorean_theorem, DOWN, buff=0.1)\n        self.play(\n            ReplacementTransform(\n                VGroup(pythagorean_theorem[0][:6]).copy(),\n                VGroup(pythagorean_substitution[0][:6]),\n            ),\n            FadeIn(\n                VGroup(pythagorean_substitution[0][6], pythagorean_substitution[0][11])\n            ),\n            ReplacementTransform(\n                VGroup(ab_over_h_equals_c[0][0:4]).copy(),\n                VGroup(pythagorean_substitution[0][7:11]),\n            ),\n            ReplacementTransform(\n                pythagorean_theorem[0][7],\n                pythagorean_substitution[0][12],\n            ),\n            run_time=1.5,\n        )\n        self.wait(0.8)\n\n        pythagorean_substitution_2 = MathTex(\n            \"a^2\", \"+\", \"b^2\", \"=\", \"\\\\frac{a^2b^2}{h^2}\"\n        ).next_to(pythagorean_substitution, DOWN)\n        self.play(\n            # Transform squares\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][1]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][3]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][6]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][0].copy(),\n                pythagorean_substitution_2[0][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][1].copy(),\n                pythagorean_substitution_2[0][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][2].copy(),\n                pythagorean_substitution_2[1][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][3].copy(),\n                pythagorean_substitution_2[2][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][4].copy(),\n                pythagorean_substitution_2[2][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][5].copy(),\n                pythagorean_substitution_2[3][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][7].copy(),\n                pythagorean_substitution_2[4][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][8].copy(),\n                pythagorean_substitution_2[4][2],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][9].copy(),\n                pythagorean_substitution_2[4][4],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][10].copy(),\n                pythagorean_substitution_2[4][5],\n            ),\n        )\n        self.wait(0.8)\n\n        pythagorean_substitution_3 = MathTex(\n            \"\\\\frac{a^2}{a^2b^2}\", \"+\", \"\\\\frac{b^2}{a^2b^2}\", \"=\", \"\\\\frac{1}{h^2}\"\n        ).next_to(pythagorean_substitution_2, DOWN)\n        self.play(\n            ReplacementTransform(\n                VGroup(pythagorean_substitution_2[4][:4]).copy(),\n                VGroup(pythagorean_substitution_3[0][3:]),\n            ),\n            ReplacementTransform(\n                VGroup(pythagorean_substitution_2[4][:4]).copy(),\n                VGroup(pythagorean_substitution_3[2][3:]),\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[0][0].copy(),\n                pythagorean_substitution_3[0][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[0][1].copy(),\n                pythagorean_substitution_3[0][1],\n            ),\n            FadeIn(pythagorean_substitution_3[0][2]),\n            ReplacementTransform(\n                pythagorean_substitution_2[1].copy(), pythagorean_substitution_3[1]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[2][0].copy(),\n                pythagorean_substitution_3[2][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[2][1].copy(),\n                pythagorean_substitution_3[2][1],\n            ),\n            FadeIn(pythagorean_substitution_3[2][2]),\n            ReplacementTransform(\n                pythagorean_substitution_2[3].copy(), pythagorean_substitution_3[3]\n            ),\n            FadeIn(pythagorean_substitution_3[4][0]),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][4].copy(),\n                pythagorean_substitution_3[4][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][5].copy(),\n                pythagorean_substitution_3[4][2],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][6].copy(),\n                pythagorean_substitution_3[4][3],\n            ),\n        )\n        self.wait(0.8)\n\n        crossed_tex = [\n            VGroup(pythagorean_substitution_3[0][:2]),\n            VGroup(pythagorean_substitution_3[0][3:5]),\n            VGroup(pythagorean_substitution_3[2][:2]),\n            VGroup(pythagorean_substitution_3[2][5:7]),\n        ]\n        crosses = []\n        for tex in crossed_tex:\n            crosses.append(Line(tex.get_critical_point(DL), tex.get_critical_point(UR)))\n        self.play(*[ShowCreation(cross) for cross in crosses])\n        self.wait(0.8)\n\n        inverse_pythagorean_theorem = MathTex(\n            \"\\\\frac{1}{a^2} + \\\\frac{1}{b^2} = \\\\frac{1}{h^2}\"\n        ).next_to(pythagorean_substitution_3, DOWN)\n        self.play(Write(inverse_pythagorean_theorem), run_time=3)\n        self.play(\n            AnimationOnSurroundingRectangle(\n                inverse_pythagorean_theorem,\n                ShowCreation,\n                surrounding_rectangle_config={\"color\": BLACK},\n            )\n        )\n\n        # Position labels for each side.\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\nclass ValentineScene(GraphScene, MovingCameraScene):\n    def setup(self):\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        self.camera.background_color = WHITE\n        self.axes_color = BLACK\n        self.x_min = -PI\n        self.x_max = PI\n        self.x_axis_config = {\"tick_frequency\": PI / 2}\n        self.x_axis_width = 10\n\n        self.y_min = -3\n        self.y_max = 3\n        self.y_axis_height = 10\n        self.graph_origin = ORIGIN\n\n        self.camera_frame.scale(1.3)\n        self.setup_axes()\n        self.remove(\n            self.x_axis, self.y_axis, self.y_axis_label_mob, self.x_axis_label_mob\n        )\n        self.y_axis_label_mob.shift(0.4 * DOWN + 0.2 * RIGHT)\n        self.play(\n            Write(\n                VGroup(\n                    self.x_axis,\n                    self.y_axis,\n                    self.y_axis_label_mob,\n                    self.x_axis_label_mob,\n                )\n            )\n        )\n\n        axis_labels = [\n            MathTex(\"\\\\frac{\\\\pi}{2}\")\n            .scale(0.8)\n            .move_to(self.coords_to_point(PI / 2, -0.35)),\n            MathTex(\"-\\\\frac{\\\\pi}{2}\")\n            .scale(0.8)\n            .move_to(self.coords_to_point(-PI / 2, -0.35)),\n        ]\n\n        # Label axes.\n        self.play(*[Write(label) for label in axis_labels])\n\n        # Draw positive sin.\n        positive_sin = self.get_graph(\n            lambda x: np.sin(x) + 1, color=GRAY, x_min=-PI, x_max=PI\n        )\n        positive_sin_label = (\n            MathTex(\"f(x) = \", \"\\\\sin(x) + 1\")\n            .scale(0.7)\n            .move_to(self.coords_to_point(-PI, 1.2))\n        )\n        self.play(\n            Write(positive_sin_label),\n            ShowCreation(positive_sin),\n        )\n        self.wait(0.7)\n\n        # Trace heart section.\n        heart_red = \"#e0245e\"\n        heart_stroke_width = 6\n\n        def draw_positive_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = self.get_graph(\n                lambda x: np.sin(x) + 1,\n                color=heart_red,\n                x_min=-PI / 2,\n                x_max=-PI / 2 + PI * section.total_time,\n                stroke_width=heart_stroke_width,\n            )\n            section.become(new_section)\n\n        positive_sin_heart_section = self.get_graph(\n            lambda x: np.sin(x) + 1,\n            color=heart_red,\n            x_min=-PI / 2,\n            x_max=-PI / 2,\n            stroke_width=heart_stroke_width,\n        )\n        positive_sin_heart_section.total_time = 0\n        positive_sin_heart_section.add_updater(draw_positive_section)\n        self.add(positive_sin_heart_section)\n\n        self.wait()\n        self.wait(0.7)\n\n        # Draw negative sin.\n        negative_sin = self.get_graph(\n            lambda x: -np.sin(x) - 1, color=GRAY, x_min=-PI, x_max=PI\n        )\n        negative_sin_label = (\n            MathTex(\"f(x) = \", \"-\\\\sin(x) - 1\")\n            .scale(0.7)\n            .move_to(self.coords_to_point(-PI, -1.2))\n        )\n        self.play(\n            Write(negative_sin_label),\n            ShowCreation(negative_sin),\n        )\n        self.wait(0.7)\n\n        # Trace heart section.\n        def draw_negative_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = self.get_graph(\n                lambda x: -np.sin(x) - 1,\n                color=heart_red,\n                x_min=-PI / 2,\n                x_max=-PI / 2 + PI * section.total_time,\n                stroke_width=heart_stroke_width,\n            )\n            section.become(new_section)\n\n        negative_sin_heart_section = self.get_graph(\n            lambda x: -np.sin(x) - 1,\n            color=heart_red,\n            x_min=-PI / 2,\n            x_max=PI / 2,\n            stroke_width=heart_stroke_width,\n        )\n        negative_sin_heart_section.total_time = 0\n        negative_sin_heart_section.add_updater(draw_negative_section)\n        self.add(negative_sin_heart_section)\n        self.wait()\n        self.wait(0.7)\n\n        # Draw the positive circle.\n        positive_circle = Circle(\n            radius=self.y_axis_config[\"unit_size\"],\n            stroke_color=GRAY,\n        ).move_to(self.coords_to_point(PI / 2, 1))\n        positive_circle_label = (\n            MathTex(\"\\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y-1)^2 = 1\")\n            .scale(0.7)\n            .next_to(positive_circle, UR, buff=0.1)\n            .shift(LEFT * 0.8 + DOWN * 0.2)\n        )\n        self.bring_to_back(positive_circle)\n        self.play(ShowCreation(positive_circle), Write(positive_circle_label))\n\n        # Trace the heart section.\n        def draw_positive_circle_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = Arc(\n                radius=self.y_axis_config[\"unit_size\"],\n                start_angle=PI / 2,\n                angle=-PI * section.total_time,\n                color=heart_red,\n                stroke_width=heart_stroke_width,\n            ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n            section.become(new_section)\n\n        positive_circle_heart_section = Arc(\n            radius=self.y_axis_config[\"unit_size\"],\n            start_angle=PI / 2,\n            angle=-PI,\n            color=heart_red,\n            stroke_width=heart_stroke_width,\n        ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n        positive_circle_heart_section.total_time = 0\n        self.add(positive_circle_heart_section)\n        positive_circle_heart_section.add_updater(draw_positive_circle_section)\n        self.wait()\n        self.wait(0.7)\n\n        # Draw the negative circle.\n        negative_circle = Circle(\n            radius=self.y_axis_config[\"unit_size\"],\n            stroke_color=GRAY,\n        ).move_to(self.coords_to_point(PI / 2, -1))\n        negative_circle_label = (\n            MathTex(\"\\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y+1)^2 = 1\")\n            .scale(0.7)\n            .next_to(negative_circle, DR, buff=0.1)\n            .shift(LEFT * 0.8 + UP * 0.2)\n        )\n        self.bring_to_back(negative_circle)\n        self.play(ShowCreation(negative_circle), Write(negative_circle_label))\n\n        # Trace the heart section.\n        def draw_negative_circle_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = Arc(\n                radius=self.y_axis_config[\"unit_size\"],\n                start_angle=-PI / 2,\n                angle=PI * section.total_time,\n                color=heart_red,\n                stroke_width=heart_stroke_width,\n            ).move_arc_center_to(self.coords_to_point(PI / 2, -1))\n            section.become(new_section)\n\n        negative_circle_heart_section = Arc(\n            radius=self.y_axis_config[\"unit_size\"],\n            start_angle=-PI / 2,\n            angle=PI,\n            color=heart_red,\n            stroke_width=heart_stroke_width,\n        ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n        negative_circle_heart_section.total_time = 0\n        self.add(negative_circle_heart_section)\n        negative_circle_heart_section.add_updater(draw_negative_circle_section)\n\n        self.wait()\n        self.wait(0.7)\n\n        # Flip over y = x\n        def inverse_function(func):\n            flipped_func = func.copy()\n            for i, point in enumerate(func.points):\n                x, y, _ = point\n                flipped_func.points[i] = self.coords_to_point(y * 2 / PI, x * PI / 5.2)\n            return flipped_func\n\n        graph_sections = [\n            positive_sin,\n            positive_sin_heart_section,\n            negative_sin,\n            negative_sin_heart_section,\n            positive_circle,\n            positive_circle_heart_section,\n            negative_circle,\n            negative_circle_heart_section,\n        ]\n        for func in graph_sections:\n            func.clear_updaters()\n\n        transforms = []\n        for func in graph_sections:\n            transforms.append(Transform(func, inverse_function(func)))\n\n        graph_label_data = [\n            # f(x) = sin(x) + 1\n            {\n                \"label\": positive_sin_label,\n                \"offset\": UP * 4.5 + RIGHT * 0.5,\n                \"inverse\": [\"f(x) = \", \"-\\\\arcsin(-x + 1)\"],\n            },\n            # f(x) = sin(x) - 1\n            {\n                \"label\": negative_sin_label,\n                \"offset\": UP * 4.5 + LEFT * 0.5,\n                \"inverse\": [\"f(x) = \", \"-\\\\arcsin(x + 1)\"],\n            },\n            # \\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y-1)^2 = 1\n            {\n                \"label\": positive_circle_label,\n                \"offset\": DOWN * 4.1 + RIGHT * 0,\n                \"inverse\": \"\\\\left(y-\\\\frac{\\\\pi}{2}\\\\right)^2 + (x-1)^2 = 1\",\n            },\n            # \\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y+1)^2 = 1\n            {\n                \"label\": negative_circle_label,\n                \"offset\": DOWN * 4.1 + LEFT * 0,\n                \"inverse\": \"\\\\left(y-\\\\frac{\\\\pi}{2}\\\\right)^2 + (x+1)^2 = 1\",\n            },\n        ]\n        animations = []\n        for i, data in enumerate(graph_label_data):\n            label = data[\"label\"]\n            offset = data[\"offset\"]\n            inverse = data[\"inverse\"]\n            x, y, _ = label.get_center()\n            target = label.generate_target()\n            # Match the corresponding terms for the sin transformations.\n            if i < 2:\n                target_tex = MathTex(inverse[0], inverse[1])\n            else:\n                target_tex = MathTex(inverse)\n            target.become(target_tex)\n            target.move_to(self.coords_to_point(y, x)).shift(offset)\n            animations.append(MoveToTarget(label))\n\n        self.play(self.camera_frame.animate.scale(1.2), *transforms, *animations)\n        self.wait(0.5)\n\n        graph_sections = [\n            positive_sin,\n            negative_sin,\n            positive_circle,\n            negative_circle,\n        ]\n        graph_labels = [data[\"label\"] for data in graph_label_data]\n        animations = [\n            FadeOut(mob)\n            for mob in graph_sections\n            + graph_labels\n            + axis_labels\n            + [self.x_axis, self.y_axis, self.x_axis_label_mob, self.y_axis_label_mob]\n        ]\n        self.play(*animations)\n\n        heart_mob = VMobject(\n            stroke_color=heart_red,\n            fill_color=heart_red,\n            stroke_width=heart_stroke_width,\n        )\n        for i, graph_section in enumerate(\n            [\n                positive_sin_heart_section,\n                positive_circle_heart_section,\n                negative_sin_heart_section,\n                negative_circle_heart_section,\n            ]\n        ):\n            heart_mob.append_points(graph_section.points)\n\n        self.remove(\n            positive_sin_heart_section,\n            positive_circle_heart_section,\n            negative_circle_heart_section,\n            negative_sin_heart_section,\n        )\n        self.add(heart_mob)\n        self.play(heart_mob.animate.set_fill(opacity=1))\n        self.wait(0.5)\n\n        heart_mob.generate_target().scale(0.15).shift(UP * 1.7)\n        self.play(MoveToTarget(heart_mob))\n\n        message_front = (\n            Text(\"With\", fill_color=BLACK).scale(1.5).next_to(heart_mob, LEFT)\n        )\n        message_back = (\n            Text(\"from\", fill_color=BLACK).scale(1.5).next_to(heart_mob, RIGHT)\n        )\n\n        self.play(FadeIn(message_front), FadeIn(message_back))\n\n        banner_location = (\n            VGroup(message_front, heart_mob, message_back).get_center() + 3 * DOWN\n        )\n\n        banner = ManimBanner(dark_theme=False).scale(0.9).move_to(banner_location)\n        banner.scale_factor = 2.5\n        self.play(banner.create())\n\n        for mob in [banner.triangle, banner.circle, banner.square]:\n            mob.clear_updaters()\n        self.bring_to_front(banner.M)\n\n        # Position the targets of the M.\n        banner.M.generate_target().shift(LEFT * banner.anim.get_width() * 0.57),\n\n        # Position the anim based on the location of the target.\n        banner.anim.next_to(banner.M.target, RIGHT, 0.1)\n        banner.anim.align_to(banner.M.target, DOWN)\n\n        self.play(\n            banner.M.animate.shift(LEFT * banner.anim.get_width() * 0.57),\n            banner.triangle.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            banner.square.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            banner.circle.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            AnimationGroup(\n                ApplyMethod(VGroup(banner.anim[1], banner.anim[2]).set_opacity, 1),\n                ApplyMethod(VGroup(banner.anim[0], banner.anim[-1]).set_opacity, 1),\n                lag_ratio=0.3,\n            ),\n        )\n\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\nclass Pendulum(VGroup):\n    def phi_fun(self, amplitude, acceleration, length, time):\n        return amplitude * np.sin(np.sqrt(acceleration / length) * time - np.pi / 2)\n\n    def __init__(self, weight, amplitude, acceleration, length, time):\n        VGroup.__init__(self)\n        self.sound_stamps_there = []\n        self.sound_stamps_back = []\n\n        self.amplitude = amplitude\n        self.acceleration = acceleration\n        self.length = length\n        self.time = time\n        self.phi = self.phi_fun(amplitude, acceleration, length, time)\n        self.anchor = Dot(ORIGIN, color=RED)\n        self.line = Line(\n            ORIGIN, length * 1.8 * DOWN, stroke_width=1.6, stroke_opacity=0.2\n        )\n        self.line.rotate(self.phi * DEGREES, about_point=self.line.get_start())\n        self.mass = Dot().set_color(BLUE).scale(1.4)\n        self.mass.move_to(self.line.get_end())\n        self.mobj = VGroup(self.line, self.anchor, self.mass)\n        self.add(self.mobj)\n\n    def start(self):\n        self.mobj.current_time = 0.000001\n\n        def updater(mob, dt):\n            mob.current_time += dt\n            old_phi = self.phi_fun(\n                self.amplitude,\n                self.acceleration,\n                self.length,\n                mob.current_time - 2 * dt,\n            )\n            new_phi = self.phi_fun(\n                self.amplitude, self.acceleration, self.length, mob.current_time\n            )\n            mob[0].rotate(\n                (new_phi - self.phi) * DEGREES, about_point=self.line.get_start()\n            )\n            if (old_phi > self.phi) & (\n                self.phi < new_phi\n            ):  # only used when sound is added.\n                self.sound_stamps_there.append(mob.current_time)\n            if (old_phi < self.phi) & (self.phi > new_phi):\n                self.sound_stamps_there.append(mob.current_time)\n\n            self.phi = new_phi\n            self.mass.move_to(self.line.get_end())\n\n        self.mobj.add_updater(updater)\n\n\nclass PendulumScene(Scene):\n    def construct(self):\n        g = 10\n        oszilations = np.array([8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n        period_length = 30\n        times = 1 / oszilations * period_length\n        lengths = (times / (2 * PI)) ** 2 * g\n        total = len(lengths)\n        pendulums1 = []\n        for i, val in enumerate(lengths):\n            pendulum = Pendulum(\n                weight=1, amplitude=32, acceleration=g, length=val, time=0\n            )\n            if i % 2 == 0:\n                pendulum.mass.set_color(GREEN)\n            anchor_pos = pendulum.anchor.get_center()\n            dest_pos = (-total / 2 + i) * 0.6 * RIGHT + 3.5 * UP\n            pendulum.shift(anchor_pos + dest_pos)\n            pendulums1.append(pendulum)\n            self.add(pendulum)\n        pendulums2 = []\n        for i, val in enumerate(lengths):\n            pendulum = Pendulum(\n                weight=1, amplitude=32, acceleration=10, length=val, time=0\n            )\n            if i % 2 == 0:\n                pendulum.mass.set_color(GREEN)\n            anchor_pos = pendulum.anchor.get_center()\n            dest_pos = 3.5 * UP\n            pendulum.shift(anchor_pos + dest_pos)\n            pendulums2.append(pendulum)\n        self.wait()\n        self.play(Transform(VGroup(*pendulums1), VGroup(*pendulums2)))\n        self.wait(1)\n        for el in pendulums1:\n            el.start()\n        self.wait(35)\n        banner = ManimBanner(dark_theme=True).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner))\n        self.play(banner.expand())\n        self.wait(30)"
  },
  {
    "text": "from manim import *\n\n\nclass Lissajous(Scene):\n    def construct(self):\n        # Simultaneous lissajous curves.\n        lissajous_size = 2\n        lissajous_a = 1\n        lissajous_b = 1\n        lissajous_delta = PI / 4\n        lissajous_rate = 5\n        lissajous_alpha = ValueTracker()\n        offset = PI / 2\n\n        def lissajous_location(t, delta):\n            A = lissajous_size\n            a = lissajous_a\n            b = lissajous_b\n            x = A * np.sin(a * t + offset)\n            y = A * np.sin(b * t + delta + offset)\n            return x * RIGHT + y * UP\n\n        def get_line_length(mob):\n            length = 0\n            start_anchors = mob.get_start_anchors()\n            for i in range(len(start_anchors) - 1):\n                length += get_norm(start_anchors[i + 1] - start_anchors[i])\n            return length\n\n        def grow_line(mob):\n            new_position = lissajous_location(\n                lissajous_alpha.get_value() * mob.rate, mob.delta\n            )\n\n            # Update line length.\n            mob.add_line_to(new_position)\n            mob.line_length += get_norm(new_position - mob.points[-1])\n\n            while get_line_length(mob) > mob.maximum_length:\n                mob.set_points(mob.points[4:])\n\n        def get_lissajous_line(delta, rate):\n            line = VMobject()\n            line.delta = delta\n            line.line_length = 0\n            line.maximum_length = 8\n            line.rate = rate\n            line.points = np.array([lissajous_location(0, line.delta)])\n            line.add_updater(grow_line)\n            return line\n\n        self.add(get_lissajous_line(1 * PI / 8, 1).set_color(RED))\n        self.add(get_lissajous_line(2 * PI / 8, 2).set_color(ORANGE))\n        self.add(get_lissajous_line(3 * PI / 8, 3).set_color(YELLOW))\n        self.add(get_lissajous_line(4 * PI / 8, 4).set_color(GREEN))\n        self.add(get_lissajous_line(5 * PI / 8, 5).set_color(BLUE))\n        self.add(get_lissajous_line(6 * PI / 8, 6).set_color(BLUE_B))\n        self.add(get_lissajous_line(7 * PI / 8, 7).set_color(PURPLE))\n\n        self.play(lissajous_alpha.animate.set_value(20), run_time=32, rate_func=linear)"
  },
  {
    "text": "from manim import *\n\n\nclass Lens(Scene):\n    def construct(self):\n        lens_height = 3\n        lens_width = 0.5\n        focal_length = 4\n\n        lens = VGroup()\n        lens.add(\n            Line(\n                UP * lens_height / 2 + LEFT * lens_width / 2,\n                UP * lens_height / 2 + RIGHT * lens_width / 2,\n            )\n        )\n        lens.add(\n            Line(\n                DOWN * lens_height / 2 + LEFT * lens_width / 2,\n                DOWN * lens_height / 2 + RIGHT * lens_width / 2,\n            )\n        )\n        lens_angle = TAU / 3 - 1.3\n        left_arc = (\n            Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n            .rotate(PI)\n            .set_height(lens_height)\n            .align_to(lens[0], LEFT)\n        )\n        left_arc.shift(LEFT * left_arc.get_width())\n        lens.add(left_arc)\n        right_arc = (\n            Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n            .set_height(lens_height)\n            .align_to(lens[0], RIGHT)\n        )\n        right_arc.shift(RIGHT * right_arc.get_width())\n        lens.add(right_arc)\n\n        original_dist_color = YELLOW\n        image_dist_color = BLUE\n\n        # Update the original.\n        original_arrow = Arrow(ORIGIN, UP, buff=0).shift(3 * LEFT)\n        original_arrow_tracker = ValueTracker(original_arrow.get_x())\n\n        def update_original_arrow(mob):\n            time = original_arrow_tracker.get_value()\n            x_offset = RIGHT * (-4 + np.sin(time * 1.3))\n            mob.move_to(x_offset)\n\n        original_arrow.add_updater(update_original_arrow)\n\n        # Update the arrow indicating the distance to the original.\n        original_dist_arrow = Arrow(\n            ORIGIN, RIGHT * original_arrow_tracker.get_value()\n        ).set_color(original_dist_color)\n\n        def update_original_dist_arrow(mob):\n            original_arrow_x_offset = original_arrow.get_center()[0]\n            mob.put_start_and_end_on(ORIGIN, RIGHT * original_arrow_x_offset)\n            mob.shift(diagram_shift)\n\n        original_dist_arrow.add_updater(update_original_dist_arrow)\n\n        # Update the image arrow.\n        image_arrow = Arrow(\n            ORIGIN,\n            DOWN,\n            buff=0,\n        ).shift(3 * RIGHT)\n\n        def update_image(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            magnification = image_lens_dist / object_lens_dist\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                RIGHT * image_lens_dist + diagram_shift,\n                RIGHT * image_lens_dist\n                + UP * (magnification + arrow_tip_height)\n                + diagram_shift,\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image)\n\n        # Update the arrow indicating the distance to the image.\n        object_lens_dist = original_arrow.get_center()[0]\n        image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n        image_dist_arrow = Arrow(ORIGIN, RIGHT * image_lens_dist).set_color(\n            image_dist_color\n        )\n\n        def update_image_dist_arrow(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            start = ORIGIN + diagram_shift\n            end = RIGHT * image_lens_dist + diagram_shift\n            mob.put_start_and_end_on(start, end)\n\n        image_dist_arrow.add_updater(update_image_dist_arrow)\n\n        self.add(original_arrow, image_arrow)\n        self.add(lens)\n\n        \"\"\"\n        v = 1 / (1 / f - 1 / u)\n        1 / u + 1 / v = (n - 1)(1 / R1 - 1 / R2 + (n-1)d / (n*R1*R2))\n        (1 / u + 1 / v)/ (n-1) = 1 / R1 - 1 / R2 + (n-1)d / (n*R1*R2)\n        (1 / u + 1 / v)/ (n-1) - 1/R1 + 1/R2 = (n-1)d / (n*R1*R2)\n        (1/u + 1/v) / (n-1)^2 - (1/R1 + 1/R2)/(n-1) = d/(n*R1*R2)\n        (n*R1*R2) * (1/u + 1/v) / (n-1)^2 - (1/R1 + 1/R2)/(n-1) = d\n        \"\"\"\n\n        image_lens_dist = 10  # This is only to set the arrow size.\n        diagram_shift = DOWN * 0.5\n\n        original_dist_arrow.add_updater(update_original_dist_arrow)\n        self.add(original_dist_arrow)\n\n        # Indicate the distance to the image arrow.\n\n        self.add(image_dist_arrow)\n\n        VGroup(\n            lens, original_arrow, image_arrow, original_dist_arrow, image_dist_arrow\n        ).shift(diagram_shift)\n\n        description = (\n            Tex(\n                \"The distance between an object and its projected \\\\\\\\\"\n                \"image is given by the thin lens equation: \"\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        thin_lens_equation = (\n            MathTex(\n                \"\\\\frac{1}{u}\",\n                \"+\",\n                \"\\\\frac{1}{v}\",\n                \"=\",\n                \"\\\\frac{1}{f}\",\n            )\n            .scale(0.7)\n            .next_to(description, DOWN)\n        )\n        # Color the distance variables.\n        thin_lens_equation[0][2].set_color(original_dist_color)\n        thin_lens_equation[2][2].set_color(image_dist_color)\n        u_label = MathTex(\"u\", fill_color=original_dist_color).shift(LEFT + DOWN)\n        v_label = MathTex(\"v\", fill_color=image_dist_color).shift(RIGHT + DOWN)\n\n        self.play(\n            original_arrow_tracker.animate.set_value(3.5),\n            Write(description),\n            rate_func=linear,\n            run_time=3.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(4),\n            rate_func=linear,\n            run_time=0.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(5.5),\n            Write(thin_lens_equation),\n            Write(VGroup(u_label, v_label)),\n            rate_func=linear,\n            run_time=1.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(6.5),\n            FadeOut(description),\n            rate_func=linear,\n            run_time=1,\n        )\n\n        image_dist_arrow.set_color(GRAY)\n        v_label.set_color(GRAY)\n        thin_lens_equation[2][2].set_color(GRAY)\n        fixed_distance_explanation = (\n            Tex(\n                \"If the distance to the image is fixed, the distance to the original \"\n                \"will still change according to the lensmaker equation:\"\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        self.wait(0.5)\n        self.play(Write(fixed_distance_explanation))\n\n        lens_width_color = RED\n        lensmaker_equation = (\n            MathTex(\n                \"(n-1)\",\n                \"\\\\left[\",\n                \"\\\\frac{1}{R_1}\",\n                \"-\",\n                \"\\\\frac{1}{R_2}\",\n                \"+\",\n                \"\\\\frac{(n-1)d}{nR_1R_2}\",\n                \"\\\\right]\",\n            )\n            .scale(0.7)\n            .next_to(thin_lens_equation[3], RIGHT)\n        )\n        lensmaker_equation[6][5].set_color(lens_width_color)\n        target = thin_lens_equation.generate_target()\n        target.submobjects[4] = lensmaker_equation\n        target.shift(RIGHT * -target.get_center()[1])\n\n        distance_label = (\n            DoubleArrow(\n                LEFT * lens.get_width() / 2, RIGHT * lens.get_width() / 2, buff=0\n            )\n            .next_to(lens, UP, buff=SMALL_BUFF)\n            .set_color(lens_width_color)\n        )\n        self.play(\n            MoveToTarget(\n                thin_lens_equation,\n            ),\n            FadeIn(distance_label),\n        )\n\n        self.play(FadeOut(fixed_distance_explanation))\n        distance_explanation = (\n            Tex(\n                \"If the \",\n                \"thickness of the lens\",\n                \" is allowed to vary with the distance to the object \"\n                \"the image can be preserved at a fixed distance.\",\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        distance_explanation[1].set_color(lens_width_color)\n        image_dist_arrow.clear_updaters()\n        image_arrow.clear_updaters()\n\n        def update_image_2(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            magnification = image_lens_dist / object_lens_dist\n\n            original_top = mob.get_top()\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                original_top,\n                original_top + UP * (magnification + arrow_tip_height),\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image_2)\n\n        initial_x_offset = original_arrow.get_center()[0]\n\n        def update_lens_thickness(mob):\n            original_arrow_x_offset = original_arrow.get_center()[0]\n            new_width = lens_width / original_arrow_x_offset * initial_x_offset\n            original_lens_center = mob.get_center()\n            lens = VGroup()\n            lens.add(\n                Line(\n                    UP * lens_height / 2 + LEFT * new_width / 2,\n                    UP * lens_height / 2 + RIGHT * new_width / 2,\n                )\n            )\n            lens.add(\n                Line(\n                    DOWN * lens_height / 2 + LEFT * new_width / 2,\n                    DOWN * lens_height / 2 + RIGHT * new_width / 2,\n                )\n            )\n            lens_angle = TAU / 3 - 1.3\n            right_arc = (\n                Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n                .set_height(lens_height)\n                .align_to(lens[0], RIGHT)\n            )\n            right_arc.shift(RIGHT * right_arc.get_width())\n            lens.add(right_arc)\n            left_arc = (\n                Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n                .rotate(PI)\n                .set_height(lens_height)\n                .align_to(lens[0], LEFT)\n            )\n            left_arc.shift(LEFT * left_arc.get_width())\n            lens.add(left_arc)\n            lens.move_to(original_lens_center)\n            mob.become(lens)\n\n            # Update width label.\n            arrow_y_offset = distance_label.get_start()[1]\n            distance_label.put_start_and_end_on(\n                LEFT * lens.get_width() / 2 + UP * arrow_y_offset,\n                RIGHT * lens.get_width() / 2 + UP * arrow_y_offset,\n            )\n\n        lens.add_updater(update_lens_thickness)\n\n        self.play(\n            original_arrow_tracker.animate.set_value(8),\n            Write(distance_explanation),\n            run_time=1.5,\n            rate_func=linear,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(10.5),\n            run_time=2.5,\n            rate_func=linear,\n        )\n        for mob in self.mobjects:\n            mob.clear_updaters()\n        self.play(\n            FadeOutAndShift(\n                VGroup(*[m for m in self.mobjects if isinstance(m, VMobject)]), UP\n            )\n        )\n        #\n        #\n        # class Eye(Scene):\n        #     def construct(self):\n        def get_eye():\n            lens_height = 2\n            lens_width = 0.6\n\n            lens = Ellipse(\n                width=lens_width,\n                height=lens_height,\n                fill_opacity=1,\n                stroke_color=BLUE,\n                fill_color=\"#EEEEEE\",\n            )\n\n            cilliary_muscle_length = 0.2\n            cilliary_muscle = VGroup(\n                Line(\n                    lens.get_top(),\n                    lens.get_top() + cilliary_muscle_length * UP,\n                    stroke_width=8,\n                ).set_color(RED_E),\n                Line(\n                    lens.get_bottom(),\n                    lens.get_bottom() + cilliary_muscle_length * DOWN,\n                    stroke_width=8,\n                ).set_color(RED_E),\n            )\n\n            vitreous_chamber_angle = 0.8 * TAU\n            vitreous_chamber_back = Arc(\n                angle=vitreous_chamber_angle,\n                fill_opacity=1,\n                fill_color=BLUE_C,\n                stroke_color=RED_B,\n            )\n            angle_to_rotate = (vitreous_chamber_angle - TAU) / 2\n            vitreous_chamber_back.rotate(\n                PI - angle_to_rotate, about_point=ORIGIN\n            ).scale(2).shift(RIGHT * 1.7)\n\n            # retina = Arc(\n            #     0.8 * TAU,\n            #     stroke_color=RED_B,\n            # )\n            # retina.rotate(PI - angle_to_rotate, about_point=ORIGIN,).scale(\n            #     2\n            # ).shift(RIGHT * 1.7)\n\n            aqueous_humor_angle = TAU - vitreous_chamber_angle\n            aqueous_humor = (\n                Arc(angle=aqueous_humor_angle, fill_opacity=1, stroke_opacity=0)\n                .set_color(BLUE_A)\n                .rotate(PI - aqueous_humor_angle / 2, about_point=ORIGIN)\n                .scale(2.05)\n                .next_to(vitreous_chamber_back, LEFT, buff=0)\n            )\n\n            cornea_angle = 0.4 * TAU\n            cornea = Arc(\n                angle=cornea_angle,\n                stroke_color=\"#EEEEEE\",\n                stroke_opacity=0.5,\n                fill_color=BLUE_A,\n                fill_opacity=1,\n                stroke_width=14,\n            )\n            cornea.rotate(PI - cornea_angle / 2, about_point=ORIGIN)\n            cornea.next_to(vitreous_chamber_back, LEFT, buff=0)\n            cornea.scale(1.2)\n\n            eye = VGroup(\n                # retina,\n                cornea,\n                vitreous_chamber_back,\n                aqueous_humor,\n                cilliary_muscle,\n                lens,\n            )\n            eye.lens = lens\n            eye.shift(-eye.get_center())\n            return eye\n\n        eye = get_eye()\n        eye_text = Tex(\"Eye\").scale(1.5).next_to(eye, UP)\n        self.play(\n            FadeInFrom(eye_text, UP),\n            FadeInFrom(eye, UP),\n        )\n        self.wait(0.5)\n\n        saved_eye = eye.generate_target()  # Save the eye to restore later.\n        target_eye = eye.generate_target()\n        target_eye.submobjects[0].shift(LEFT * 2)  # cornea\n        target_eye.submobjects[2].shift(LEFT * 2)  # aqueous humor\n        target_eye.submobjects[4].shift(RIGHT * 0.7)  # lens\n        target_eye.submobjects[1].shift(RIGHT * 2)  # vitreous_chamber_back\n        target_eye.submobjects[3].shift(LEFT * 0.5)  # cilliary_muscle\n        self.play(\n            MoveToTarget(eye),\n            FadeOutAndShift(eye_text, UP),\n        )\n\n        cornea_label = Tex(\"Cornea\").scale(0.8).next_to(target_eye.submobjects[0], LEFT)\n        aqueous_humor_label = (\n            Tex(\"Aqueous Humor\").scale(0.8).next_to(target_eye.submobjects[2], DOWN)\n        )\n        lens_label = (\n            Tex(\"Lens\", fill_color=BLUE)\n            .scale(0.8)\n            .next_to(target_eye.submobjects[4], DOWN)\n        )\n        vitreous_chamber_label = (\n            Tex(\"Vitreous\\\\\\\\Chamber\")\n            .scale(0.8)\n            .move_to(target_eye.submobjects[1].get_center())\n        )\n        cilliary_muscle_label = (\n            Tex(\"Cilliary\\\\\\\\Muscle\").scale(0.8).next_to(target_eye.submobjects[3], UP)\n        )\n        retina_label = (\n            Tex(\"Retina\", fill_color=YELLOW)\n            .scale(0.8)\n            .next_to(target_eye.submobjects[1], RIGHT)\n        )\n        self.play(\n            FadeIn(\n                VGroup(\n                    cornea_label,\n                    aqueous_humor_label,\n                    lens_label,\n                    vitreous_chamber_label,\n                    cilliary_muscle_label,\n                    retina_label,\n                )\n            ),\n        )\n\n        eye_lens_explanation = Tex(\n            \"This is how the \",\n            \"lenses\",\n            \" in our eyes focus light on our \",\n            \"retinas\",\n        ).scale(0.9)\n        eye_lens_explanation[1].set_color(BLUE)\n        eye_lens_explanation[3].set_color(YELLOW)\n        eye_lens_explanation.shift(\n            UP\n            * (\n                target_eye.submobjects[1].get_bottom()[1]\n                - eye_lens_explanation.get_top()[1]\n                - 0.8\n            )\n        )\n        eye_lens_explanation_2 = (\n            Tex(\"which are always a fixed distance away.\")\n            .scale(0.9)\n            .next_to(eye_lens_explanation, DOWN, buff=SMALL_BUFF)\n        )\n        self.play(Write(eye_lens_explanation))\n        self.wait(0.5)\n\n        eye.target = saved_eye\n        self.play(\n            MoveToTarget(eye),\n            FadeOut(\n                VGroup(\n                    cornea_label,\n                    aqueous_humor_label,\n                    lens_label,\n                    vitreous_chamber_label,\n                    cilliary_muscle_label,\n                    retina_label,\n                )\n            ),\n        )\n        self.play(eye.animate.shift(3 * RIGHT), run_time=0.7)\n\n        original_arrow = Arrow(ORIGIN, UP * 0.8, buff=0).shift(3 * LEFT)\n        image_arrow = Arrow(ORIGIN, DOWN * 0.7, buff=0).shift(4.8 * RIGHT)\n        focal_axis = Line(\n            original_arrow.get_bottom(),\n            image_arrow.get_top(),\n            stroke_width=3,\n            stroke_color=GREY_B,\n        )\n        self.play(FadeIn(VGroup(original_arrow, image_arrow)))\n        self.play(ShowCreation(focal_axis), run_time=0.7)\n\n        original_arrow_tracker = ValueTracker()\n\n        # Update the original arrow.\n        original_arrow_starting_position = original_arrow.get_center()\n\n        def update_original(mob):\n            time = original_arrow_tracker.get_value()\n            x_offset = 1.5 * RIGHT * np.sin(time * 1.5)\n            mob.move_to(original_arrow_starting_position + RIGHT * x_offset)\n\n        original_arrow.add_updater(update_original)\n\n        lens = eye.submobjects[4]\n        original_image_height = image_arrow.get_height()\n        object_lens_dist = lens.get_center()[0] - original_arrow.get_center()[0]\n        image_lens_dist = image_arrow.get_center()[0] - lens.get_center()[0]\n        original_magnification = image_lens_dist / object_lens_dist\n        magnification_offset_ratio = original_image_height / original_magnification\n\n        def update_image(mob):\n            lens = eye.submobjects[4]\n            object_lens_dist = lens.get_center()[0] - original_arrow.get_center()[0]\n            image_lens_dist = image_arrow.get_center()[0] - lens.get_center()[0]\n            magnification = image_lens_dist / object_lens_dist\n            magnification *= magnification_offset_ratio\n            image_arrow_base = image_arrow.get_top()\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                image_arrow_base,\n                image_arrow_base + DOWN * (magnification - arrow_tip_height),\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image)\n\n        # Update the thickness of the lens.\n        starting_lens_dist = eye.lens.get_center()[0] - original_arrow.get_center()[0]\n\n        def update_lens(mob):\n            original_lens_dist = (\n                eye.lens.get_center()[0] - original_arrow.get_center()[0]\n            )\n            mob.stretch_to_fit_width(0.6 * starting_lens_dist / original_lens_dist)\n\n        lens = eye.lens\n        lens.add_updater(update_lens)\n\n        def update_axis(mob):\n            new_axis = Line(\n                original_arrow.get_bottom(),\n                image_arrow.get_top(),\n                stroke_width=3,\n                stroke_color=GREY_B,\n            )\n            mob.become(new_axis)\n\n        focal_axis.add_updater(update_axis)\n\n        self.play(\n            Write(eye_lens_explanation_2),\n            original_arrow_tracker.animate.set_value(1),\n            rate_func=linear,\n            run_time=1,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(6),\n            rate_func=linear,\n            run_time=5,\n        )"
  },
  {
    "text": "import manim as mn\nimport numpy as np\n\ndef regular_vertices(n, *, radius=1, start_angle=None):\n    if start_angle is None:\n        if n % 2 == 0:\n            start_angle = 0\n        else:\n            start_angle = mn.TAU / 4\n\n    start_vector = mn.rotate_vector(mn.RIGHT * radius, start_angle)\n    vertices     = mn.compass_directions(n, start_vector)\n\n    return vertices, start_angle\n\nclass Star(mn.Polygon):\n    def __init__(self, n=5, *, density=2, outer_radius=1, inner_radius=None, start_angle=None, **kwargs):\n        if density <= 0 or density >= n / 2:\n            raise ValueError(f\"Incompatible density {density}\")\n\n        inner_angle = mn.TAU / (2 * n)\n\n        if inner_radius is None:\n            # Calculate the inner radius for n and density.\n            # See https://math.stackexchange.com/a/2136292\n\n            outer_angle = mn.TAU * density / n\n\n            inverse_x = 1 - np.tan(inner_angle) * ((np.cos(outer_angle) - 1) / np.sin(outer_angle))\n\n            inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)\n\n        outer_vertices, self.start_angle = regular_vertices(n, radius=outer_radius, start_angle=start_angle)\n        inner_vertices, _                = regular_vertices(n, radius=inner_radius, start_angle=self.start_angle + inner_angle)\n\n        vertices = []\n        for pair in zip(outer_vertices, inner_vertices):\n            vertices.extend(pair)\n\n        super().__init__(*vertices, **kwargs)\n\nclass ModularMultiplier(mn.Group):\n    def __init__(self, mobject, *, modulus, factor, rate_func=mn.linear, line_config=None, **kwargs):\n        super().__init__(**kwargs)\n\n        self.mobject   = mobject.copy()\n        self.modulus   = modulus\n        self.factor    = mn.ValueTracker(factor)\n        self.rate_func = rate_func\n\n        self.add(self.mobject)\n\n        if line_config is None:\n            line_config = {}\n\n        self.line_config = line_config\n        self.init_lines()\n        mn.always(self.update_lines)\n\n    def number_to_point(self, n):\n        n %= self.modulus\n        n /= self.modulus\n\n        return self.mobject.point_from_proportion(self.rate_func(n))\n\n    def n2p(self, n):\n        return self.number_to_point(n)\n\n    def init_lines(self):\n        self.lines = mn.VGroup()\n        self.add_to_back(self.lines)\n\n        factor = self.factor.get_value()\n        for n in range(self.modulus):\n            n_point    = self.n2p(n)\n            mult_point = self.n2p(n * factor)\n\n            line = mn.Line(n_point, mult_point, **self.line_config)\n            self.lines.add(line)\n\n    def update_lines(self):\n        factor = self.factor.get_value()\n\n        for n, line in enumerate(self.lines):\n            n_point    = self.n2p(n)\n            mult_point = self.n2p(n * factor)\n\n            line.set_start_and_end_attrs(n_point, mult_point)\n            line.generate_points()\n\nclass ModularScene(mn.Scene):\n    def construct(self):\n        mod = ModularMultiplier(\n            Star(outer_radius=3, color=mn.BLUE),\n\n            modulus = 300,\n            factor  = 1,\n\n            line_config = {\n                \"stroke_width\": 1,\n            },\n        )\n\n        mod_var    = mn.Tex(\"Modulus\", \"$=$\", f\"${mod.modulus}$\")\n        factor_var = mn.Variable(mod.factor.get_value(), mn.Tex(\"Factor\"))\n\n        # Arrange mod_var so it lines up well with factor_var's elements\n        mod_var[2].align_to(factor_var, mn.UR)\n        mod_var[1].next_to(factor_var.label[0], mn.RIGHT)\n        mod_var[0].next_to(mod_var[1], mn.LEFT)\n        mod_var.shift((factor_var.height + 0.25) * mn.UP)\n\n        factor_var.add_updater(lambda v: v.tracker.set_value(mod.factor.get_value()))\n\n        info = mn.VGroup(mod_var, factor_var)\n        info.to_corner(mn.UR)\n\n        self.add(info, mod)\n\n        self.animate_factors(mod, [2, 1])\n\n    def animate_factors(self, mod, iterable, *, wait=0.3, run_time=2, **kwargs):\n        for f in iterable:\n            self.play(mod.factor.animate.set_value(f), run_time=run_time, **kwargs)\n            self.wait(wait)"
  },
  {
    "text": "from manim import *\n\nclass SortingVisualization(Scene):\n    def construct(self):\n        array = [4, 1, 3, 2, 5]\n        bars = VGroup(*[Rectangle(height=n, width=0.5, fill_opacity=1) for n in array])\n        bars.arrange(RIGHT, buff=0.1).to_edge(DOWN)\n\n        for i in range(len(array)):\n            for j in range(len(array) - i - 1):\n                bar1, bar2 = bars[j], bars[j + 1]\n                if array[j] > array[j + 1]:\n                    array[j], array[j + 1] = array[j + 1], array[j]\n                    self.play(\n                        bar1.animate.move_to(bar2.get_center()),\n                        bar2.animate.move_to(bar1.get_center()),\n                        run_time=0.5\n                    )\n                    bars[j], bars[j + 1] = bars[j + 1], bars[j]\n                self.wait(0.1)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\nimport random\n\nclass LawOfLargeNumbers(Scene):\n    def construct(self):\n        heads = 0\n        total = 0\n        heads_ratio = always_redraw(lambda: DecimalNumber(heads / total if total > 0 else 0).to_edge(UP))\n\n        for _ in range(100):\n            total += 1\n            if random.random() < 0.5:\n                heads += 1\n            self.play(\n                ChangeDecimalToValue(heads_ratio, heads / total if total > 0 else 0),\n                run_time=0.1\n            )\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParametricCurve3D(ThreeDScene):\n    def construct(self):\n        curve = ParametricFunction(\n            lambda t: np.array([\n                np.sin(t), \n                np.cos(t), \n                t / 2\n            ]),\n            t_range=[0, TAU], \n            color=BLUE\n        )\n        axes = ThreeDAxes()\n\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.play(Create(axes), Create(curve))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(5)"
  },
  {
    "text": "from manim import *\n\nclass LissajousCurve(Scene):\n    def construct(self):\n        path = ParametricFunction(\n            lambda t: np.array([\n                2 * np.sin(3 * t + PI/2),\n                2 * np.sin(2 * t),\n                0\n            ]),\n            t_range=[0, TAU],\n            color=RED\n        )\n\n        dot = Dot(color=RED).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=5, rate_func=linear)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ComplexRootsOfUnity(Scene):\n    def construct(self):\n        plane = ComplexPlane().add_coordinates()\n        roots = [np.exp(2 * PI * 1j * k / 5) for k in range(5)]\n        dots = VGroup(*[Dot(plane.n2p(root), color=BLUE) for root in roots])\n        lines = VGroup(*[Line(plane.n2p(0), dot.get_center(), color=YELLOW) for dot in dots])\n\n        self.play(Create(plane))\n        self.play(AnimationGroup(*[GrowFromCenter(dot) for dot in dots], lag_ratio=0.1))\n        self.play(ShowCreation(lines))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PendulumMotion(Scene):\n    def construct(self):\n        pivot = Dot(UP * 2)\n        bob = Dot(DOWN * 1)\n        rod = Line(pivot.get_center(), bob.get_center()).set_stroke(width=2)\n        pendulum = VGroup(pivot, rod, bob)\n        \n        self.play(FadeIn(pivot), GrowFromCenter(bob), ShowCreation(rod))\n        self.play(Rotating(rod, radians=PI/4, about_point=pivot.get_center(), rate_func=there_and_back, run_time=2))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeries(Scene):\n    def construct(self):\n        square_wave = lambda x: 1 if x % 2 < 1 else -1\n        approx = FourierSeries(square_wave, n_terms=10)\n        \n        self.play(Create(approx), run_time=5)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SphericalHarmonic(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        \n        def param_surface(u, v):\n            return np.array([\n                np.sin(u) * np.cos(v),\n                np.sin(u) * np.sin(v),\n                np.cos(u)\n            ]) * (1 + 0.3 * np.sin(5 * u) * np.cos(5 * v))\n\n        surface = ParametricSurface(param_surface, u_range=[0, PI], v_range=[0, TAU], resolution=(resolution_fa, resolution_fa))\n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"
  },
  {
    "text": "from manim import *\n\nclass VectorFieldGraph(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        field = ArrowVectorField(lambda p: np.array([-p[1], p[0], 0]), x_range=[-5, 5], y_range=[-5, 5])\n        \n        self.play(Create(plane))\n        self.play(Create(field))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass MontyHallProblem(Scene):\n    def construct(self):\n        doors = VGroup(*[Square() for _ in range(3)]).arrange(RIGHT, buff=1)\n        car_door = np.random.randint(0, 3)\n        goats = [Tex(\"Goat\") for _ in range(3)]\n        car = Tex(\"Car\")\n\n        for i, door in enumerate(doors):\n            door_content = car if i == car_door else goats[i]\n            door_content.next_to(door, UP)\n            self.play(FadeIn(door), Write(door_content))\n\n        description = Tex(\"One of these doors has a car behind it,\\\\and the others have goats.\").to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DifferentialEquationSolution(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\frac{dy}{dx}\", \"=\", r\"x^2 - y^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        step1 = Tex(\"Separate the variables: $\\\\frac{dy}{y^2} = x^2dx$\")\n        self.play(Write(step1))\n        self.wait(1)\n\n        step2 = Tex(\"Integrate both sides: $\\\\int \\\\frac{dy}{y^2} = \\\\int x^2dx$\")\n        self.play(Write(step2))\n        self.wait(1)\n\n        step3 = MathTex(r\"- \\frac{1}{y}\", \"=\", r\"\\frac{x^3}{3} + C\")\n        self.play(Write(step3))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierTransformVisualization(Scene):\n    def construct(self):\n        function = Tex(\"f(x) = sin(x)\")\n        self.play(Write(function))\n        self.wait(1)\n\n        transform = Tex(\"Fourier Transform of $f(x)$\")\n        self.play(Transform(function, transform))\n        self.wait(1)\n\n        explanation = Tex(\"This transforms the function into frequency space.\")\n        self.play(Write(explanation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ComplexFunction3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.play(Create(axes))\n        self.wait(1)\n\n        function = Tex(r\"f(z) = z^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        surface = ParametricSurface(\n            lambda u, v: axes.c2p(u * np.cos(v), u * np.sin(v), u**2),\n            u_range=[-2, 2], v_range=[0, TAU]\n        )\n        self.play(Create(surface))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PlanetaryMotion(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=0.5, color=YELLOW).shift(LEFT * 2)\n        earth = Sphere(radius=0.2, color=BLUE).shift(RIGHT * 3)\n\n        self.play(FadeIn(sun), FadeIn(earth))\n        description = Tex(\"The Earth orbits around the Sun due to gravitational forces.\")\n        self.play(Write(description))\n        self.wait(1)\n\n        orbit = Ellipse(width=6, height=3, color=WHITE)\n        self.play(ShowCreation(orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), run_time=5))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanTheorem(Scene):\n    def construct(self):\n        # Creating the initial right triangle\n        triangle = RightTriangle().scale(2)\n        a_label = Tex(\"a\").next_to(triangle, LEFT)\n        b_label = Tex(\"b\").next_to(triangle, DOWN)\n        c_label = Tex(\"c\").next_to(triangle.get_hypotenuse(), RIGHT, buff=0.5)\n\n        self.play(Create(triangle))\n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.wait(1)\n\n        # Explanation\n        explanation = Tex(\"In a right triangle, the square of the hypotenuse\\\\\\\\\",\n                          \"is equal to the sum of the squares of the other two sides.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Creating squares on each side\n        a_square = Square().scale(0.5).next_to(triangle, LEFT)\n        b_square = Square().scale(0.5).next_to(triangle, DOWN)\n        c_square = Square().scale(0.7).align_to(triangle.get_hypotenuse(), RIGHT)\n\n        self.play(Create(a_square), Create(b_square), Create(c_square))\n        self.wait(1)\n\n        # Final proof animation\n        proof_text = Tex(\"a^2 + b^2 = c^2\").to_edge(DOWN)\n        self.play(Write(proof_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass LimitConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"As $x$ approaches 2, the value of $x^2$ approaches 4.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(2, 4))\n        approaching_line = DashedLine(start=axes.c2p(2, 0), end=axes.c2p(2, 4), color=YELLOW)\n\n        self.play(Create(approaching_line), FadeIn(dot))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass MatrixMultiplication(Scene):\n    def construct(self):\n        matrix1 = Matrix([[1, 2], [3, 4]], left_bracket=\"(\", right_bracket=\")\")\n        matrix2 = Matrix([[2, 0], [1, 3]], left_bracket=\"(\", right_bracket=\")\")\n\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait(1)\n\n        description = Tex(\"To multiply two matrices, we take the dot product\\\\\\\\\",\n                          \"of rows from the first matrix with columns of the second.\")\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Highlighting rows and columns\n        row_highlight = SurroundingRectangle(matrix1.get_rows()[0], color=GREEN)\n        col_highlight = SurroundingRectangle(matrix2.get_columns()[0], color=PINK)\n        self.play(Create(row_highlight), Create(col_highlight))\n        self.wait(2)\n\n        # Showing the multiplication process\n        result_matrix = Matrix([[2, 6], [6, 12]], left_bracket=\"(\", right_bracket=\")\")\n        result_matrix.move_to(RIGHT * 3)\n        self.play(Transform(matrix1, result_matrix))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ElectricFieldLines(Scene):\n    def construct(self):\n        charge = Dot(ORIGIN, color=RED)\n        charge_label = Tex(\"+\").next_to(charge, UP)\n\n        self.play(FadeIn(charge), Write(charge_label))\n        self.wait(1)\n\n        field_lines = StreamLines(\n            lambda p: np.array([p[0], p[1], 0]) / np"
  },
  {
    "text": "from manim import *\n\nclass EulersFormula(Scene):\n    def construct(self):\n        formula = MathTex(\"e^{i\\\\theta} = \\\\cos(\\\\theta) + i\\\\sin(\\\\theta)\")\n        self.play(Write(formula))\n        self.wait(1)\n\n        # Explanation of Euler's formula\n        explanation1 = Tex(\"Euler's formula connects complex exponentials \", \n                           \"and trigonometric functions.\")\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        explanation2 = Tex(\"It's a fundamental formula in complex analysis.\")\n        explanation2.next_to(explanation1, DOWN, aligned_edge=LEFT)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Visualizing on the complex plane\n        plane = ComplexPlane()\n        circle = Circle(radius=2, color=BLUE)\n\n        self.play(Create(plane), Create(circle))\n        self.wait(1)\n\n        # Animation of the formula's components\n        dot = Dot(color=RED).move_to(circle.get_start())\n        vector = Arrow(ORIGIN, circle.get_start(), buff=0)\n\n        self.play(MoveAlongPath(dot, circle), ShowCreation(vector), run_time=5, rate_func=linear)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass IntegrationBySubstitution(Scene):\n    def construct(self):\n        integral = MathTex(\"\\\\int x\\\\cos(x^2)dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Step 1: Substitution\n        step1 = Tex(\"Let $u = x^2$, then $du = 2xdx$\")\n        self.play(Write(step1))\n        self.wait(2)\n\n        step2 = Tex(\"The integral becomes $\\\\frac{1}{2}\\\\int \\\\cos(u)du$\")\n        self.play(Write(step2))\n        self.wait(2)\n\n        # Step 2: Solving the new integral\n        step3 = Tex(\"Integrate to get $\\\\frac{1}{2}\\\\sin(u) + C$\")\n        self.play(Write(step3))\n        self.wait(2)\n\n        # Step 3: Back Substitution\n        final_step = MathTex(\"\\\\frac{1}{2}\\\\sin(x^2) + C\")\n        self.play(ReplacementTransform(step3, final_step))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ProjectileMotionWithAirResistance(Scene):\n    def construct(self):\n        # Initial setup\n        description1 = Tex(\"Projectile motion with air resistance\")\n        self.play(Write(description1))\n        self.wait(1)\n\n        description2 = Tex(\"The motion is influenced by gravity and drag force.\")\n        description2.next_to(description1, DOWN)\n        self.play(Write(description2))\n        self.wait(2)\n\n        # Physics equations\n        equations = VGroup(\n            MathTex(\"F_{drag} = -k v^2\"),\n            MathTex(\"\\\\vec{a} = g - \\\\frac{F_{drag}}{m}\")\n        ).arrange(DOWN, aligned_edge=LEFT)\n\n        self.play(Write(equations))\n        self.wait(2)\n\n        # Animation of the projectile\n        projectile = Dot()\n        path = Parabola(start=LEFT * 4, end=RIGHT * 4, height=2)\n        self.play(FadeIn(projectile), ShowCreation(path))\n        self.play(MoveAlongPath(projectile, path), run_time=4)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExpansion(Scene):\n    def construct(self):\n        # Introduction\n        intro_text = Tex(\"Fourier Series Expansion of a Periodic Function\")\n        self.play(Write(intro_text))\n        self.wait(1)\n\n        # Explanation of Fourier series\n        explanation = Tex(\"A periodic function can be expressed as the sum of\\\\\\\\\",\n                          \"sines and cosines of different frequencies.\")\n        explanation.next_to(intro_text, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Showing the formula\n        formula = MathTex(\"f"
  },
  {
    "text": "from manim import *\n\nclass StreamLinePlot(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]), \n            stroke_width=3,\n            max_anchors_per_line=30,\n        )\n        self.add(plane)\n        self.add(stream_lines)\n        self.play(stream_lines.create())  # Uses the StreamLines Animation\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#f8eedb\"\nTEXT_COLOR = \"#403c3c\"\nLIGHT_GREEN_COLOR = \"#4caf50\"\nLIGHT_BLUE_COLOR = \"#2196f3\"\nLIGHT_YELLOW_COLOR = \"#ffeb3b\"\nLIGHT_RED_COLOR = \"#f44336\"\nPURPLE_COLOR = \"#9c27b0\"\n\ndef ease_in_quad(t):\n    return rate_functions.ease_in_quad(t)\n\ndef PrimeRectangle(width, height, color):\n    rect = Rectangle(width=width, height=height, color=color)\n\n    label = Tex(f\"p={width * height}\", color=color)\n    label.scale(0.5)\n    label.move_to(rect)\n\n    return Group(rect, label)\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PrimePattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"N\u00fameros primos e ret\u00e2ngulos\", color=LIGHT_GREEN_COLOR)\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        prime_rectangles = VGroup()\n\n        for i, prime in enumerate(primes):\n            color = interpolate_color(LIGHT_BLUE_COLOR, PURPLE_COLOR, i / (len(primes) - 1))\n            rectangle = PrimeRectangle(1, prime, color=color)\n            prime_rectangles.add(rectangle)\n\n        prime_rectangles.arrange_in_grid(rows=2, cols=5, buff=0.5)\n        prime_rectangles.move_to(ORIGIN)\n\n        self.add(title)\n        self.wait(0.5)\n\n        for rectangle in prime_rectangles:\n            self.play(\n                FadeIn(rectangle),\n                run_time=0.5,\n                rate_func=ease_in_quad\n            )\n            self.wait(0.25)\n\n        self.wait(1)\n        self.play(\n            FadeOut(prime_rectangles),\n            run_time=1\n        )\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n        derivative_graph = axes.plot(lambda x: 2 * x, color=ORANGE)\n\n        tangent_line = always_redraw(\n            lambda: axes.get_tangent_line(\n                x=1, \n                graph=func_graph, \n                length=4, \n                line_color=PURPLE\n            )\n        )\n        \n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        self.play(Write(derivative_graph), run_time=2)\n        self.wait(1)\n\n        self.play(Create(tangent_line), run_time=2)\n        self.wait(2)\n\n        explanation = Tex(r\"The tangent line at $x=1$ represents \\\\ the derivative of $x^2$, which is $2x$.\")\n        explanation.next_to(tangent_line, UP)\n        explanation.shift(RIGHT*3)\n\n        self.play(Write(explanation))\n        self.wait(2)"
  },
  {
    "text": "BACKGROUND_COLOR = \"#d3e0ff\"\nTEXT_COLOR = \"#303030\"\nLIGHT_YELLOW_COLOR = \"#fff89a\"\nLIGHT_GREEN_COLOR = \"#7cd992\"\nLIGHT_BLUE_COLOR = \"#6ab0f3\"\nORANGE_COLOR = \"#ff9f68\"\nPURPLE_COLOR = \"#b28fd0\"\nTEAL_COLOR = \"#2dd4bf\"\nDARK_GREEN_COLOR = \"#1b5e20\"\nDARK_BLUE_COLOR = \"#1a237e\"\nSAND_COLOR = \"#f4e1c0\"\nBROWN_COLOR = \"#795548\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef ThoughtBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=6, height=3, corner_radius=0.75),\n        Polygram([\n            [6/3, -3 + 0.5, 0],\n            [6/3 - 0.3, -3 + 1.1, 0], \n            [6/3 + 0.8, -3 + 1.1, 0]\n        ])\n    )\n    gp.center()\n    \n    return Union(*gp, **kwargs)\n\nclass QuestionThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        robot = ImageMobject(\"./assets/robot_image.png\")\n        robot.scale(0.5)\n        robot.shift(8 * RIGHT)\n        thought = ThoughtBubble(color=TEXT_COLOR, fill_opacity=0.9, fill_color=LIGHT_YELLOW_COLOR)\n        thought.next_to(robot, UP+LEFT)\n        text_group = VGroup(\n            Text(\"What is\", font_size=28, color=TEXT_COLOR),\n            Text(\"the square root\", font_size=28, color=TEXT_COLOR),\n            Text(\"of 16?\", font_size=28, color=TEXT_COLOR)\n        )\n        text_group.arrange(DOWN, aligned_edge=LEFT)\n        text_group.next_to(robot, UP+LEFT)\n        \n        self.play(\n            robot.animate.shift(7 * LEFT),\n            FadeIn(thought, shift=DOWN),\n            FadeIn(text_group, shift=DOWN)\n        )\n        self.wait(3)\n        self.play(\n            robot.animate.shift(7 * RIGHT),\n            FadeOut(thought, target_position=thought.get_top()),\n            FadeOut(text_group, target_position=text_group.get_top())\n        )\n        self.remove(robot, thought, text_group)"
  },
  {
    "text": "from manim import *\n\nclass DisplayUnits(Scene):\n    def construct(self):\n        # Create a grid to visualize screen units\n        grid = NumberPlane()\n        self.add(grid)\n\n        # Different percentages of the screen width and color for each rectangle\n        percentages = [10, 20, 30, 40, 50]\n        colors = [RED, GREEN, BLUE, ORANGE, PURPLE]\n\n        # Create and add rectangles to the scene\n        for percent, color in zip(percentages, colors):\n            self.add(\n                Rectangle(\n                    width=percent * Percent(X_AXIS),\n                    height=10 * Percent(Y_AXIS),\n                    color=color,\n                    fill_opacity=0.5\n                )\n            )\n\n        # Create and add a dot at a fixed number of pixels from the origin\n        dot = Dot(point=ORIGIN).shift(150 * Pixels * UP + 150 * Pixels * RIGHT)\n        self.add(dot)\n"
  },
  {
    "text": "from manim import Scene, Circle, FadeIn_x000D_\n_x000D_\nclass CreateCircleScene(Scene):_x000D_\n    def construct(self):_x000D_\n        circle = Circle() # Create a circle_x000D_\n        circle.set_fill(PINK, opacity=0.5) # Set the color and transparency_x000D_\n        self.play(FadeIn(circle)) # Fade the circle in_x000D_\n        self.wait(2) # Wait for 2 seconds"
  },
  {
    "text": "from manim import *\n\nclass GraphTheoryPrim(Scene):\n    def construct(self):\n        vertices = [\n            (np.cos(ang), np.sin(ang), 0)\n            for ang in np.linspace(0, TAU, 7, endpoint=False)\n        ]\n\n        edges = [\n            (0, 2),\n            (0, 3),\n            (1, 3),\n            (1, 4),\n            (2, 3),\n            (2, 5),\n            (3, 4),\n            (3, 5),\n            (3, 6),\n            (4, 6),\n            (5, 6),\n        ]\n\n        g = Graph(vertices, edges, layout=\"spring\", labels=True)\n        self.play(Create(g))\n        self.wait()\n\n        def prims_algorithm(graph, start_vertex=0):\n            mst_edges = set()\n            visited_vertices = {start_vertex}\n            available_edges = {\n                edge for edge in graph.edges if start_vertex in edge\n            }\n\n            while available_edges:\n                min_edge = min(\n                    available_edges,\n                    key=lambda edge: graph[edge[0]].get_center().get_distance(\n                        graph[edge[1]].get_center()\n                    ),\n                )\n                available_edges.remove(min_edge)\n                if min_edge[0] not in visited_vertices:\n                    new_vertex = min_edge[0]\n                else:\n                    new_vertex = min_edge[1]\n\n                if new_vertex not in visited_vertices:\n                    visited_vertices.add(new_vertex)\n                    mst_edges.add(min_edge)\n                    for edge in graph.edges:\n                        if new_vertex in edge and edge not in mst_edges:\n                            available_edges.add(edge)\n\n            return mst_edges\n\n        mst_edges = prims_algorithm(g)\n        mst_graph = Graph(\n            vertices,\n            list(mst_edges),\n            layout=\"spring\",\n            labels=True,\n            edge_type=DashedLine,\n            edge_config={\"stroke_width\": 4, \"color\": BLUE},\n        )\n\n        self.play(Transform(g, mst_graph))\n        self.wait()\n\n        tree_label = Tex(\"Minimum Spanning Tree (Prim's Algorithm)\")\n        tree_label.move_to(3 * UP)\n        self.play(Write(tree_label))\n        self.wait(1)\n\n        self.play(FadeOut(g), FadeOut(tree_label))"
  },
  {
    "text": "from manim import *\n\nMOON_ORBIT_RADIUS = 2\nEARTH_RADIUS = 0.3\nMOON_RADIUS = 0.1\nMOON_ORBIT_RATE = 0.25\nANIMATION_TIME = 60\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth and moon\n        earth = Circle(radius=EARTH_RADIUS, color=BLUE)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.3)\n        moon = Circle(radius=MOON_RADIUS, color=GREY)\n\n        earth.move_to(ORIGIN)\n        moon_orbit.move_to(earth.get_center())\n        moon.move_to(moon_orbit.point_at_angle(0))\n\n        self.add(earth, moon_orbit, moon)\n\n        # Moon's orbit around earth\n        moon_tracker = ValueTracker(0)\n        def update_moon(mob):\n            alpha = moon_tracker.get_value() / ANIMATION_TIME\n            angle = TAU * alpha * MOON_ORBIT_RATE\n            mob.move_to(moon_orbit.point_at_angle(angle))\n        \n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.add(moon_tracker)\n        self.play(moon_tracker.animate.set_value(ANIMATION_TIME), run_time=ANIMATION_TIME, rate_func=linear)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef ThoughtBubble(**kwargs):\n    gp = VGroup(\n        Ellipse(width=4, height=3),\n        Polygram([\n            [-4/3, -3 + 0.45, 0], \n            [-4/2.6, -3 + 0.9, 0], \n            [-4/2.6 + 0.85, -3 + 0.9, 0]\n        ]),\n        Dot([-4/2.6 + 1.35, -3 + 0.9, 0], radius=0.1),\n        Dot([-4/2.6 + 1.6, -3 + 0.75, 0], radius=0.1),\n        Dot([-4/2.6 + 1.85, -3 + 0.6, 0], radius=0.1)\n    )\n\n    return Union(*gp, **kwargs)\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass GreatestCommonDivisor(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        math_student = ImageMobject(\"./assets/math_student.png\")\n        math_student.scale(0.7)\n        math_student.to_edge(DOWN)\n        \n        thought = ThoughtBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_BLUE_COLOR)\n        thought.next_to(math_student, UP+LEFT, buff=0.3)\n        \n        gcd_text = VGroup(\n            Text(\"Qual \u00e9 o MDC\", color=WHITE),\n            Text(\"de 48 e 64?\", color=WHITE)\n        )\n        gcd_text.scale(0.7)\n        gcd_text.arrange(DOWN, buff=0.1)\n        gcd_text.move_to(thought.get_center_of_mass() + 0.3*UP + 0.4*RIGHT)\n        \n        self.play(FadeIn(math_student))\n        self.play(Create(thought), Write(gcd_text))\n        self.wait(2)\n        \n        answer_text = VGroup(\n            Text(\"MDC(48, 64) = 16\", color=WHITE)\n        )\n        answer_text.scale(0.7)\n        answer_text.to_edge(UP)\n        \n        self.play(ReplacementTransform(gcd_text, answer_text))\n        self.wait(2)\n        \n        self.play(FadeOut(math_student), FadeOut(thought), FadeOut(answer_text))"
  },
  {
    "text": "class TransformShapes(Scene):\n    def construct(self):\n        t = Triangle(color=BLUE, fill_opacity=0.5)\n        r = Rectangle(color=YELLOW, fill_opacity=0.5)\n        self.add(t, r)\n        self.play(t.animate.shift(LEFT), r.animate.shift(RIGHT))\n        self.play(t.animate.rotate(PI/4), r.animate.rotate(-PI/4))\n        self.play(Transform(t, r), ReplacementTransform(r.copy(), t))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass TransformShapes(Scene):\n    def construct(self):\n        r = Rectangle color=BLUE, fill_opacity=0.7)\n        t = Triangle(color=YELLOW, fill_opacity=0.7)\n        self.add(r, t)\n        self.play(r.animate.shift(LEFT), t.animate.shift(RIGHT))\n        self.play(r.animate.rotate(PI/4), t.animate.rotate(-PI/4))\n        self.play(Transform(r, t))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        # Create a square with a label\n        square = Square()\n        label = Text(\"Math is Fun!\").scale(0.7)\n        group = VGroup(square, label).arrange(UP)\n\n        # Create an animated boundary around the square with specified colors\n        animated_boundary = AnimatedBoundary(group, colors=[TEAL, PURPLE, YELLOW])\n\n        # Add the square and the animated boundary to the scene\n        self.add(group, animated_boundary)\n\n        # Play the animation where the square scales up and down\n        self.play(group.animate.scale(1.5), run_time=2)\n        self.play(group.animate.scale(0.66), run_time=2)\n\n        # Wait for a moment\n        self.wait(2)\n\n        # Remove the square and the animated boundary from the scene\n        self.remove(group, animated_boundary)"
  },
  {
    "text": "class MovingFrameBoxExample(Scene):\n    def construct(self):\n        text_group = VGroup(\n            Text(\"This is a sample\"), Text(\"of moving\"), Text(\"FrameBoxes\")\n        ).arrange(DOWN, buff=0.5)\n\n        frame_box1 = SurroundingRectangle(text_group[0], color=BLUE)\n        frame_box2 = SurroundingRectangle(text_group[1], color=GREEN)\n        frame_box3 = SurroundingRectangle(text_group[2], color=RED)\n\n        self.add(text_group, frame_box1)\n        self.wait(0.5)\n        self.play(ReplacementTransform(frame_box1, frame_box2))\n        self.wait(0.5)\n        self.play(ReplacementTransform(frame_box2, frame_box3))\n        self.wait(0.5)\n\n        frame_movement = frame_box3.copy()\n        path = VMobject()\n        path.set_points_as_corners([frame_box3.get_center(), frame_box3.get_center() + 2*UP])\n        self.play(MoveAlongPath(frame_movement, path), run_time=2)\n\n        self.wait(1)"
  },
  {
    "text": "from manim import Scene, VGroup, Circle, SQUARE, ORIGIN, Create, FadeOut\n\nclass NeuralNetworkAnimation(Scene):\n    def construct(self):\n        # Create a group of circles to represent neurons\n        neurons = VGroup(*[Circle(radius=0.1, color=SQUARE) for _ in range(5)])\n        neurons.arrange_in_grid(rows=1, buff=0.5)\n        neurons.move_to(ORIGIN)\n\n        # Animation: creation of each neuron\n        self.play(*(Create(neuron) for neuron in neurons))\n\n        # Animation: Fade out all neurons\n        self.play(*(FadeOut(neuron) for neuron in neurons))"
  },
  {
    "text": "from manim import *\n\nclass WaveExample(Scene):\n    def construct(self):\n        some_text = Text(\"Hello, Manim!\")\n        self.play(Write(some_text))\n        self.wait(0.5)\n        self.play(ApplyWave(some_text))\n        self.play(ApplyWave(some_text, amplitude=0.5))\n        self.wait(0.5)\n        self.play(Unwrite(some_text))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass CircumscribeExample(Scene):\n    def construct(self):\n        text = Text(\"Inscribe\")\n        self.add(text)\n        self.wait(0.5)\n        self.play(Transform(text, Text(\"Inscribe a Square\").shift(DOWN*2)))\n        self.wait(0.5)\n\n        square = Square()\n        square.surround(text)\n        self.play(ShowCreation(square))\n        self.wait(0.5)\n\n        self.play(FadeOut(square))\n        self.wait(0.5)\n\n        self.play(Transform(text, Text(\"Inscribe a Triangle\").shift(DOWN*2)))\n        self.wait(0.5)\n\n        triangle = Triangle()\n        triangle.surround(text)\n        self.play(ShowCreation(triangle))\n        self.wait(0.5)\n\n        self.remove(triangle, text)"
  },
  {
    "text": "class Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(\n                self.mobject.get_center() + np.random.uniform(-1, 1, size=3))\n              for _ in range(self.dot_number)]\n        ).set_opacity(0)\n    \n    def begin(self):\n        self.mobject.set_opacity(0)\n        self.starting_mobject = self.mobject.copy()\n        self.starting_mobject.add(self.dots)\n        super().begin()\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n            \n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.dots.set_opacity(alpha * 2)\n            for dot in self.dots:\n                dot.move_to(dot.get_center() + alpha*(self.mobject.get_center() - dot.get_center()))\n        else:\n            self.mobject.set_opacity((alpha - 0.5) * 2)\n            self.dots.set_opacity((1 - alpha) * 2)\n            for dot in self.dots:\n                dot.move_to(self.mobject.get_center())\n\nclass CustomAnimationGatherExample(Scene):\n    def construct(self):\n        circle = Circle(color=RED, fill_opacity=1).scale(3)\n        self.play(Gather(circle, dot_number=200, run_time=4))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass TorusSurface(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n\n        def param_surface(u, v):\n            R = 1\n            r = 0.25\n            return np.array([\n                (R + r * np.cos(v)) * np.cos(u),\n                (R + r * np.cos(v)) * np.sin(u),\n                r * np.sin(v)\n            ])\n\n        surface = ParametricSurface(\n            param_surface,\n            u_range=[0, TAU],\n            v_range=[0, TAU],\n            resolution=(resolution_fa, resolution_fa)\n        )\n        surface.set_style(fill_opacity=0.5, stroke_color=BLUE)\n        \n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(10)"
  },
  {
    "text": "class ShapesComposition(Scene):\n    def construct(self):\n        square = Square(color=RED)\n        circle = Circle(color=BLUE).next_to(square, RIGHT)\n        triangle = Triangle(color=YELLOW).next_to(square, UP)\n        shape_group = VGroup(square, circle, triangle)\n        shape_group.to_edge(LEFT)\n        self.add(shape_group)\n\n        rectangles = VGroup(*[Rectangle(height=0.4, width=0.6) for _ in range(5)])\n        rectangles.arrange(DOWN, buff=0.3)\n        self.add(rectangles)\n\n        polygons = VGroup(*[RegularPolygon(n, color=ORANGE, fill_opacity=0.5).scale(0.4) for n in range(3, 8)])\n        polygons.arrange_in_grid(2, 3, buff=0.3)\n        self.add(polygons)"
  },
  {
    "text": "class MultipleTransformations(Scene):\n    def construct(self):\n        t = Triangle()\n        self.add(t)\n        self.play(Rotate(t, PI/2), Transform(t, Circle()), run_time=3)"
  },
  {
    "text": "class WiggleExampleScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n        self.add(square)\n        self.play(Wiggle(square, scale_value=2, rotation_angle=0.1*PI, run_time=2))"
  },
  {
    "text": "from manim import *\n\nclass CircleTheorem(Scene):\n    def construct(self):\n        # Create a circle with a radius\n        circle = Circle(radius=2)\n        radius = Line(start=ORIGIN, end=circle.get_top())\n        radius_label = Tex(\"r\").next_to(radius, LEFT)\n\n        self.play(Create(circle))\n        self.play(Create(radius), Write(radius_label))\n        self.wait(1)\n\n        # Explain the area of a circle\n        area_explanation = Tex(\"The area of a circle is given by the formula \\\\\\\\\",\n                               r\"Area = \\pi r^2\")\n        area_explanation.to_edge(UP)\n\n        self.play(Write(area_explanation))\n        self.wait(2)\n\n        # Create the formula for the area of the circle\n        area_formula = Tex(r\"A = \\pi r^2\").to_edge(DOWN)\n        self.play(Transform(area_explanation, area_formula))\n        self.wait(2)\n\n        # Show circumference of a circle\n        circle_circumference = Circle(radius=2, color=YELLOW)\n        dot = Dot(circle_circumference.point_at_angle(0))\n        circumference_label = Tex(\"Circumference = 2\\\\pi r\").move_to(circle.get_bottom() + DOWN*0.5)\n\n        self.play(Create(dot))\n        self.play(MoveAlongPath(dot, circle_circumference), rate_func=linear, run_time=2)\n        self.play(dot.animate.move_to(circle.get_right()), FadeOut(dot))\n        self.play(Write(circumference_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass FeedForwardNetworkScene(Scene):\n    def construct(self):\n        # Define the neural network structure\n        nn = NeuralNetwork([\n                FeedForwardLayer(4),\n                FeedForwardLayer(6),\n                FeedForwardLayer(4),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.5,\n        )\n\n        # Center the neural network\n        nn.move_to(ORIGIN)\n\n        # Create the neural network on the scene\n        self.play(Create(nn))\n\n        # Make a forward pass animation through the layers\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#edf2f7\"\nTEXT_COLOR = \"#2b2d42\"\nLIGHT_GREEN_COLOR = \"#8d99ae\"\nLIGHT_YELLOW_COLOR = \"#f2cc8f\"\nLIGHT_RED_COLOR = \"#ef233c\"\nLIGHT_BLUE_COLOR = \"#4a7c59\"\nNAVY_COLOR = \"#3d405b\"\n\nclass PrimeNumberSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Prime Number Spiral\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.5)\n        title.shift(3 * UP)\n\n        dots = VGroup()\n        primes = set()\n        n = 400  # Total number of dots to be checked and displayed\n\n        for i in range(1, n + 1):\n            angle = i * 0.2  # Angle for the polar position\n            radius = 0.1 * i  # Radius for the polar position\n            dot = Dot(point=complex_to_R3(np.exp(1j * angle) * radius), color=LIGHT_GREEN_COLOR)\n            dots.add(dot)\n            for j in range(2, int(i**0.5) + 1):\n                if i % j == 0:\n                    dot.set_color(LIGHT_YELLOW_COLOR)\n                    break\n            else:\n                dot.set_color(LIGHT_RED_COLOR)\n                primes.add(i)\n\n        number_line = NumberLine(\n            x_range=[-1, 50, 2],\n            length=10,\n            color=NAVY_COLOR,\n            include_numbers=True,\n            label_direction=DOWN,\n        )\n\n        self.add(title)\n        self.play(ShowCreation(number_line), run_time=2)\n        self.play(Succession(*[GrowFromCenter(dot) for dot in dots], run_time=5))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n# Colors\nPRIMARY_COLOR = \"#ff0000\"\nSECONDARY_COLOR = \"#0000ff\"\nTERTIARY_COLOR = \"#00ff00\"\nACCENT_COLOR = \"#ff00ff\"\n\n# Configuration\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.22\n\ndef Multiplication(factor1, factor2):\n    result = factor1 * factor2\n\n    gp = VGroup(\n        MathTex(str(factor1), color=PRIMARY_COLOR),\n        MathTex(\"\\\\times\", color=ACCENT_COLOR),\n        MathTex(str(factor2), color=SECONDARY_COLOR),\n        MathTex(\"=\", color=ACCENT_COLOR),\n        MathTex(str(result), color=TERTIARY_COLOR)\n    ).arrange(RIGHT)\n\n    return gp\n\nclass FiveMultiplication(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ffffff\"\n\n        times_one = Multiplication(5, 1)\n        times_two = Multiplication(5, 2)\n        times_three = Multiplication(5, 3)\n        times_four = Multiplication(5, 4)\n        times_five = Multiplication(5, 5)\n        multiplications = VGroup(\n            times_one,\n            times_two,\n            times_three,\n            times_four,\n            times_five\n        ).arrange(DOWN, buff=0.5)\n\n        rectangle_one = SurroundingRectangle(times_one, color=PRIMARY_COLOR)\n        rectangle_five = SurroundingRectangle(times_five, color=SECONDARY_COLOR)\n\n        self.play(LaggedStart(\n            *[FadeIn(multiplication) for multiplication in multiplications],\n            lag_ratio=0.2,\n            run_time=2\n        ))\n        self.wait(1)\n        self.play(Create(rectangle_one), Create(rectangle_five))\n        self.wait(2)\n        self.play(\n            FadeOut(rectangle_one),\n            FadeOut(rectangle_five),\n            *[FadeOut(multiplication) for multiplication in multiplications],\n            run_time=1\n        )\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_YELLOW_COLOR = \"#f7e03c\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef ThoughtBubble(**kwargs):\n    bubble = SVGMobject(\"./assets/thought.svg\", **kwargs)\n    bubble.set(height=2)\n    return bubble\n\nclass KnowledgeQuestion(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        teacher = ImageMobject(\"./assets/teacher.png\")\n        teacher.scale(0.5)\n        teacher.to_edge(LEFT)\n        \n        thought_bubble = ThoughtBubble(fill_opacity=0.8, fill_color=LIGHT_BLUE_COLOR)\n        thought_bubble.next_to(teacher, UP+RIGHT, buff=0.5)\n        thought_bubble.shift(2.5 * UP)\n\n        knowledge_text_1 = Text(\"What is the\", color=WHITE)\n        knowledge_text_2 = Text(\"Pythagorean\", color=WHITE)\n        knowledge_text_3 = Text(\"Theorem?\", color=WHITE)\n        knowledge_text_group = VGroup(knowledge_text_1, knowledge_text_2, knowledge_text_3)\n        knowledge_text_group.scale(0.6)\n        knowledge_text_group.arrange(DOWN, center=False, aligned_edge=LEFT)\n        knowledge_text_group.move_to(thought_bubble.get_center_of_mass())\n\n        self.play(\n            FadeIn(teacher), \n            FadeIn(thought_bubble), \n            run_time=0.5\n        )\n        self.play(\n            Write(knowledge_text_1),\n            Write(knowledge_text_2),\n            Write(knowledge_text_3),\n            run_time=2\n        )\n        self.wait(1)\n\n        answer_text_1 = Text(\"In a right triange,\", color=WHITE)\n        answer_text_2 = Text(\"the square of the hypotenuse\", color=WHITE)\n        answer_text_3 = Text(\"is equal to the sum of\", color=WHITE)\n        answer_text_4 = Text(\"the squares of the other two sides.\", color=WHITE)\n        answer_text_group = VGroup(answer_text_1, answer_text_2, answer_text_3, answer_text_4)\n        answer_text_group.scale(0.5)\n        answer_text_group.arrange(DOWN, center=False, aligned_edge=LEFT)\n        answer_text_group.next_to(thought_bubble.get_bottom(), DOWN)\n\n        self.play(\n            FadeOut(knowledge_text_group),\n            FadeIn(answer_text_group),\n            run_time=1.5\n        )\n        self.wait(2)\n        \n        self.play(\n            FadeOut(answer_text_group),\n            FadeOut(thought_bubble),\n            FadeOut(teacher),\n            run_time=0.5\n        )\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_width = 14.22\nconfig.frame_height = 25.4\n\nclass AddingFractions(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{4}\", color=BLACK).scale(2),\n            MathTex(r\"+\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{1}{4}\", color=BLACK).scale(2),\n            MathTex(r\"=\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=BLACK).scale(2)\n        ).arrange(RIGHT, buff=0.5)\n\n        brace_top = Brace(fractions[:2], UP, color=BLACK)\n        brace_bottom = Brace(fractions[:2], DOWN, color=BLACK)\n        text_top = brace_top.get_tex(r\"\\text{Same Denominator}\", color=BLACK)\n        text_bottom = brace_bottom.get_tex(r\"\\text{Add Numerators}\", color=BLACK)\n\n        self.play(Write(fractions))\n        self.wait(1)\n        self.play(\n            GrowFromCenter(brace_top),\n            FadeIn(text_top, shift=DOWN)\n        )\n        self.wait(1)\n        self.play(\n            GrowFromCenter(brace_bottom),\n            FadeIn(text_bottom, shift=UP)\n        )\n        self.wait(1)\n        self.play(\n            ReplacementTransform(fractions[:3].copy(), fractions[3:])\n        )\n        self.wait(2)\n        self.play(FadeOut(VGroup(*self.mobjects)))"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            Convolutional2DLayer(1, 16, 5, filter_spacing=0.4),\n            Convolutional2DLayer(16, 32, 3, filter_spacing=0.4),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(10),\n        ],\n        layer_spacing=0.3,\n        )\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
  },
  {
    "text": "class SimpleGraphScene(Scene):\n\n    def construct(self):\n        axes = Axes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # create a graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # display graph\n        self.add(axes, graph)"
  },
  {
    "text": "from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        text = Text(\"GrowFromPoint - Example\")\n        self.add(text)\n\n        # First square growing from a point at the bottom\n        square1 = Square()\n        self.play(GrowFromPoint(square1, point=DOWN*3))\n\n        # Update text and show second square growing from a specific point\n        self.play(Transform(text, Text(\"Next square grows from a point\").shift(UP*2.5)))\n        square2 = Square()\n        specific_point = RIGHT*3 + UP*2\n        self.play(GrowFromPoint(square2, point=specific_point))\n\n        # Cleanup\n        self.remove(square1, square2)"
  },
  {
    "text": "from manim import *\n\nclass SolarSystem(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=1, color=YELLOW)\n        earth = Sphere(radius=0.3, color=BLUE).move_to(RIGHT * 5)\n        moon = Sphere(radius=0.1, color=GREY_B).move_to(earth.get_center() + RIGHT)\n\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.play(FadeIn(sun), FadeIn(earth), FadeIn(moon))\n        self.wait(1)\n\n        earth_orbit = Circle(radius=5, color=WHITE)\n        moon_orbit = Circle(radius=1, color=LIGHT_GREY).move_to(earth.get_center())\n        self.play(ShowCreation(earth_orbit), ShowCreation(moon_orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), rate_func=linear, run_time=8, rate=PI/5),\n                  Rotating(moon, about_point=earth.get_center(), rate_func=linear, run_time=2, rate=PI))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(8)\n        self.stop_ambient_camera_rotation()\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#ffffff\"\nHIGHLIGHT_COLOR = \"#ff0000\"\nGRAPH_COLOR = \"#00ff00\"\n\nclass MonthlyExpenseGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Monthly Expenses\", color=TEXT_COLOR)\n        axes = NumberPlane(\n            x_range=[0, 6, 1],\n            y_range=[0, 1000, 250],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": TEXT_COLOR},\n            background_line_style={\n                \"stroke_color\": TEXT_COLOR,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.5\n            }\n        )\n        axes.add_coordinates()\n        title.next_to(axes, UP)\n\n        points_data = [\n            (1, 300),\n            (2, 500),\n            (3, 450),\n            (4, 650),\n            (5, 400),\n        ]\n\n        lines = VGroup()\n        dots = VGroup()\n        for point in points_data:\n            dot = Dot(color=HIGHLIGHT_COLOR).move_to(axes.c2p(*point))\n            dots.add(dot)\n            if lines:\n                line = Line(start=lines[-1].get_end(), end=dot.get_center(), color=GRAPH_COLOR)\n                lines.add(line)\n\n        self.play(Create(axes), Write(title))\n        self.play(LaggedStart(\n            *[Create(dot) for dot in dots], lag_ratio=0.5),\n            *[Create(line) for line in lines],\n            run_time=3)\n        self.wait(1)\n        self.play(FadeOut(VGroup(axes, title, dots, lines)))"
  },
  {
    "text": "from manim import *\n\nclass FallingObjects(Scene):\n    def construct(self):\n        balls = VGroup(*[Circle(radius=0.2, color=random_color()) for _ in range(5)])\n        balls.arrange(RIGHT, buff=0.5)\n        balls.move_to(UP * 2)\n        \n        floor = Line(LEFT, RIGHT).scale(2).next_to(DOWN * 2, DOWN)\n        \n        self.add(balls, floor)\n        for ball in balls:\n            self.play(FallDown(ball, floor))\n        \n        self.wait(10)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\n\nclass SalesBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Quarterly Sales\", color=TEXT_COLOR)\n        bars = BarChart(\n            [10, 6, 9, 5], \n            max_value=10,\n            bar_colors=['#5e81ac', '#bf616a', '#a3be8c', '#ebcb8b'],\n            bar_names=['Q1', 'Q2', 'Q3', 'Q4'],\n            bar_label_scale_val=0.7,\n            label_y_axis=True,\n            y_axis_config={'include_tip': False},\n            x_axis_config={'include_tip': False}\n        )\n        title.to_edge(UP)\n        bars.to_edge(DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(bars, lag_ratio=0.2), run_time=2)\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_GREEN_COLOR = \"#2ecc71\"\nLIGHT_YELLOW_COLOR = \"#f1c40f\"\nLIGHT_BLUE_COLOR = \"#3498db\"\nLIGHT_PURPLE_COLOR = \"#9b59b6\"\n\ndef ease_in_quad(t):\n    return rate_functions.smooth(t, inflection=10.0)\n\ndef GeometricSquare(size, color):\n    rect = Square(side_length=size, color=color, fill_opacity=0.5)\n    text = Tex(str(size), color=color)\n    text.scale(0.5 + 0.5 * min(1, size))\n    text.move_to(rect.get_center())\n\n    return Group(rect, text)\n\nclass PowersOfTwoScene(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Powers of Two\", color=LIGHT_GREEN_COLOR)\n        title.scale(2)\n        title.to_edge(UP)\n\n        subtitle = Tex(\"2, 4, 8, 16, 32, ...\", color=TEXT_COLOR).scale(1.5)\n        subtitle.next_to(title, DOWN)\n\n        self.add(title)\n        self.play(FadeInFrom(subtitle, direction=DOWN), run_time=1)\n        self.wait(1)\n\n        squares = VGroup()\n        previous_square = None\n        for i, x in enumerate([2 ** (i + 1) for i in range(5)]):\n            square = GeometricSquare(size=x, color=LIGHT_BLUE_COLOR if i % 2 == 0 else LIGHT_PURPLE_COLOR)\n            square.move_to(3 * RIGHT + 2 * DOWN if previous_square is None else previous_square.get_center() + 1.5 * RIGHT)\n\n            if previous_square:\n                self.play(Transform(previous_square, square), run_time=0.75)\n            else:\n                self.play(FadeIn(square))\n\n            previous_square = square\n            squares.add(square)\n            self.wait(0.5)\n\n        self.play(squares.animate.arrange(RIGHT, buff=0.2).scale(0.6).move_to(ORIGIN))\n        self.wait(1)\n\n        for square in squares:\n            self.play(square.animate.set_color(LIGHT_YELLOW_COLOR), run_time=0.5)\n            self.wait(0.25)\n\n        self.play(FadeOut(VGroup(*self.mobjects)))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass CircumscribeExample(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n\n        text_inside = Text(\"Inside\").move_to(square.get_center())\n        self.add(text_inside)\n\n        self.play(Circumscribe(square, color=BLUE))\n        self.wait(0.5)\n\n        text_outside = Text(\"Outside\").shift(DOWN*2)\n        self.add(text_outside)\n\n        self.play(Circumscribe(text_outside, FadeOut, shape=Rectangle, fade_out=True, color=RED))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1], axis_config={\"color\": GREEN})\n        func_graph = axes.plot(lambda x: x**2, color=BLUE)\n        derivative_graph = axes.plot_derivative_graph(func_graph, color=ORANGE)\n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        explanation = MathTex(r\"\\text{The derivative of }\", \"x^2\", r\"\\text{ is }\", \"2x\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        self.play(Create(derivative_graph))\n        self.wait(1)\n\n        point = axes.input_to_graph_point(1, func_graph)\n        slope = axes.get_tangent_line(1, func_graph, length=3, color=PURPLE)\n        dot = Dot(point, color=RED)\n\n        self.play(Create(slope), FadeIn(dot))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass MagneticFieldLines(Scene):\n    def construct(self):\n        magnet = Rectangle(color=BLUE)\n        north_pole = Tex(\"N\").next_to(magnet, UP)\n        south_pole = Tex(\"S\").next_to(magnet, DOWN)\n\n        self.play(Create(magnet), Write(north_pole), Write(south_pole))\n        self.wait(1)\n\n        field_lines = StreamLines(\n            lambda p: np.array([-p[1], p[0], 0]) / (p[0]**2 + p[1]**2),\n            color=BLUE,\n            max_anchors_per_line=30,\n            padding=1\n        )\n\n        self.play(Create(field_lines), run_time=3)\n        self.wait(2)"
  },
  {
    "text": "class ShapesAndColors(Scene):\n    def construct(self):\n        # Create a square, a circle, and a triangle\n        square = Square(side_length=1, color=PURPLE)\n        circle = Circle(radius=1, color=ORANGE)\n        triangle = Triangle(color=TEAL)\n\n        # Position the shapes in a group\n        shape_group = VGroup(square, circle, triangle)\n        shape_group.arrange(RIGHT, buff=1)\n        shape_group.to_edge(LEFT)\n\n        # Add the group of shapes to the scene\n        self.add(shape_group)\n\n        # Create rectangles of various colors\n        rectangles = VGroup(*[Rectangle(width=0.4, height=1, color=random_color()) for _ in range(5)])\n        rectangles.arrange(RIGHT, buff=0.2)\n        rectangles.next_to(shape_group, DOWN, buff=1)\n\n        # Add the rectangles to the scene\n        self.add(rectangles)\n\n        # Create pentagons in a grid\n        pentagons = VGroup(*[RegularPolygon(n=5, color=random_color(), fill_opacity=0.5).scale(0.3) for _ in range(15)])\n        pentagons.arrange_in_grid(3, 5, buff=0.25)\n        pentagons.next_to(rectangles, DOWN, buff=1)\n\n        # Add the pentagons to the scene\n        self.add(pentagons)"
  },
  {
    "text": "from manim import *\n\nclass MultiplyMatrix(VMobject):\n    def __init__(self, matrix_1, matrix_2, element_time=1, run_time=3, **kwargs):\n        super().__init__(**kwargs)\n        self.matrix_1 = matrix_1\n        self.matrix_2 = matrix_2\n        self.element_time = element_time\n        self.run_time = run_time\n        self.result_matrix = self.get_result_matrix()\n\n    def get_result_matrix(self):\n        return np.dot(self.matrix_1, self.matrix_2)\n\n    def animate_multiplication(self):\n        animations = []\n        m1_rows, m1_cols = self.matrix_1.shape\n        m2_cols = self.matrix_2.shape[1]\n        for i in range(m1_rows):\n            for j in range(m2_cols):\n                dot_product_anim = []\n                for k in range(m1_cols):\n                    elem_1 = DecimalNumber(self.matrix_1[i, k]).move_to(i * UP + k * LEFT)\n                    elem_2 = DecimalNumber(self.matrix_2[k, j]).move_to(k * UP + j * RIGHT)\n                    product = DecimalNumber(self.matrix_1[i, k] * self.matrix_2[k, j]).move_to(i * UP + j * RIGHT)\n                    dot_product_anim += [\n                        TransformFromCopy(elem_1, product),\n                        TransformFromCopy(elem_2, product),\n                        FadeOut(product)\n                    ]\n                animations.append(AnimationGroup(*dot_product_anim, run_time=self.element_time))\n        return Succession(*animations, lag_ratio=1)\n\nclass MatrixScene(Scene):\n    def construct(self):\n        matrix_1 = np.array([[1, 2], [3, 4]])\n        matrix_2 = np.array([[2, 0], [1, 2]])\n\n        matrix_mobject_1 = Matrix(matrix_1).to_edge(UP)\n        matrix_mobject_2 = Matrix(matrix_2).to_edge(DOWN)\n\n        self.play(Write(matrix_mobject_1), Write(matrix_mobject_2))\n\n        multiply_matrix = MultiplyMatrix(matrix_1, matrix_2)\n        self.play(multiply_matrix.animate_multiplication())\n\n        result_matrix_mobject = Matrix(multiply_matrix.result_matrix).move_to(ORIGIN)\n        self.play(TransformFromCopy(matrix_mobject_1, result_matrix_mobject))\n        self.play(TransformFromCopy(matrix_mobject_2, result_matrix_mobject))\n\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        initial_text = Text(\"Wave Propagation\")\n        self.play(Write(initial_text))\n        self.wait(1)\n        self.play(ApplyWave(initial_text))\n        self.wait(1)\n        transformed_text = Text(\"Wave Effect\").shift(DOWN*2)\n        self.play(Transform(initial_text, transformed_text))\n        self.wait(1)\n        self.play(ApplyWave(transformed_text, direction=UP))\n        self.wait(1)\n        self.remove(transformed_text)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#E0E0E0\"\nTEXT_COLOR = \"#383838\"\nLIGHT_BLUE_COLOR = \"#ADD8E6\"\nDARK_BLUE_COLOR = \"#00008B\"\n\nconfig.frame_width = 14\nconfig.frame_height = 8\n\n\ndef AppleSlice():\n    return VGroup(\n        Circle(1, color=LIGHT_BLUE_COLOR, fill_opacity=1, stroke_color=DARK_BLUE_COLOR),\n        Line(UP, DOWN, color=DARK_BLUE_COLOR),\n        Line(LEFT, RIGHT, color=DARK_BLUE_COLOR),\n    )\n\n\nclass ApplePie(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Apple Pie Slices\", color=TEXT_COLOR)\n        title.scale(1.5)\n        pie_slice = AppleSlice()\n        pie_slices = VGroup(*[AppleSlice() for _ in range(8)])\n        pie_slices.arrange_in_grid(buff=0.2, rows=2)\n        Group(title, pie_slices).arrange(DOWN, buff=1)\n\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromCenter(slice) for slice in pie_slices], lag_ratio=0.3, run_time=2))\n        self.wait(1)\n\n        # Animate some slices as if taking them out\n        taken_slices = [pie_slices[2], pie_slices[5]]\n        for slice in taken_slices:\n            self.play(slice.animate.shift(3 * UP + 2 * RIGHT), run_time=0.5)\n        self.wait(0.5)\n\n        # Move back the taken slices\n        for slice in taken_slices:\n            self.play(slice.animate.shift(3 * DOWN + 2 * LEFT), run_time=0.5)\n        self.wait(1)\n\n        # Scale down everything and fade out\n        self.play(\n            Group(*self.mobjects).animate.scale(0.5),\n            FadeOut(Group(*self.mobjects)),\n            run_time=1\n        )"
  },
  {
    "text": "from manim import *\n\nclass WavePath(VGroup):\n    def __init__(self, wave_freq, amplitude, start_point, end_point, color=BLUE):\n        super().__init__()\n        \n        self.wave_freq = wave_freq\n        self.amplitude = amplitude\n        self.start_point = start_point\n        self.end_point = end_point\n        self.color = color\n\n        self.path = VMobject(color=self.color)\n        self.path.set_points_as_corners([self.start_point, self.start_point])\n\n        self.add(self.path)\n        self.time = 0\n\n    def update_wave(self, dt):\n        self.time += dt\n        prev_point = self.path.points[-1]\n        new_point = prev_point + RIGHT * dt\n        new_point[1] = self.amplitude * np.sin(self.wave_freq * self.time) + self.start_point[1]\n        \n        if new_point[0] > self.end_point[0]:\n            self.path.set_points_as_corners([*self.path.points, self.end_point])\n            self.path.clear_updaters()\n        else:\n            self.path.set_points_as_corners([*self.path.points, new_point])\n\n    def start_wave(self):\n        self.path.add_updater(self.update_wave)\n\n\nclass WaveScene(Scene):\n    def construct(self):\n        start_point = LEFT * 4\n        end_point = RIGHT * 4\n        wave = WavePath(\n            wave_freq=2 * PI,\n            amplitude=1,\n            start_point=start_point,\n            end_point=end_point\n        )\n        self.add(wave)\n        wave.start_wave()\n\n        self.play(ShowCreation(wave.path), run_time=4)\n        self.wait()"
  },
  {
    "text": "from manim import *\nimport numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import ImageLayer, Convolutional2DLayer, FeedForwardLayer, MaxPoolingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Load an example image\n        image_path = \"path/to/your/image.jpg\"  # Replace with the path to your image file\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Define the neural network's structure\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=2,\n                    feature_map_size=5,\n                    kernel_size=(3, 3),\n                    stride=1,\n                    padding=0\n                ),\n                MaxPoolingLayer(\n                    pool_size=(2, 2),\n                    stride=2\n                ),\n                FeedForwardLayer(5),\n                FeedForwardLayer(2),\n            ],\n            layer_spacing=0.2,\n        )\n\n        # Center the neural network\n        self.add(nn)\n        nn.move_to(ORIGIN)\n\n        # Animate the forward pass\n        forward_pass_animation = nn.make_forward_pass_animation()\n        self.play(forward_pass_animation, run_time=15)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        \n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{4}{8}\", color=BLACK).scale(2)\n        ).arrange(RIGHT, buff=1)\n        \n        arrows = VGroup(\n            Arrow(fractions[0].get_right(), fractions[1].get_left(), buff=0.1, color=BLUE),\n            Arrow(fractions[1].get_right(), fractions[2].get_left(), buff=0.1, color=BLUE)\n        )\n        \n        times_two = Tex(r\"\\times 2\", color=BLUE).next_to(arrows[0], UP)\n        times_four = Tex(r\"\\times 4\", color=BLUE).next_to(arrows[1], UP)\n        \n        self.play(Write(fractions[0]), run_time=0.5)\n        self.play(\n            GrowArrow(arrows[0]),\n            Write(times_two),\n            run_time=0.7\n        )\n        self.play(Write(fractions[1]), run_time=0.5)\n        self.play(\n            GrowArrow(arrows[1]),\n            Write(times_four),\n            run_time=0.7\n        )\n        self.play(Write(fractions[2]), run_time=0.5)\n        self.wait(2)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=1)"
  },
  {
    "text": "from manim import *\n\n\nclass PieChartExample(Scene):\n    def construct(self):\n        pie_chart = PieChart(\n            values=[30, 45, 10, 15],\n            radius=2,\n            colors=[RED, BLUE, GREEN, YELLOW],\n            labels=[\"Product A\", \"Product B\", \"Product C\", \"Product D\"],\n            label_colors=[WHITE, WHITE, WHITE, WHITE],\n            label_radius=1.5,\n            slice_colors=[TEAL_E,TEAL_D,TEAL_C,TEAL_B],\n            start_angle=90,\n        )\n\n        self.add(pie_chart)"
  },
  {
    "text": "from manim import *\n\nclass SecondExample(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.7)\n        yellow_hexagon = RegularPolygon(6, color=YELLOW, fill_opacity=0.6)\n        yellow_hexagon.next_to(red_triangle, LEFT, buff=0.5)\n        self.play(GrowFromCenter(red_triangle))\n        self.play(FadeIn(yellow_hexagon))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n# Define colors\nGREEN_SCREEN_COLOR = \"#00FF00\"\nDARK_YELLOW_COLOR = \"#d7c000\"\nDARK_GREEN_COLOR = \"#008000\"\nLIGHT_BROWN_COLOR = \"#996633\"\nDARK_BROWN_COLOR = \"#662400\"\n\n# Geometry constants\nSANDWICH_HEIGHT = 0.3\nSANDWICH_LENGTH = 3\nBREAD_HEIGHT = 0.5\n\ndef Bread():\n    return Rectangle(\n        height=BREAD_HEIGHT, \n        width=SANDWICH_LENGTH, \n        color=LIGHT_BROWN_COLOR, \n        fill_opacity=1\n    )\n\ndef Lettuce():\n    return Ellipse(\n        width=SANDWICH_LENGTH + 0.5, \n        height=SANDWICH_HEIGHT, \n        color=DARK_GREEN_COLOR, \n        fill_opacity=1\n    ).shift(SANDWICH_HEIGHT * DOWN)\n\ndef Cheese():\n    return Rectangle(\n        height=SANDWICH_HEIGHT, \n        width=SANDWICH_LENGTH + 0.2, \n        color=DARK_YELLOW_COLOR, \n        fill_opacity=1\n    ).shift(SANDWICH_HEIGHT * 0.5 * DOWN)\n\ndef Sandwich():\n    return VGroup(\n        Bread().shift(SANDWICH_HEIGHT * 0.5 * UP),\n        Lettuce(),\n        Cheese(),\n        Bread().shift(SANDWICH_HEIGHT * 0.5 * DOWN)\n    )\n\nclass SandwichScene(Scene):\n    def construct(self):\n        self.camera.background_color = GREEN_SCREEN_COLOR\n        \n        sandwich = Sandwich()\n        sandwich_group = VGroup(*[sandwich.copy() for _ in range(4)])\n        sandwich_group.arrange(DOWN, buff=0.5)\n\n        self.play(\n            AnimationGroup(\n                *[FadeIn(sandwich, shift=UP) for sandwich in sandwich_group],\n                lag_ratio=0.1\n            ),\n            run_time=2\n        )\n\n        self.wait(1)\n\n        bite_marks = []\n        for i, sandwich in enumerate(sandwich_group):\n            bite = Arc(\n                radius=0.5, \n                start_angle=PI, \n                angle=-3*PI/4,\n                color=DARK_BROWN_COLOR\n            ).shift(SANDWICH_LENGTH / 2 * LEFT + (i - 1.5) * BREAD_HEIGHT * UP)\n            self.play(DrawBorderThenFill(bite))\n            bite_marks.append(bite)\n\n        self.wait(1)\n\n        self.play(\n            *[sandwich.animate.shift(LEFT * 3) for sandwich in sandwich_group],\n            *[bite_mark.animate.shift(LEFT * 3) for bite_mark in bite_marks],\n            run_time=1.5\n        )\n\n        self.wait(0.5)\n\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=1\n        )\n\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_TEAL_COLOR = \"#5adbad\"\nLIGHT_PINK_COLOR = \"#f5a3c7\"\nLIGHT_BROWN_COLOR = \"#cdab7e\"\nDARK_TEAL_COLOR = \"#3c787e\"\nDARK_PINK_COLOR = \"#8c4351\"\nDARK_BROWN_COLOR = \"#5a4634\"\n\nclass SimplePieChart(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        data = [35, 25, 40]\n        colors = [LIGHT_TEAL_COLOR, LIGHT_PINK_COLOR, LIGHT_BROWN_COLOR]\n        legend_labels = [\"Teal Product\", \"Pink Product\", \"Brown Product\"]\n        pie_chart = PieChart(\n            data,\n            radius=2,\n            colors=colors,\n            start_angle=PI/2,\n            stroke_width=0,\n            slice_colors=colors\n        )\n\n        # Create legends\n        legends = VGroup()\n        for i, label in enumerate(legend_labels):\n            legend = Legend(\n                color=colors[i],\n                label=label,\n                label_constructor=Text,\n                label_scale=0.6,\n                size=0.2\n            )\n            legends.add(legend)\n        legends.arrange(DOWN, aligned_edge=LEFT, buff=0.5)\n        legends.move_to(RIGHT * 4)\n\n        # Adding percentage texts inside the pie chart\n        for slice_, value in zip(pie_chart.slice, data):\n            percentage = (value / sum(data)) * 100\n            slice_.add(Text(f\"{percentage:.1f}%\", font_size=36, color=BACKGROUND_COLOR).move_to(slice_.get_center()))\n\n        # Initial animations\n        self.play(FadeIn(pie_chart), FadeIn(legends))\n        self.wait(1)\n\n        # Highlight each section\n        for i in range(len(data)):\n            slice_ = pie_chart.slice[i]\n            legends[i].set_color(DARK_TEAL_COLOR if i == 0 else DARK_PINK_COLOR if i == 1 else DARK_BROWN_COLOR)\n            self.play(slice_.animate.scale(1.1))\n            self.wait(0.5)\n            self.play(slice_.animate.scale(1/1.1))\n            self.wait(0.5)\n            legends[i].set_color(colors[i])\n\n        self.wait(2)\n\n        # Remove pie chart and legends\n        self.play(FadeOut(pie_chart), FadeOut(legends))\n        self.wait(0.4)"
  },
  {
    "text": "class WaveLikeMotionScene(Scene):\n    def construct(self):\n        def wave_motion(mobject, alpha):\n            wave_height = 2\n            wave_length = 5\n            speed = 3\n            \n            x = mobject.get_center()[0]\n            y = wave_height * np.sin(wave_length * alpha + speed * x)\n            mobject.move_to(mobject.get_center() + y * UP)\n        \n        square = Square(color=BLUE)\n        self.add(square)\n        self.play(UpdateFromAlphaFunc(square, wave_motion, run_time=2))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.starting_dots = VGroup(\n            *[Dot(radius=self.dot_radius) for _ in range(self.dot_number)]\n        )\n        self.create_starting_dots()\n\n    def begin(self):\n        self.mobject.set_opacity(0)\n        for dot in self.starting_dots:\n            dot.move_to(dot.initial_position)\n        self.mobject.add(self.starting_dots)\n        super().begin()\n\n    def create_starting_dots(self):\n        mobject_center = self.mobject.get_center()\n        for dot in self.starting_dots:\n            dot.shift_vector = np.random.uniform(-4, 4, 3)\n            dot.initial_position = mobject_center + dot.shift_vector\n            dot.set_opacity(0)\n\n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.starting_dots.set_opacity(2 * alpha)\n            for dot in self.starting_dots:\n                dot.move_to(dot.initial_position + (0.5 - alpha) * dot.shift_vector)\n        else:\n            self.starting_dots.set_opacity(2 * (1 - alpha))\n            self.mobject.set_opacity(2 * (alpha - 0.5), family=False)\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.starting_dots)\n\nclass CustomGatherAnimationExample(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1).scale(2)\n        self.add(square)\n        self.wait()\n        self.play(Gather(square, dot_number=200, run_time=4))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 5, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: 0.5 * x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='y=0.5x^2')\n\n        # Create area under graph\n        graph_area = axes.get_area(graph, x_range=[0, 2], color=YELLOW, opacity=0.5)\n\n        # Display graph and area\n        self.play(Create(axes), Write(graph), FadeIn(graph_label))\n        self.play(FadeIn(graph_area))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        text = Text(\"Inscribe\").shift(DOWN*2.5)\n        self.add(text)\n        self.play(Transform(text, Text(\"Inscribe\").shift(UP*2.5)), run_time=0.5)\n        another_text = Text(\"Watch Here\")\n        self.add(another_text)\n        self.play(Indicate(another_text))\n        self.play(Indicate(another_text, color=RED))\n        self.remove(another_text)"
  },
  {
    "text": "from manim import *\n\nclass EulerianPath(Scene):\n    def construct(self):\n        vertices = 6\n        edges = [\n            (0, 1), (0, 2), (1, 2), (2, 3), (3, 2), \n            (3, 4), (4, 3), (4, 5), (5, 4), (1, 5),\n        ]\n        dots = [Dot().move_to(UP + ii * RIGHT) for ii in range(vertices)]\n        for ind, dot in enumerate(dots):\n            dot.move_to(\n                3 * (np.cos(ind / vertices * TAU) * RIGHT +\n                     np.sin(ind / vertices * TAU) * UP)\n            )\n        lines = VGroup()\n        for u, v in edges:\n            lines.add(Line(dots[u].get_center(), dots[v].get_center()))\n        \n        vgroup = VGroup(lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(LaggedStart(*[FadeIn(dot) for dot in dots], lag_ratio=0.5))\n        self.wait(0.5)\n        self.play(LaggedStart(*[ShowCreation(line) for line in lines], lag_ratio=0.5))\n        self.wait(1)\n\n        path_ind = [0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 5]\n        path_lines = []\n        for k in range(len(path_ind) - 1):\n            self.play(dots[path_ind[k]].set_color, BLUE, run_time=0.5)\n            new_line = Line(\n                dots[path_ind[k]].get_center(),\n                dots[path_ind[k + 1]].get_center(),\n                color=BLUE,\n                stroke_width=5,\n            )\n            path_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.5)\n        self.play(dots[path_ind[-1]].set_color, BLUE, run_time=0.5)\n        self.wait(1)\n\n        label = Tex(\"Eulerian Path\", color=BLUE).to_edge(UP)\n        self.play(Write(label))\n\n        graph_copy = VGroup(*dots, *path_lines).copy()\n        self.play(\n            ApplyFunction(\n                lambda m: m.scale(0.5).next_to(label, DOWN),\n                graph_copy\n            )\n        )\n        \n        self.wait(1)\n        self.play(FadeOut(VGroup(*self.mobjects)))"
  },
  {
    "text": "class FadeInAndOut(Scene):_x000D_\n    def construct(self):_x000D_\n        red_square = Square(color=RED)_x000D_\n        square_label = Text(\"This is a square\").next_to(red_square, DOWN)_x000D_\n_x000D_\n        self.add(red_square, square_label)_x000D_\n        self.wait(1)_x000D_\n        self.play(FadeIn(red_square), FadeIn(square_label))_x000D_\n        self.wait(1)_x000D_\n        self.play(FadeOut(red_square), FadeOut(square_label))_x000D_\n        self.wait(1)"
  },
  {
    "text": "class ShapesScene(Scene):\n    def construct(self):\n        red_rect = Rectangle(color=RED, fill_opacity=0.6, width=4, height=2)\n        orange_triangle = Polygon(ORIGIN, RIGHT, RIGHT+UP, color=ORANGE, fill_opacity=0.3)\n        orange_triangle.next_to(red_rect, UP)\n        self.play(FadeIn(red_rect), GrowFromPoint(orange_triangle, ORIGIN))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\n# Define colors for each part of the fraction bar graph\nBACKGROUND_COLOR = \"#ffffff\"\nBAR_COLOR = \"#3e7aab\"\nLABEL_COLOR = \"#333333\"\n\nclass FractionBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        # Create a list to hold the bars and labels.\n        bars = []\n        labels = []\n\n        # Define the maximum height of the bars and the total number of bars.\n        max_height = 5\n        num_bars = 6\n\n        # Create bars and corresponding labels.\n        for i in range(1, num_bars + 1):\n            height = max_height * (i / num_bars)\n            bar = Rectangle(width=0.8, height=height, color=BAR_COLOR, fill_opacity=1)\n            label = MathTex(f\"\\\\frac{{{i}}}{{{num_bars}}}\", color=LABEL_COLOR)\n            bars.append(bar)\n            labels.append(label)\n\n        # Position the bars and labels.\n        bar_group = VGroup(*bars)\n        label_group = VGroup(*labels)\n        bar_group.arrange(RIGHT, buff=1)\n        label_group.arrange(RIGHT, buff=1)\n\n        # Align the bars to the bottom and position the labels right below the bars.\n        for i in range(num_bars):\n            bars[i].align_to(bar_group, DOWN)\n            labels[i].next_to(bars[i], DOWN)\n\n        # Group the bars and the labels together.\n        graph_group = VGroup(bar_group, label_group)\n        graph_group.move_to(ORIGIN)\n\n        for bar, label in zip(bars, labels):\n            # Animate each bar and its corresponding label.\n            self.play(\n                GrowFromEdge(bar, DOWN),\n                Write(label),\n                run_time=0.5\n            )\n\n        # Show the entire graph for a brief moment\n        self.wait(1)\n\n        # Animate moving and scaling down of all the bars except the third one\n        self.play(\n            *[bar.animate.scale(0) for bar in bars if bar != bars[2]],\n            *[FadeOut(label) for label in labels if label != labels[2]],\n            run_time=0.8\n        )\n\n        # Highlight the selected bar and label\n        self.play(\n            bars[2].animate.set_color(YELLOW),\n            labels[2].animate.set_color(YELLOW),\n            run_time=0.5\n        )\n\n        # Animate shifting out all graph elements to the left\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=0.5\n        )\n\n        # Clear the scene\n        self.clear()"
  },
  {
    "text": "from manim import *\n\nclass Spiral3D(ThreeDScene):\n    def construct(self):\n        spiral = ParametricFunction(\n            lambda u: np.array([\n                1.5 * np.cos(u),\n                1.5 * np.sin(u),\n                u / (2 * PI)\n            ]),\n            t_range=[0, 4 * PI],\n            color=RED\n        )\n        axes = ThreeDAxes()\n\n        self.set_camera_orientation(phi=60 * DEGREES, theta=-45 * DEGREES)\n        self.play(Create(axes), Create(spiral))\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(6)"
  },
  {
    "text": "from manim import *\n\nclass RayTracing(Scene):\n    def construct(self):\n        # Setting up the mirror and the object\n        mirror_radius = 2\n        focal_length = mirror_radius / 2\n        object_height = 1\n        object_position = LEFT * 3\n        \n        concave_mirror = Arc(\n            radius=mirror_radius,\n            start_angle=-np.pi / 3,\n            angle=2 * np.pi / 3,\n            color=WHITE\n        )\n        principal_axis = Line(\n            start=LEFT * 5,\n            end=RIGHT * 5,\n            color=BLUE\n        )\n        object_arrow = Arrow(\n            start=object_position,\n            end=object_position + UP * object_height,\n            buff=0,\n            color=RED\n        )\n\n        focal_point = Dot(\n            point=RIGHT * focal_length,\n            color=YELLOW\n        )\n        center_curve = Dot(\n            point=RIGHT * mirror_radius,\n            color=YELLOW\n        )\n\n        # Add elements to the scene\n        self.add(concave_mirror, principal_axis, object_arrow, focal_point, center_curve)\n\n        # Calculate image position based on mirror equation\n        object_distance = abs(object_position[0])\n        image_distance = 1 / ((1 / focal_length) + (1 / object_distance))\n        image_height = (image_distance / object_distance) * object_height\n\n        # The position for the image_arrow is negative since in concave mirrors \n        # real images are formed on the same side as the object\n        image_position = RIGHT * (-image_distance)\n        image_arrow = Arrow(\n            start=image_position,\n            end=image_position - UP * image_height,\n            buff=0,\n            color=GREEN\n        )\n\n        # Add image to the scene\n        self.play(ShowCreation(image_arrow))\n        self.wait(1)\n\n        # Create light rays\n        # Ray 1 - Parallel to principal axis and then through focal point\n        ray1 = DashedLine(start=object_arrow.get_top(), end=RIGHT * 5, color=PURPLE)\n        ray1_reflect = DashedLine(\n            start=ray1.get_end(),\n            end=focal_point.get_center(),\n            color=PURPLE\n        )\n\n        # Ray 2 - Through the focal point and then parallel to the principal axis\n        ray2_start = object_arrow.get_top()\n        ray2_end = focal_point.get_center() + UP * (ray2_start[1] - focal_point.get_center()[1])\n\n        ray2 = DashedLine(start=ray2_start, end=ray2_end, color=ORANGE)\n        ray2_reflect = DashedLine(\n            start=ray2.get_end(),\n            end=ray2_start + RIGHT * (5 - abs(ray2_start[0])),\n            color=ORANGE\n        )\n\n        # Ray 3 - Through center of curvature which reflects back on same path\n        ray3 = DashedLine(start=object_arrow.get_top(), end=center_curve.get_center(), color=TEAL)\n        ray3_reflect = DashedLine(start=ray3.get_end(), end=ray3.get_start(), color=TEAL)\n\n        # Add light rays to the scene\n        self.play(ShowCreation(ray1), ShowCreation(ray1_reflect))\n        self.play(ShowCreation(ray2), ShowCreation(ray2_reflect))\n        self.play(ShowCreation(ray3), ShowCreation(ray3_reflect))\n\n        self.wait(2)\n\n        self.play(FadeOut(ray1), FadeOut(ray1_reflect),\n                  FadeOut(ray2), FadeOut(ray2_reflect),\n                  FadeOut(ray3), FadeOut(ray3_reflect),\n                  FadeOut(image_arrow), FadeOut(object_arrow),\n                  FadeOut(concave_mirror), FadeOut(principal_axis),\n                  FadeOut(focal_point), FadeOut(center_curve))\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SimpleGenerator(Scene):\n    def construct(self):\n        # Create base parts of the generator\n        base_circle = Circle(radius=1.5, color=GREY_B).set_fill(GREY_A, 1)\n        coils = VGroup(*[\n            Arc(radius=1.5, angle=PI / 2, start_angle=PI / 2 * i, color=BLUE)\n            for i in range(4)\n        ]).set_z_index(1)\n\n        # Create the armature\n        armature = VGroup(\n            Line(ORIGIN, UP * 1.5, color=RED),\n            Line(ORIGIN, DOWN * 1.5, color=RED)\n        ).set_z_index(2)\n\n        # Combine into a single VGroup for the generator\n        generator = VGroup(base_circle, coils, armature)\n\n        # Generate labels and arrows for \"Magnetic Field\" and \"Current\"\n        magnetic_field_text = Text(\"Magnetic Field\", color=BLUE).shift(LEFT * 3.5)\n        magnetic_field_arrow = Arrow(\n            magnetic_field_text.get_right(), coils[0].get_center(),\n            color=BLUE, buff=0.2\n        )\n\n        current_text = Text(\"Current\", color=RED).shift(RIGHT * 3.5 + DOWN * 0.5)\n        current_arrow = Arrow(\n            current_text.get_left(), armature.get_top(),\n            color=RED, buff=0.2\n        )\n\n        # Set the background color, add all objects to the scene\n        self.camera.background_color = WHITE\n        self.add(generator, magnetic_field_text, magnetic_field_arrow, current_text, current_arrow)"
  },
  {
    "text": "from manim import *\n\nclass ExampleNeuralNetworkScene(ThreeDScene):\n    def construct(self):\n        # Let's create a simple neural network with 3 layers\n        \n        # Define the number of neurons for each layer\n        layers = [4, 5, 3]  \n\n        # Colors for different layers\n        first_layer_color = BLUE\n        middle_layer_color = GREEN\n        output_layer_color = RED\n\n        # Initial positions\n        first_layer_position = LEFT * 3\n        middle_layer_position = ORIGIN\n        output_layer_position = RIGHT * 3\n\n        # Create the first layer\n        first_layer = VGroup(\n            *[Circle(radius=0.2, color=first_layer_color) for _ in range(layers[0])]\n        ).arrange(DOWN, buff=0.5).move_to(first_layer_position)\n\n        # Create the middle layer\n        middle_layer = VGroup(\n            *[Circle(radius=0.2, color=middle_layer_color) for _ in range(layers[1])]\n        ).arrange(DOWN, buff=0.5).move_to(middle_layer_position)\n\n        # Create the output layer\n        output_layer = VGroup(\n            *[Circle(radius=0.2, color=output_layer_color) for _ in range(layers[2])]\n        ).arrange(DOWN, buff=0.5).move_to(output_layer_position)\n\n        # Draw the neurons in the scene\n        self.add(first_layer, middle_layer, output_layer)\n\n        # Function for creating arrows from one layer to another\n        def connect_layers(layer1, layer2):\n            return VGroup(\n                *[Line(layer1[i].get_center(), layer2[j].get_center(), buff=0.1)\n                  for i in range(len(layer1)) for j in range(len(layer2))]\n            )\n        \n        # Connect the first layer to the middle layer\n        first_to_middle_arrows = connect_layers(first_layer, middle_layer)\n        # Connect the middle layer to the output layer\n        middle_to_output_arrows = connect_layers(middle_layer, output_layer)\n\n        # Add the arrows to the scene\n        self.add(first_to_middle_arrows, middle_to_output_arrows)\n\n        # Move the camera to get a better view\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n\n        # Show passing flash to simulate signal\n        self.play(ShowPassingFlash(first_to_middle_arrows.copy().set_color(YELLOW), run_time=2, lag_ratio=0.2))\n        self.play(ShowPassingFlash(middle_to_output_arrows.copy().set_color(YELLOW), run_time=2, lag_ratio=0.2))\n\n        # Hold on the last frame\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n# Define colors to be used\nBACKGROUND_COLOR = \"#FAEBD7\"\nTEXT_COLOR = \"#5B5A5A\"\nBLUE_COLOR = \"#1E90FF\"\nGREEN_COLOR = \"#32CD32\"\nRED_COLOR = \"#FF6347\"\nYELLOW_COLOR = \"#FFD700\"\nPURPLE_COLOR = \"#8A2BE2\"\n\n# Configure frame properties\nconfig.frame_size = (1920, 1080)\nconfig.frame_width = 16\nconfig.frame_height = 9\n\nclass FigureTwo(Scene):\n    def construct(self):\n        # Set the background color of the scene\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        # Create several circles with different colors and arrange them\n        circles = VGroup(\n            Circle(stroke_color=BLUE_COLOR, fill_color=RED_COLOR, fill_opacity=0.5),\n            Circle(stroke_color=GREEN_COLOR, fill_color=YELLOW_COLOR, fill_opacity=0.5),\n            Circle(stroke_color=PURPLE_COLOR, fill_color=GREEN_COLOR, fill_opacity=0.5)\n        )\n        circles.arrange(RIGHT, buff=1)\n        \n        # Create mathematical expression and position it below the circles\n        equation = MathTex(r\"e^{i\\pi} + 1 = 0\", color=TEXT_COLOR)\n        equation.next_to(circles, DOWN)\n        \n        # Create a text label for each circle and position it at the center of each circle\n        labels = VGroup(\n            Text(\"i\", font_size=24, color=TEXT_COLOR).move_to(circles[0]),\n            Text(\"ii\", font_size=24, color=TEXT_COLOR).move_to(circles[1]),\n            Text(\"iii\", font_size=24, color=TEXT_COLOR).move_to(circles[2])\n        )\n        \n        # Animate the circles appearing one after another\n        self.play(LaggedStart(*(Create(circle) for circle in circles), lag_ratio=0.5), run_time=2)\n        # Show equation\n        self.play(Write(equation), run_time=1)\n        # Display the text labels\n        self.play(LaggedStart(*(FadeIn(label) for label in labels), lag_ratio=0.5), run_time=2)\n        \n        # Wait for a short duration\n        self.wait(2)\n        \n        # Move everything to the left and then clear the screen\n        animation_group = VGroup(circles, labels, equation)\n        self.play(animation_group.animate.shift(LEFT*3))\n        self.wait(1)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        square = Square(side_length=3, fill_color=BLUE, fill_opacity=0.5)\n        text = Text(\"Manim\", color=WHITE, font_size=24)\n        group = VGroup(square, text).move_to(ORIGIN)\n        self.play(Create(group))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ProbabilityTree(Scene):\n    def construct(self):\n        # Create the probability tree diagram nodes\n        start_node = Dot(point=ORIGIN)\n        end_nodes = VGroup(*[Dot() for _ in range(4)])\n\n        # Position the end nodes\n        end_nodes.arrange_in_grid(rows=2, cols=2, buff=2)\n        end_nodes.to_edge(DOWN)\n\n        # Create edges between start node and end nodes\n        edges = VGroup()\n        for end_node in end_nodes:\n            edge = Line(start_node.get_center(), end_node.get_center())\n            edges.add(edge)\n\n        # Labels for events and probabilities\n        labels = [\"HH\", \"HT\", \"TH\", \"TT\"]\n        probabilities = [\"1/4\", \"1/4\", \"1/4\", \"1/4\"]\n        event_labels = VGroup()\n        probability_labels = VGroup()\n        \n        for i, node in enumerate(end_nodes):\n            event_label = Tex(labels[i])\n            event_label.next_to(node, DOWN)\n            event_labels.add(event_label)\n\n            prob_label = Tex(probabilities[i])\n            prob_label.move_to(edge.get_center())\n            probability_labels.add(prob_label)\n\n        # Draw the tree\n        self.play(ShowCreation(start_node))\n        self.play(LaggedStart(*[GrowFromPoint(edge, start=start_node.get_center()) for edge in edges], lag_ratio=0.5))\n        self.play(*[FadeIn(label) for label in event_labels])\n        self.play(*[Write(label) for label in probability_labels])\n\n        # Hold on screen\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FlowingVectorField(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        field = ArrowVectorField(lambda p: np.array([p[1], -p[0], 0]), x_range=[-7, 7], y_range=[-5, 5])\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]),\n            x_range=[-7, 7], y_range=[-5, 5], \n            resolution=(11, 11), stream_line_config={\"stroke_width\": 3}\n        )\n\n        self.play(Create(plane), Create(field))\n        self.play(Create(stream_lines))\n        self.wait(2)\n        self.play(FadeOut(plane), FadeOut(field), FadeOut(stream_lines))"
  },
  {
    "text": "from manim import *\n\nclass MovingSquare(Scene):\n    def construct(self):\n        square = Square(color=RED, fill_opacity=1)\n        square.set_width(1)\n\n        # Animate the square across the screen\n        self.play(square.animate.shift(RIGHT * 5), run_time=2)\n        self.wait(0.5)\n\n        # Animate the square to change color\n        self.play(square.animate.set_color(BLUE), run_time=1)\n        self.wait(0.5)\n\n        # Animate the square to move in a circle\n        circle_path = Circle(radius=2.5, color=WHITE)\n        self.play(MoveAlongPath(square, circle_path), run_time=2)\n        self.wait(0.5)\n\n        # Animate the square scaling up and then fading out\n        self.play(square.animate.scale(3), run_time=1)\n        self.play(FadeOut(square), run_time=1)\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass MovingAlongEpicycloid(Scene):\n    def construct(self):\n        def epicycloid(t):\n            R, r, d = 3, 1, 2\n            theta = t\n            x = (R + r) * np.cos(theta) - d * np.cos((R + r) / r * theta)\n            y = (R + r) * np.sin(theta) - d * np.sin((R + r) / r * theta)\n            return np.array([x, y, 0])\n\n        path = ParametricFunction(\n            epicycloid,\n            t_range=[0, 4 * PI],\n            color=BLUE\n        )\n\n        dot = Dot(color=BLUE).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=8, rate_func=linear)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass VariousShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        ellipse = Ellipse(width=3, height=1, color=RED)\n        rectangle = Rectangle(width=2, height=3, color=GREEN)\n        triangle = Triangle(color=YELLOW)\n        \n        shapes = VGroup(circle, ellipse, rectangle, triangle)\n        \n        shapes.arrange_in_grid(rows=2, cols=2)\n        \n        self.add(shapes)"
  },
  {
    "text": "from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        # Create a square and an associated animated boundary\n        square = Square()\n        animated_boundary = AnimatedBoundary(square, cycle_rate=2, colors=[YELLOW, PINK, WHITE])\n\n        # Add the square and its animated boundary to the scene\n        self.add(square, animated_boundary)\n\n        # Play animation for 4 seconds\n        self.wait(4)\n\n        # Transform the square into a triangle while moving it up\n        triangle = Triangle().shift(UP)\n        self.play(Transform(square, triangle), run_time=1)\n\n        # Wait for 2 seconds before concluding the animation\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nDARK_GREEN_COLOR = \"#2a623d\"\n\nclass PieChartExample(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        data = [30, 15, 55]\n        pie_chart = PieChart(\n            values=data,\n            colors=[LIGHT_BLUE_COLOR, LIGHT_PURPLE_COLOR, DARK_GREEN_COLOR],\n            labels=[\"Sky\", \"Lavender\", \"Forest\"],\n            start_angle=90,\n            radius=2,\n            slice_colors_opacity=0.7\n        )\n\n        legends = [\n            LegendEntry(text=\"Sky\", color=LIGHT_BLUE_COLOR),\n            LegendEntry(text=\"Lavender\", color=LIGHT_PURPLE_COLOR),\n            LegendEntry(text=\"Forest\", color=DARK_GREEN_COLOR)\n        ]\n        legend = Legend(legends, dot_scale=1)\n        legend.shift(3 * DOWN)\n\n        title = Text(\"Favorite Colors Survey Results\", color=TEXT_COLOR)\n        title.to_edge(UP)\n\n        self.add(pie_chart, legend, title)"
  },
  {
    "text": "from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        s = self.square_with_text(2, \"Manim\", RED, 36, WHITE, 3, YELLOW)\n        self.play(Create(s))\n        self.wait(2)\n\n    def square_with_text(\n        self, side_length: float, txt: str, color=WHITE, font_size: int = 48,\n        font_color=BLACK, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        sqr = Square(side_length, color).set_stroke(color).set_fill(fill_color, opacity=1.0)\n        t = Text(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(sqr, t).move_to(ORIGIN)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#dddddd\"\nCOLOR_ONE = \"#e07a5f\"\nCOLOR_TWO = \"#3d405b\"\nCOLOR_THREE = \"#81b29a\"\nCOLOR_FOUR = \"#f2cc8f\"\n\ndef ease_in_quad(t):\n    return rate_functions.ease_in_quad(t)\n\ndef GoldenRectangle(width, height, color):\n    rect = Rectangle(width=width, height=height, color=color)\n\n    text = Tex(f\"{width}: {height}\", color=color)\n    text.scale(0.75 * min(width, height) / 2)\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass GoldenSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            COLOR_ONE,\n            COLOR_TWO,\n            COLOR_THREE,\n            COLOR_FOUR\n        ]\n        \n        ratio = (1 + 5 ** 0.5) / 2 # Golden ratio\n        widths = [1, ratio]\n        heights = [1, 1]\n\n        for _ in range(6):\n            widths.append(widths[-2] + widths[-1])\n            heights.append(heights[-2] + heights[-1])\n\n        directions = [RIGHT, UP, LEFT, DOWN]\n        rectangles = Group()\n\n        for i in range(len(widths)):\n            rectangles.add(GoldenRectangle(widths[i], heights[i], colors[i % 4]))\n            if i == 0:\n                continue\n            rectangles[i].next_to(rectangles[i - 1], directions[i % 4], buff=0)\n\n        animations = []\n        for rectangle in rectangles:\n            animations.append(Create(rectangle[0]))\n            animations.append(Write(rectangle[1]))\n\n        self.play(LaggedStart(*animations, lag_ratio=0.2))\n\n        angle_tracker = ValueTracker(0)\n        last_rect = rectangles[-1]\n        start_angle = 0\n        arc_radius = 1\n\n        for _ in range(4):\n            arc = always_redraw(\n                lambda: Arc(\n                    radius=arc_radius,\n                    arc_center=last_rect.get_corner(DL),\n                    start_angle=start_angle,\n                    angle=angle_tracker.get_value(),\n                    color=TEXT_COLOR\n                )\n            )\n            self.add(arc)\n            self.play(\n                angle_tracker.animate.set_value(TAU),\n                rate_func=ease_in_quad,\n                run_time=2\n            )\n            start_angle += TAU / 2\n            arc_radius *= ratio\n\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects), run_time=2))"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\n# Define some constants for colors\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\n\n# Function to create a cookie circle\ndef CookieCircle():\n    return VGroup(\n        Circle(radius=1, color=TEXT_COLOR, fill_opacity=1),\n        Dot(point=UP, color=BACKGROUND_COLOR),\n        Dot(point=DOWN, color=BACKGROUND_COLOR),\n        Dot(point=RIGHT, color=BACKGROUND_COLOR),\n        Dot(point=LEFT, color=BACKGROUND_COLOR)\n    )\n\nclass CookiePartition(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividing cookie into 4 parts\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.3).to_edge(UP)\n        \n        cookie = CookieCircle()\n        partition_lines = VGroup(\n            Line(UP, DOWN, color=BACKGROUND_COLOR),\n            Line(LEFT, RIGHT, color=BACKGROUND_COLOR),\n        )\n        \n        partitioned_cookie = VGroup(cookie, partition_lines)\n        \n        self.play(Write(title))\n        self.play(FadeIn(cookie))\n        self.wait(0.5)\n        \n        for line in partition_lines:\n            self.play(Write(line), run_time=0.5)\n        \n        self.play(partitioned_cookie.animate.scale(0.7).shift(3 * LEFT + 2 * UP))\n        \n        fraction_group = VGroup()\n        \n        # Add fractions to indicate parts of the cookie\n        for i in range(4):\n            frac = MathTex(rf\"\\frac{1}{{4}}\", color=LIGHT_BLUE_COLOR).scale(0.5)\n            pos = cookie.get_critical_point([UP, DOWN, LEFT, RIGHT][i]) + frac.get_width() * [DOWN, UP, RIGHT, LEFT][i]\n            frac.move_to(pos)\n            fraction_group.add(frac)\n        \n        self.play(AnimationGroup(*[FadeIn(f) for f in fraction_group], lag_ratio=0.3))\n        \n        self.wait(1)\n        self.play(Uncreate(title), FadeOut(partitioned_cookie), FadeOut(fraction_group))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass Atom(Scene):\n    def construct(self):\n        # Create the center of the atom\n        nucleus = circle_with_text(0.4, \"N\", RED_E, 30, WHITE, 2, RED_E)\n        nucleus.move_to(ORIGIN)\n        \n        # Create three electrons\n        e1 = electron()\n        e2 = electron()\n        e3 = electron()\n        \n        # Position electrons around the nucleus\n        e1.move_to(UP * 0.8)\n        e2.move_to(DOWN * 0.6 + LEFT * 0.6)\n        e3.move_to(DOWN * 0.6 + RIGHT * 0.6)\n\n        # Animate the creation of nucleus and electrons\n        self.play(Create(nucleus))\n        self.play(FadeIn(e1), FadeIn(e2), FadeIn(e3))\n        \n        # Animate electrons' circular orbits around the nucleus\n        self.play(\n            Rotating(e1, about_point=nucleus.get_center(), radians=2*PI),\n            Rotating(e2, about_point=nucleus.get_center(), radians=2*PI, rate_func=linear),\n            Rotating(e3, about_point=nucleus.get_center(), radians=2*PI, rate_func=linear),\n            run_time=4,\n            rate_func=linear\n        )\n\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass PendulumScene(Scene):\n    def construct(self):\n        pendulum = Pendulum(\n            initial_theta=0.3,\n            damping=0.1,\n            length=3,\n            gravity=9.81,\n            bob_mass=2\n        )\n        pendulum.start_swinging()\n\n        path = TracedPath(pendulum.get_bob().get_center, stroke_color=RED, stroke_width=4)\n        self.add(pendulum, path)\n        \n        self.wait(10)"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkArchitectureScene(Scene):\n    def construct(self):\n        # Define the size and style of the neural network layers\n        layer_sizes = [4, 8, 6, 8, 4]\n        layer_style = {\"stroke_color\": BLUE, \"fill_color\": GREEN, \"fill_opacity\": 0.5}\n        \n        # Create the neural network layers\n        layers = VGroup(*[\n            Rectangle(height=0.2, width=size, **layer_style) for size in layer_sizes\n        ]).arrange(DOWN, buff=0.5)\n\n        # Update the positions to be centered at ORIGIN\n        layers.move_to(ORIGIN)\n\n        # Create the neural network edges (connections)\n        edges = VGroup()\n        for i in range(len(layer_sizes) - 1):\n            edges.add(*[\n                Line(layers[i][j].get_bottom(), layers[i + 1][k].get_top())\n                for j in range(layer_sizes[i])\n                for k in range(layer_sizes[i + 1])\n            ])\n\n        # Set the edge style\n        edges.set_stroke(WHITE, 0.5)\n\n        # Create a neural network group\n        neural_network = VGroup(layers, edges)\n\n        # Animate the construction of the neural network\n        self.play(ShowCreation(edges), run_time=2)\n        self.play(FadeIn(layers, shift=DOWN), run_time=2)\n\n        # Display the neural network\n        self.wait(1)\n        self.play(FadeOut(neural_network), run_time=2)\n"
  },
  {
    "text": "from manim import *\n\nclass TriangleToSquare(Scene):\n    def construct(self):\n        triangle = Triangle()\n        square = Square()\n\n        # Playing animation.\n        self.play(Create(triangle))\n        self.play(triangle.animate.rotate(PI/2))\n        self.play(Transform(triangle, square), run_time=3)\n        self.play(FadeOut(triangle))"
  },
  {
    "text": "from manim import *\nfrom manim_physics import *\n\nclass BalancingBall(SpaceScene):\n    def construct(self):\n        # Create a rectangle to act as a seesaw\n        seesaw = Rectangle(height=0.2, width=4)\n        seesaw.set_color(BLUE)\n\n        # Create a circle to act as a ball\n        ball = Circle(radius=0.2)\n        ball.set_fill(RED, opacity=1)\n        ball.move_to(3 * RIGHT)\n\n        # Create a small rectangle to act as the fulcrum of the seesaw\n        fulcrum = Rectangle(height=0.1, width=0.2)\n        fulcrum.set_color(GREEN)\n        fulcrum.next_to(seesaw, DOWN, buff=0)\n\n        # Add all the objects to the scene\n        self.add(seesaw, ball, fulcrum)\n\n        # Make the seesaw a static body so it can rotate around the fulcrum\n        self.make_static_body(seesaw, bounce=0.5, friction=1.0, angle_of_restitution=0.5)\n        # Pin the seesaw to the fulcrum\n        self.pin(seesaw, fulcrum.get_center())\n\n        # Make the ball a rigid body so it is affected by gravity and can bounce\n        self.make_rigid_body(ball, bounce=0.8, friction=1.0)\n\n        # Play the animation\n        self.wait(5)\n        # during wait time, the ball would move and the seesaw would balance itself according to physics simulation"
  },
  {
    "text": "class TriangleToSquare(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(red_triangle))\n        yellow_square = Square(color=YELLOW, fill_opacity=0.5)\n        self.play(ReplacementTransform(red_triangle, yellow_square))\n        self.play(Indicate(yellow_square))\n        self.play(FadeOut(yellow_square))"
  },
  {
    "text": "from manim import *\nimport random\n\nclass PiApproximationByMonteCarlo(Scene):\n    def construct(self):\n        num_points = 1000\n        circle = Circle(radius=1)\n        square = Square(side_length=2).move_to(circle.get_center())\n        inside_circle = 0\n\n        points_inside_circle = VGroup()\n        points_outside_circle = VGroup()\n\n        pi_estimate = always_redraw(lambda: DecimalNumber((inside_circle / num_points) * 4).next_to(circle, DOWN, buff=0.5))\n\n        self.add(square, circle, pi_estimate)\n        for _ in range(num_points):\n            x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n            if x**2 + y**2 <= 1:\n                inside_circle += 1\n                points_inside_circle.add(Dot(point=(x, y, 0), color=BLUE))\n            else:\n                points_outside_circle.add(Dot(point=(x, y, 0), color=RED))\n            self.play(\n                FadeIn(points_inside_circle.copy(), scale=0.5),\n                FadeIn(points_outside_circle.copy(), scale=0.5),\n                ChangeDecimalToValue(pi_estimate, (inside_circle / num_points) * 4),\n                run_time=0.1,\n                rate_func=linear\n            )\n        self.wait(1)"
  },
  {
    "text": "import numpy as np\nfrom manim import *\n\nMOON_ORBIT_WIDTH = 2.5\nMOON_ORBIT_HEIGHT = 0.3\nMOON_RATE = 0.15\nEARTH_DAY_START = 0.5\nMOON_PHASE_CHANGE_RATE = 1.2\nLUNAR_MONTH = 29.5\n\nclass MoonPhaseScene(Scene):\n    def construct(self):\n        # Earth setup\n        earth = Dot(point=ORIGIN, color=BLUE)\n        self.add(earth)\n        \n        # Moon orbit path setup\n        moon_orbit = Ellipse(width=MOON_ORBIT_WIDTH, height=MOON_ORBIT_HEIGHT, color=WHITE)\n        moon_path = moon_orbit.move_to(earth.get_center())\n        self.add(moon_path)\n        \n        # Moon setup\n        moon_tracker = ValueTracker(EARTH_DAY_START)\n        moon = Dot(color=WHITE)\n        moon.move_to(moon_orbit.point_from_proportion(EARTH_DAY_START))\n        \n        # Moon updater\n        def update_moon(m, dt):\n            phase_progress = (moon_tracker.get_value() / LUNAR_MONTH) % 1\n            m.become(Dot(point=moon_orbit.point_from_proportion(phase_progress), color=WHITE))\n            moon_tracker.increment_value(MOON_RATE * dt)\n        \n        moon.add_updater(update_moon)\n        self.add(moon)\n        \n        # Moon Phases\n        phases_group = VGroup()\n        for i in range(8):\n            phase_pos = moon_orbit.point_from_proportion(i / 8)\n            phase_dot = Dot(point=phase_pos, color=YELLOW).scale(0.5)\n            phases_group.add(phase_dot)\n        \n        self.add(phases_group)\n\n        moon_phase_names = [\n            \"New Moon\", \"Waxing Crescent\", \"First Quarter\", \"Waxing Gibbous\",\n            \"Full Moon\", \"Waning Gibbous\", \"Last Quarter\", \"Waning Crescent\",\n        ]\n\n        # Moon phase labels\n        for i, phase_name in enumerate(moon_phase_names):\n            label = Text(phase_name, font_size=20).next_to(phases_group[i], DOWN)\n            self.add(label)\n        \n        # Running the scene\n        self.wait(LUNAR_MONTH / MOON_PHASE_CHANGE_RATE)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.layers.flatten import FlattenLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport numpy as np\nfrom PIL import Image\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Manim rendering options\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 6.0\nconfig.frame_width = 8.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Load an image and convert to numpy array\n        image_path = ROOT_DIR / \"assets/mnist/digit.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n        \n        # Define the neural network structure\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=2.5),\n            Convolutional2DLayer(\n                num_feature_maps=32,\n                feature_map_size=6,\n                filter_size=5,\n                padding=2,\n                padding_dashed=True\n            ),\n            MaxPooling2DLayer(pool_size=2),\n            Convolutional2DLayer(\n                num_feature_maps=64,\n                feature_map_size=6,\n                filter_size=5,\n                padding=2,\n                padding_dashed=True\n            ),\n            MaxPooling2DLayer(pool_size=2),\n            FlattenLayer(),\n            FeedForwardLayer(120),\n            FeedForwardLayer(84),\n            FeedForwardLayer(10),\n        ], layer_spacing=0.3)\n\n        # Add the neural network model to the scene\n        self.add(nn)\n        \n        # Create and play the forward pass animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass, run_time=15)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CreateAndFadeOutExample(Scene):\n    def construct(self):\n        text = Text(\"Create and Fade Out\").to_edge(UP)\n        self.play(Write(text))\n        \n        squares = VGroup(\n            Square().shift(LEFT),\n            Square().shift(ORIGIN),\n            Square().shift(RIGHT)\n        )\n        \n        self.play(Create(squares))\n        self.wait(1)\n        self.play(FadeOut(squares))\n        self.wait(1)"
  },
  {
    "text": "class SquareToCircle(Scene):\n    def construct(self):\n        square = Square()  # Create a square\n        circle = Circle()  # Create a circle\n        circle.set_fill(PINK, opacity=0.5)  # Set the color and transparency for the circle\n\n        self.play(Create(square))  # Animate the creation of the square\n        self.play(Transform(square, circle))  # Animate the square turning into a circle\n        self.play(FadeOut(square))  # Animate the fading out of the circle (originally the square)"
  },
  {
    "text": "from manim import *\n\nclass VariousShapes(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle(radius=1, color=BLUE)\n        circle.shift(LEFT*2)\n\n        # Create a rectangle\n        rectangle = Rectangle(height=2, width=3, color=GREEN)\n        rectangle.next_to(circle, RIGHT, buff=1)\n\n        # Create an ellipse\n        ellipse = Ellipse(width=3, height=1, color=RED)\n        ellipse.next_to(rectangle, RIGHT, buff=1)\n\n        # Add shapes to the scene\n        self.add(circle, rectangle, ellipse)\n\n        # Show animation\n        self.play(\n            GrowFromCenter(circle),\n            FadeIn(rectangle),\n            GrowFromEdge(ellipse, UP)\n        )\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass MovingShapes(Scene):\n    def construct(self):\n        squares = VGroup(\n            *[Square(side_length=1, color=Color(hue=i/7, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for i in range(7)]\n        ).arrange_in_grid(rows=1, cols=7, col_width=2)\n        self.play(Create(squares), run_time=2)\n        self.play(\n            squares.animate.shift(UP * 2),\n            rate_func=smooth,\n            run_time=2\n        )\n        self.play(\n            squares[0].animate.rotate(PI/2),\n            squares[1].animate.rotate(PI).scale(0.5),\n            squares[2].animate.rotate(PI).scale(2),\n            squares[3].animate.rotate(PI/2).set_opacity(0.2),\n            squares[4].animate.rotate(-PI/2).set_color(RED),\n            squares[5].animate.rotate(PI).set_fill(YELLOW, opacity=0.75),\n            squares[6].animate.rotate(PI/4).set_stroke(BLUE, width=4),\n            run_time=2\n        )\n        self.wait()"
  },
  {
    "text": "from manim import Scene, VGroup, Circle, Line\n\nclass LinearTransformationScene(Scene):\n    def construct(self):\n        # Create a group of objects\n        group = VGroup(*[Circle() for i in range(3)])\n        group.arrange_in_grid(buff=1.0)\n\n        # Start by drawing the group\n        self.play(Create(group))\n\n        # Apply a transformation to the group\n        transformation_matrix = [[1, 2], [0, 1]]\n        self.play(group.animate.apply_matrix(transformation_matrix))\n\n        # Draw lines to represent the transformation axis\n        x_axis = Line(start=-2 * RIGHT, end=2 * RIGHT)\n        y_axis = Line(start=-2 * UP, end=2 * UP)\n        self.play(Create(x_axis), Create(y_axis))\n\n        # Show the transformed group\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(group), FadeOut(x_axis), FadeOut(y_axis))"
  },
  {
    "text": "import math\nfrom manim import *\n\nclass ShapesScene(Scene):\n    def construct(self):\n        # Create a background color gradient rectangle\n        background = Rectangle(width=config.frame_width, height=config.frame_height)\n        background.set_fill(BLUE_D, opacity=1)\n        background.set_stroke(BLUE_E, width=6)\n\n        # Display the background on the scene\n        self.play(FadeIn(background))\n        self.wait(1)\n\n        # Adding a square on the screen\n        square = Square(side_length=3)\n        square.set_stroke(color=YELLOW, width=3)\n        square.set_fill(YELLOW, opacity=0.5)\n\n        # Display and move the square on the scene\n        self.play(Create(square))\n        self.wait(1)\n        self.play(square.animate.shift(UP + RIGHT))\n        self.wait(1)\n\n        # Adding a circle overlapping the square\n        circle = Circle(radius=1.5)\n        circle.set_stroke(color=GREEN, width=3)\n        circle.set_fill(GREEN, opacity=0.5)\n        \n        # Display and move the circle on the scene\n        self.play(Create(circle))\n        self.wait(1)\n        self.play(circle.animate.next_to(square, UP))\n        self.wait(1)\n\n        # Group both shapes and animate them together\n        shapes = VGroup(square, circle)\n        self.play(shapes.animate.shift(LEFT * 2))\n        self.wait(1)\n        \n        # Fade out everything\n        self.play(FadeOut(VGroup(background, shapes)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FallingObjects(Scene):\n    def construct(self):\n        balls = VGroup(*[Ball() for _ in range(5)])\n        balls.arrange(RIGHT, buff=0.5)\n        floor = Line(LEFT, RIGHT).shift(DOWN)\n        \n        self.play(ShowCreation(balls), ShowCreation(floor))\n        self.wait(1)\n        \n        for ball in balls:\n            ball.set_fill(BLUE, opacity=0.5)\n            self.play(Fall(ball), run_time=2)\n        \n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef DivisionOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.5)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass GeometryFive(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = DivisionOperation(\"./assets/Asset 5.png\", \"\\\\div 3 = 15\")\n        operation_2 = Tex(r\"\\textbf{b} \\div 3 = 15\", color=BLACK)\n        operation_2[0][0].set(color=LIGHT_GREEN_COLOR)\n        operation_2.scale(1.5)\n        operation_3 = Tex(r\"\\textbf{45} \\div 3 = 15\", color=BLACK)\n        operation_3[0][0].set(color=LIGHT_GREEN_COLOR)\n        operation_3.scale(1.5)\n        conclusion_1 = DivisionOperation(\"./assets/Asset 5.png\", \"= 45\")\n        conclusion_2 = Tex(r\"\\textbf{b} = 45\", color=BLACK)\n        conclusion_2[0][0].set(color=LIGHT_GREEN_COLOR)\n        conclusion_1.scale(0.8)\n        conclusion_2.scale(1.5)\n        Group(\n            operation_1,\n            operation_2,\n            operation_3,\n            Group(conclusion_1, conclusion_2).arrange(RIGHT, buff=0.5)\n        ).arrange(DOWN, buff=0.7)\n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(Transform(operation_2.copy(), operation_3))\n        self.wait(1)\n        self.play(\n            FadeIn(conclusion_1, target_position=ORIGIN),\n            FadeIn(conclusion_2, target_position=ORIGIN)\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
  },
  {
    "text": "from manim import *_x000D_\nimport numpy as np_x000D_\n_x000D_\nclass AVLTree(VGroup):_x000D_\n    def __init__(_x000D_\n        self,_x000D_\n        scene,_x000D_\n        levels=3,_x000D_\n        node_radius=0.5,_x000D_\n        label_scale_factor=0.75,_x000D_\n        node_color=RED,_x000D_\n        edge_color=WHITE,_x000D_\n        animation_runtime=0.5,_x000D_\n    ):_x000D_\n        super().__init__()_x000D_\n        self.scene = scene_x000D_\n        self.levels = levels_x000D_\n        self.node_radius = node_radius_x000D_\n        self.label_scale_factor = label_scale_factor_x000D_\n        self.node_color = node_color_x000D_\n        self.edge_color = edge_color_x000D_\n        self.animation_runtime = animation_runtime_x000D_\n_x000D_\n        self.nodes = []_x000D_\n        self.edges = []_x000D_\n        self.tree_height = 1_x000D_\n_x000D_\n        self.create_tree(levels)_x000D_\n_x000D_\n    def create_tree(self, levels):_x000D_\n        level_width = 3.0 * (2 ** (levels - 1))_x000D_\n        nodes_current_level = 1_x000D_\n        for level in range(levels):_x000D_\n            horizontal_spacing = level_width / nodes_current_level_x000D_\n            for i in range(nodes_current_level):_x000D_\n                x = -level_width / 2 + i * horizontal_spacing_x000D_\n                y = -level_x000D_\n                node = self.create_node(value=\"\")_x000D_\n                node.move_to([x, y, 0])_x000D_\n                self.nodes.append(node)_x000D_\n                self.add(node)_x000D_\n            nodes_current_level *= 2_x000D_\n_x000D_\n    def create_node(self, value):_x000D_\n        node = Circle(radius=self.node_radius, color=self.node_color)_x000D_\n        label = Tex(str(value), color=WHITE).scale(self.label_scale_factor)_x000D_\n        label.move_to(node.get_center())_x000D_\n        node.add(label)_x000D_\n        return node_x000D_\n_x000D_\n    def create_edge(self, node1, node2):_x000D_\n        edge = Line(node1.get_center(), node2.get_center(), color=self.edge_color)_x000D_\n        self.edges.append(edge)_x000D_\n        self.add(edge)_x000D_\n_x000D_\n    def insert(self, value, index=0):_x000D_\n        node = self.nodes[index]_x000D_\n        label = node[0]_x000D_\n        label.become(Tex(str(value), color=WHITE).scale(self.label_scale_factor))_x000D_\n_x000D_\n        # Animate the label change to the new value_x000D_\n        self.scene.play(ReplacementTransform(label, label.copy()), run_time=self.animation_runtime)_x000D_\n_x000D_\n    def connect_parent_child(self, parent_index, child_index):_x000D_\n        parent_node = self.nodes[parent_index]_x000D_\n        child_node = self.nodes[child_index]_x000D_\n        # Create an edge from the parent to the child node_x000D_\n        self.create_edge(parent_node, child_node)_x000D_\n_x000D_\nclass AVLScene(Scene):_x000D_\n    def construct(self):_x000D_\n        avl_tree = AVLTree(self, levels=4)_x000D_\n        self.add(avl_tree)_x000D_\n_x000D_\n        # Let's insert some values and connect the parent and child nodes after each insertion_x000D_\n        avl_tree.insert(10, 0)_x000D_\n        avl_tree.insert(20, 1)_x000D_\n        avl_tree.insert(30, 2)_x000D_\n_x000D_\n        avl_tree.connect_parent_child(0, 1)_x000D_\n        avl_tree.connect_parent_child(0, 2)_x000D_\n_x000D_\n        # We wait a second to showcase the final tree_x000D_\n        self.wait(1)"
  },
  {
    "text": "class ScalingAndRotating(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        self.play(Scale(s, 2), Rotate(s, PI / 2), run_time=3)"
  },
  {
    "text": "class SquareToCircle(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n        \n        self.play(Create(square))\n        self.play(Transform(square, circle))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass MovingShapes(Scene):\n    def construct(self):\n        circles = VGroup(\n            *[Circle(radius=0.5, color=Color(hue=k/7, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for k in range(7)]\n        ).arrange_in_grid(rows=1)\n        self.play(FadeIn(circles), run_time=2)\n        self.play(\n            circles.animate.shift(UP * 2),\n            rate_func=smooth,\n            run_time=2\n        )\n        self.play(\n            circles.animate.arrange(DOWN).scale(0.75),\n            rate_func=there_and_back_with_pause,\n            run_time=2\n        )\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass CircularWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        wave = CircularWave(\n            point=ORIGIN,  # Origin of the waves\n            color=BLUE,\n            wave_radius=0.5,\n            num_waves=5\n        )\n        self.add(wave)\n        wave.start_wave()\n        self.wait(2)\n        wave.stop_wave()\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        square = Square(side_length=3, fill_color=GREEN, fill_opacity=0.5, color=BLUE)\n        text = Text(\"Manim\", color=WHITE, font_size=24)\n        square_text_group = VGroup(square, text)\n        self.play(Create(square_text_group))\n        self.wait()"
  },
  {
    "text": "from manim import *_x000D_\n_x000D_\nclass BallRollingDownInclinedPlane(Scene):_x000D_\n    def construct(self):_x000D_\n        # Create an inclined plane_x000D_\n        plane = Polygon(_x000D_\n            ORIGIN, 5*RIGHT + 2*UP, 6*RIGHT + 2*UP, 1*RIGHT, fill_opacity=0.5_x000D_\n        )_x000D_\n        plane.set_fill(BLUE_B)_x000D_\n        plane.set_stroke(width=0)_x000D_\n        _x000D_\n        # Create a ball at the top of the inclined plane_x000D_\n        ball = Circle(radius=0.2, color=RED_A).shift(5*RIGHT + 2.2*UP)_x000D_\n        _x000D_\n        # Create gravity_x000D_\n        gravity = 9.81 * DOWN_x000D_\n        _x000D_\n        # Add objects to the scene_x000D_\n        self.add(plane, ball)_x000D_\n        _x000D_\n        # Apply gravity to the ball_x000D_\n        ball_acceleration = always_redraw(_x000D_\n            lambda: ball.shift(gravity * self.time**2 / 2)_x000D_\n        )_x000D_\n        _x000D_\n        # Roll the ball down the plane_x000D_\n        self.play(_x000D_\n            ball_acceleration,_x000D_\n            rate_func=linear,_x000D_\n            run_time=2_x000D_\n        )_x000D_\n        _x000D_\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierCirclesScene(Scene):\n    def construct(self):\n        wave = lambda x: np.sin(x)\n        fourier_circles = FourierSeries(wave, color=BLUE, n_terms=5).scale(0.5)\n        \n        self.add(fourier_circles)\n        self.play(Create(fourier_circles.animate.shift(3*LEFT)))\n        self.wait(2)\n\n        path = fourier_circles.make_path(up_to=3*TAU, step_size=0.05)\n        self.play(Create(path), run_time=3)\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass GrowFromCenterExample(Scene):\n    def construct(self):\n        # Create a square and a circle\n        square = Square().shift(LEFT * 2)\n        circle = Circle().shift(RIGHT * 2)\n\n        # Add the square to the scene\n        self.add(square)\n\n        # Wait for 1 second\n        self.wait(1)\n\n        # Transform the square into a circle and move it to the right\n        self.play(Transform(square, circle), run_time=1)\n\n        # Remove the circle from the scene\n        self.remove(circle)\n\n        # Create a new star shape and grow it from the center\n        star = Star().shift(DOWN * 2)\n        self.play(GrowFromCenter(star))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nMOON_ORBIT_RADIUS = 2\nMOON_RATE = 0.1\nMOON_SIZE = 0.2\nMOON_COLOR = WHITE\nEARTH_SIZE = 0.4\nEARTH_COLOR = BLUE\nSUN_SIZE = 0.8\nSUN_COLOR = YELLOW\nANIMATION_TIME = 50\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Sun\n        sun = Dot(radius=SUN_SIZE, color=SUN_COLOR).move_to(ORIGIN)\n        self.add(sun)\n\n        # Earth orbit (invisible)\n        earth_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        self.add(earth_orbit)\n\n        # Earth\n        earth = Dot(radius=EARTH_SIZE, color=EARTH_COLOR)\n        earth.move_to(earth_orbit.point_from_proportion(0))\n        self.add(earth)\n\n        # Moon orbit (invisible, relative to Earth)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        moon_orbit.move_to(earth.get_center())\n        self.add(moon_orbit)\n\n        # Moon\n        moon = Dot(radius=MOON_SIZE, color=MOON_COLOR)\n        moon.move_to(moon_orbit.point_from_proportion(0))\n        self.add(moon)\n\n        # Set up the ValueTracker for the moon's orbit\n        moon_phase = ValueTracker(0)\n\n        def update_moon(mob, dt):\n            phase = moon_phase.get_value()\n            new_phase = (phase + MOON_RATE * dt) % 1\n            mob.move_to(moon_orbit.point_from_proportion(new_phase))\n            moon_phase.set_value(new_phase)\n\n        # Add the update function to the moon\n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.play(moon_phase.set_value, 1, run_time=ANIMATION_TIME, rate_func=linear)\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass AnotherScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE)\n        square.rotate(PI / 4)\n        self.play(Create(square))\n        self.wait(1)\n        self.play(Transform(square, Circle()))\n        self.wait(1)"
  },
  {
    "text": "class ProjectileMotionScene(MovingCameraScene):\n    def construct(self):\n        self.camera_frame.move_to(2 * UP)\n        formula = MathTex(\n            r\" \\vec{v}(t) &= v_0 \\cos(\\theta) \\mathbf{i} + \"\n            r\"\\left(v_0 \\sin(\\theta) - g t\\right)\\mathbf{j}\"\n        )\n        formula.to_corner(UL)\n\n        def trajectory(t):\n            v0 = 25\n            theta = PI / 4\n            return np.array(\n                (v0 * t * np.cos(theta), v0 * t * np.sin(theta) - 0.5 * 9.8 * t**2, 0)\n            )\n\n        projectile = ParametricFunction(trajectory, t_max=2, color=YELLOW)\n        self.play(Create(projectile))\n        self.wait(1)\n\n        arrow = Arrow(start=ORIGIN, end=[5 * np.cos(PI / 4), 5 * np.sin(PI / 4), 0], color=BLUE)\n        arrow_label = MathTex(r\"v_0\", color=BLUE).next_to(arrow.get_center(), UP)\n        self.play(GrowArrow(arrow), Write(arrow_label))\n\n        self.play(FadeIn(formula))\n        self.wait(1)\n\n        fireworks = VGroup()\n        for j in range(5):\n            sparks = VGroup()\n            i_loc = trajectory(2)\n            for angle in np.linspace(0, TAU, 100):\n                def spark_trajectory(t, theta=angle):\n                    v_spark = 4\n                    return np.array(\n                        (i_loc[0] + v_spark * t * np.cos(theta), \n                         i_loc[1] + v_spark * t * np.sin(theta) - 0.5 * 4.9 * t**2,\n                         0)\n                    )\n                spark = ParametricFunction(spark_trajectory, t_min=0.05, t_max=0.4, color=RED)\n                sparks.add(spark)\n            fireworks.add(sparks)\n\n        self.play(*[Create(sparkle) for sparkle in fireworks], run_time=1.5)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CreateGraphScene(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Create dot at a specific point on the graph\n        dot_at_start_graph = Dot(color=RED).move_to(axes.c2p(0, 0))\n\n        # Create label for the graph, dot, and origin\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        dot_label = Text(\"Start\", color=RED).next_to(dot_at_start_graph, UP+RIGHT)\n        origin_label = Text(\"(0,0)\", color=ORANGE).next_to(axes.c2p(0, 0), DOWN)\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(dot_at_start_graph, shift=UP))\n        self.play(Write(graph_label), Write(dot_label), FadeInFromPoint(origin_label, axes.c2p(0, 0)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass EpitrochoidScene(Scene):\n    def construct(self):\n        R = 3    # Radius of the larger circle\n        r = 1    # Radius of the smaller circle\n        d = 2    # Distance from the center of the smaller circle\n\n        def epitrochoid(t):\n            x = (R + r) * np.cos(t) - d * np.cos((R + r) / r * t)\n            y = (R + r) * np.sin(t) - d * np.sin((R + r) / r * t)\n            return np.array([x, y, 0])\n\n        path = ParametricFunction(epitrochoid, t_range=[0, TAU * r], color=BLUE)\n\n        dot = Dot(color=BLUE).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=8, rate_func=linear)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#dee3e6\"\n        path = Circle().scale(2)\n        fourier_series = self.get_fourier_series(path, color=PURE_RED, n_terms=10)\n        \n        self.play(ShowCreation(path), run_time=2)\n        self.wait()\n        \n        for n, partial_sum in enumerate(fourier_series):\n            self.play(TransformFromCopy(path, partial_sum), run_time=2)\n            self.wait(0.5)\n\n    def get_fourier_series(self, path, color=RED, n_terms=10):\n        fourier_series = []\n        for n in range(1, n_terms + 1):\n            sine_wave = self.get_sine_wave(n, path, color)\n            sine_wave.scale(0.5)\n            fourier_series.append(sine_wave)\n        return fourier_series\n\n    def get_sine_wave(self, frequency, path, color):\n        def func(t):\n            return np.array([np.sin(frequency * t), np.cos(frequency * t), 0])\n        sine_wave = ParametricFunction(func, t_range=[0, TAU], color=color)\n        sine_wave.move_to(path.get_center())\n        return sine_wave\n\nclass FourierSeriesOfSquareWave(FourierSeriesScene):\n    def get_sine_wave(self, frequency, path, color):\n        if frequency % 2 == 0:\n            return VMobject()  # Even harmonics are not present in square wave.\n        amplitude = 4 / (np.pi * frequency)  # Amplitude of the sine wave\n        def square_wave_func(t):\n            return np.array([amplitude * np.sin(frequency * t), 2 * (t - PI / 2) / TAU, 0])\n        sine_wave = ParametricFunction(square_wave_func, t_range=[0, TAU], color=color)\n        sine_wave.move_to(path.get_center())\n        return sine_wave\n\n    def construct(self):\n        self.camera.background_color = \"#dee3e6\"\n        path = Square().scale(2)\n        fourier_series = self.get_fourier_series(path, n_terms=10)\n\n        self.play(ShowCreation(path), run_time=2)\n        self.wait()\n\n        for n, partial_sum in enumerate(fourier_series):\n            self.play(TransformFromCopy(path, partial_sum), run_time=2)\n            self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass AnimatedBoundaryScene(Scene):\n    def construct(self):\n        # Create a square and position it\n        square = Square()\n        square.to_edge(UP)\n\n        # Apply an animated boundary to the square\n        animated_boundary = AnimatedBoundary(square, cycle_rate=2, colors=[YELLOW, PURPLE, TEAL])\n        self.add(square, animated_boundary)\n\n        # Play animations\n        self.play(FadeIn(square))\n        self.wait(1)\n\n        # Transform the square into a triangle\n        triangle = Triangle()\n        triangle.to_edge(UP)\n        self.play(Transform(square, triangle))\n        self.wait(1)\n\n        # Remove the square and animated boundary\n        self.play(FadeOut(square), FadeOut(animated_boundary))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_YELLOW_COLOR = \"#fff5ba\"\nLIGHT_GREEN_COLOR = \"#94c973\"\nLIGHT_BLUE_COLOR = \"#5a8ef5\"\nLIGHT_ORANGE_COLOR = \"#ffad42\"\nLIGHT_PURPLE_COLOR = \"#b085f5\"\nDARK_GREEN_COLOR = \"#2e7d32\"\nDARK_BLUE_COLOR = \"#0033CC\"\n\ndef GummyBear():\n    body_color = LIGHT_YELLOW_COLOR\n    eye_color = DARK_BLUE_COLOR\n    nose_color = DARK_GREEN_COLOR\n    body = Ellipse(width=1, height=1.5, color=body_color, fill_opacity=1)\n    left_eye = Dot(color=eye_color).shift(LEFT*0.2 + UP*0.5)\n    right_eye = Dot(color=eye_color).shift(RIGHT*0.2 + UP*0.5)\n    nose = Dot(color=nose_color).shift(UP*0.2)\n    ears = VGroup(\n        Ellipse(width=0.3, height=0.5, color=body_color, fill_opacity=1).shift(LEFT*0.45 + UP*0.75),\n        Ellipse(width=0.3, height=0.5, color=body_color, fill_opacity=1).shift(RIGHT*0.45 + UP*0.75)\n    )\n    return VGroup(body, left_eye, right_eye, nose, ears)\n\nclass GummyBearCounting(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Let's Count Gummy Bears!\", color=TEXT_COLOR)\n        title.scale(1.2)\n        title.move_to(3 * UP)\n\n        gummy_bears = VGroup(*[GummyBear() for i in range(12)])\n        gummy_bears.arrange_in_grid(rows=3, cols=4, buff=0.5)\n        gummy_bears.center()\n        \n        total_count = Text(\"Total: 12 Bears\", color=LIGHT_GREEN_COLOR)\n        total_count.scale(0.8)\n        total_count.next_to(gummy_bears, DOWN)\n\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromCenter(gummy) for gummy in gummy_bears], lag_ratio=0.1, run_time=3))\n        self.wait(1)\n        self.play(Write(total_count))\n        self.wait(2)\n        self.play(FadeOut(gummy_bears), FadeOut(total_count), FadeOut(title))\n        self.wait(0.5)"
  },
  {
    "text": "class CircleExpansion(Scene):_x000D_\n    def construct(self):_x000D_\n        circles = VGroup()_x000D_\n        colors = [X11.AQUAMARINE1, X11.AQUAMARINE2, X11.AQUAMARINE3, X11.AQUAMARINE4]_x000D_\n        labels = [\"1x\", \"2x\", \"3x\", \"4x\"]_x000D_\n        for i, color in enumerate(colors):_x000D_\n            circle = Circle(radius=1)_x000D_\n            circle.set_fill(color, opacity=1)_x000D_\n            circle.set_stroke(opacity=0)_x000D_\n            label = Text(labels[i], font_size=24, font=\"Monospace\")_x000D_\n            label.move_to(circle)_x000D_\n            circle.add(label)_x000D_\n            circles.add(circle)_x000D_\n_x000D_\n        circles.arrange(RIGHT, buff=1).to_edge(UP)_x000D_\n        self.add(circles)_x000D_\n_x000D_\n        growth_animations = []_x000D_\n        for i, circle in enumerate(circles):_x000D_\n            scale_factor = i + 1_x000D_\n            growth_animations.append(circle.animate(run_time=2, rate_func=smooth).scale(scale_factor))_x000D_\n_x000D_\n        self.wait()_x000D_\n        self.play(*growth_animations)_x000D_\n        self.wait()_x000D_\n_x000D_\n        # Add a tracking line showing the expansion time_x000D_\n        tracker_line = Line(4*LEFT, 4*RIGHT).next_to(circles, DOWN, buff=1)_x000D_\n        tracker_dot = Dot().move_to(tracker_line.get_start())_x000D_\n        self.add(tracker_line, tracker_dot)_x000D_\n_x000D_\n        self.play(_x000D_\n            tracker_dot.animate(run_time=2, rate_func=linear).move_to(tracker_line.get_end()),_x000D_\n            *growth_animations,_x000D_\n        )_x000D_\n        self.wait()"
  },
  {
    "text": "class EasingFunctionComparison(Scene):\n    def construct(self):\n        rate_function_names = [\n            \"linear\", \"ease_in_quad\", \"ease_out_quad\",\n            \"ease_in_out_quad\", \"ease_in_cubic\", \"ease_out_cubic\",\n        ]\n        colors = color_gradient([BLUE, GREEN, YELLOW, ORANGE, RED], len(rate_function_names))\n\n        easing_squares = VGroup()\n        for name, color in zip(rate_function_names, colors):\n            square = Square(size=0.5)\n            square.set_fill(color, opacity=0.9)\n            label = Text(name.replace(\"_\", \" \").title(), font_size=18)\n            label.next_to(square, DOWN)\n            combined = VGroup(square, label)\n            easing_squares.add(combined)\n\n        easing_squares.arrange_in_grid(rows=2, cols=3, buff=1)\n        self.add(easing_squares)\n\n        # Add a thick line to represent progression\n        progression_line = Line(start=4*LEFT, end=4*RIGHT, stroke_width=10)\n        progression_line.next_to(easing_squares, DOWN, buff=1)\n        self.add(progression_line)\n\n        # Marker for the line\n        progression_marker = Dot(color=RED).move_to(progression_line.get_start())\n        self.add(progression_marker)\n\n        self.wait()\n        # Animate squares with different easing functions and marker on the line\n        animations = []\n        for ind, name in enumerate(rate_function_names):\n            rate_func = getattr(rate_functions, name)\n            animation = easing_squares[ind].animate(rate_func=rate_func).shift(4*DOWN)\n            animations.append(animation)\n\n        # Animate all squares simultaneously with the line marker\n        self.play(\n            AnimationGroup(*animations, lag_ratio=0.1),\n            UpdateFromAlphaFunc(\n                progression_marker,\n                lambda m: m.move_to(progression_line.point_from_proportion(self.time / 4)),\n                run_time=4,\n                rate_func=linear\n            )\n        )\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nDARK_GREEN_COLOR = \"#2e8b57\"\nYELLOW_COLOR = \"#ffd700\"\nORANGE_COLOR = \"#ff8c00\"\nRED_COLOR = \"#ff0000\"\nPURPLE_COLOR = \"#800080\"\nAQUA_COLOR = \"#00ffff\"\n\ndef CreateCheckMark():\n    check_mark = VGroup()\n    check_mark.add(Line([0, 0, 0], [0.2, -0.2, 0]))\n    check_mark.add(Line([0.2, -0.2, 0], [0.6, 0.3, 0]))\n    check_mark.set_color(LIGHT_GREEN_COLOR)\n    check_mark.set_stroke(width=6)\n\n    return check_mark\n\ndef CreateXMark():\n    x_mark = VGroup()\n    x_mark.add(Line([-0.3, -0.3, 0], [0.3, 0.3, 0]))\n    x_mark.add(Line([-0.3, 0.3, 0], [0.3, -0.3, 0]))\n    x_mark.set_color(RED_COLOR)\n    x_mark.set_stroke(width=6)\n\n    return x_mark\n\ndef EquationCheck(expression, is_correct=True):\n    text = MathTex(expression, color=TEXT_COLOR).scale(2)\n    if is_correct:\n        symbol = CreateCheckMark()\n    else:\n        symbol = CreateXMark()\n\n    symbol.next_to(text, RIGHT)\n\n    return VGroup(text, symbol)\n\nclass VerifyEquations(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        eq1 = EquationCheck(\"2x + 1 = 5\", is_correct=True)\n        eq2 = EquationCheck(\"4y - 2 = 7\", is_correct=False)\n        eq3 = EquationCheck(\"3a^2 - 9 = 0\", is_correct=True)\n\n        VGroup(eq1, eq2, eq3).arrange(DOWN, buff=1)\n\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(Write(eq3))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(eq1, eq2, eq3)))"
  },
  {
    "text": "from manim import Scene, VGroup\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations import Train\n\nclass TrainNeuralNetworkScene(Scene):\n    def construct(self):\n        # Define a neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4),\n            FeedForwardLayer(7),\n            FeedForwardLayer(2),\n        ],\n        layer_spacing=0.5,\n        )\n\n        # Center the neural network\n        nn.move_to(ORIGIN)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Training animation for the neural network\n        training_animation = Train(nn)\n\n        # Play the training animation\n        self.play(training_animation)\n\n        # Hold the final frame\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-1, 5])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        tangent_line = axes.plot(lambda x: 2*x - 1, color=GREEN)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"The derivative of $x^2$ is $2x$. Here is the tangent when $x=1$.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(1, 1**2))\n        tangent = TangentLine(graph, alpha=0.5, length=4, line_color=GREEN)\n        self.play(Create(dot), Create(tangent))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TextAnimations(Scene):\n    def construct(self):\n        title = Text(\"Writing Text Animation\").to_edge(UP)\n        self.play(Write(title))\n        \n        paragraph = Text(\n            \"Manim makes elaborate animations with text \"\n            \"quite straightforward to program!\"\n        ).scale(0.7).next_to(title, DOWN)\n        self.play(Write(paragraph, run_time=2))\n        \n        self.wait(1)\n        \n        self.play(Unwrite(paragraph, run_time=2))\n        conclusion = Text(\"And just as easy to erase!\").scale(0.7).next_to(title, DOWN)\n        self.play(Transform(title, conclusion))\n        \n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass PerceptronScene(Scene):\n    def construct(self):\n        # Define perceptron layer with 3 inputs and 1 output neuron\n        layer = VGroup()\n        neurons = [Circle(radius=0.15, fill_color=WHITE, fill_opacity=1) for _ in range(4)]\n        inputs = VGroup(*neurons[:3]).arrange(DOWN, buff=0.5)\n        output = neurons[-1]\n\n        # Add input and output neurons to the layer\n        layer.add(inputs)\n        layer.add(output)\n        layer.move_to(ORIGIN)\n\n        # Drawing the synapses (lines connecting neurons)\n        synapses = VGroup()\n        for input_neuron in inputs:\n            synapse = Line(input_neuron.get_center(), output.get_center(), buff=0.15).set_stroke(width=2)\n            synapses.add(synapse)\n        \n        # Add synapses to layer\n        layer.add(synapses)\n\n        # Add neurons numbers\n        for i, input_neuron in enumerate(inputs, 1):\n            neuron_num = Text(f\"x{i}\", color=BLACK).scale(0.5).move_to(input_neuron)\n            layer.add(neuron_num)\n        output_neuron_num = Text(\"y\", color=BLACK).scale(0.5).move_to(output)\n        layer.add(output_neuron_num)\n\n        # Add layer to the scene\n        self.add(layer)\n\n        # Animation part\n        self.play(FadeIn(layer))\n        for synapse in synapses:\n            self.play(ShowCreation(synapse))\n            self.wait(0.1)\n        self.play(*[GrowFromCenter(neuron) for neuron in neurons])\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SampleScene(Scene):\n    def construct(self):\n        initial_text = Text(\"Hello!\").to_edge(UP)\n        self.add(initial_text)\n        self.wait(1)\n        self.play(Transform(initial_text, Text(\"Goodbye!\").to_edge(UP)), run_time=1)\n        warning_text = Text(\"Watch out!\").set_color(RED).next_to(initial_text, DOWN)\n        self.play(Write(warning_text))\n        self.play(Circumscribe(warning_text, color=RED, run_time=1.5))\n        self.wait(1)\n        self.play(FadeOut(initial_text), FadeOut(warning_text))"
  },
  {
    "text": "from manim import *\n\nclass AVLTree(VGroup):\n    def __init__(self, scene, node_radius=0.4, balance_factor=2):\n        super().__init__()\n        self.scene = scene\n        self.node_radius = node_radius\n        self.balance_factor = balance_factor\n        self.root = None\n\n    class AVLNode:\n        def __init__(self, value, node_radius, balance_factor):\n            self.value = value\n            self.height = 1\n            self.balance = 0\n            self.node = None\n            self.edge_left = None\n            self.edge_right = None\n            self.node_visual = Circle(radius=node_radius, color=WHITE).set_fill(GREEN, opacity=1)\n            self.label_visual = MathTex(str(value))\n            self.node_radius = node_radius\n            self.balance_factor = balance_factor\n            self.left = None\n            self.right = None\n\n        def update_heights(self):\n            left_height = self.left.height if self.left else 0\n            right_height = self.right.height if self.right else 0\n            self.height = 1 + max(left_height, right_height)\n\n        def update_balances(self):\n            left_height = self.left.height if self.left else 0\n            right_height = self.right.height if self.right else 0\n            self.balance = left_height - right_height\n\n        def update_visuals(self, center_point):\n            self.node_visual.move_to(center_point)\n            self.label_visual.move_to(center_point)\n\n    def insert(self, value, node=None):\n        if self.root is None:\n            self.root = self.AVLNode(value, self.node_radius, self.balance_factor)\n            self.root.update_visuals(ORIGIN)\n            self.add(self.root.node_visual, self.root.label_visual)\n            return\n\n        if node is None:\n            node = self.root\n\n        if value < node.value:\n            if node.left is None:\n                node.left = self.AVLNode(value, self.node_radius, self.balance_factor)\n                left_position = node.node_visual.get_center() + LEFT * node.node_radius * 2\n                node.left.update_visuals(left_position)\n                node.edge_left = Line(node.node_visual.get_center(), left_position)\n                self.add(node.left.node_visual, node.left.label_visual, node.edge_left)\n            else:\n                self.insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = self.AVLNode(value, self.node_radius, self.balance_factor)\n                right_position = node.node_visual.get_center() + RIGHT * node.node_radius * 2\n                node.right.update_visuals(right_position)\n                node.edge_right = Line(node.node_visual.get_center(), right_position)\n                self.add(node.right.node_visual, node.right.label_visual, node.edge_right)\n            else:\n                self.insert(value, node.right)\n\n        # Update the height and balance of ancestor node\n        node.update_heights()\n        node.update_balances()\n\n        # Balance the tree\n        node = self.rebalance(node)\n\n    def rotate_left(self, z):\n        y = z.right\n        T2 = y.left\n\n        y.left = z\n        z.right = T2\n\n        z.update_heights()\n        z.update_balances()\n        y.update_heights()\n        y.update_balances()\n\n        return y\n\n    def rotate_right(self, y):\n        z = y.left\n        T3 = z.right\n\n        z.right = y\n        y.left = T3\n\n        y.update_heights()\n        y.update_balances()\n        z.update_heights()\n        z.update_balances()\n\n        return z\n\n    def rebalance(self, node):\n        if node.balance < -self.balance_factor:\n            if node.right.balance > 0:\n                node.right = self.rotate_right(node.right)\n                return self.rotate_left(node)\n            return self.rotate_left(node)\n\n        if node.balance > self.balance_factor:\n            if node.left.balance < 0:\n                node.left = self.rotate_left(node.left)\n                return self.rotate_right(node)\n            return self.rotate_right(node)\n\n        return node\n\n\nclass AVLScene(Scene):\n    def construct(self):\n        avl_tree = AVLTree(self)\n        self.add(avl_tree)\n        values = [30, 40, 50, 60, 70, 75]\n        for value in values:\n            avl_tree.insert(value)\n            self.wait(0.5)  # Pause between insertions for visual effect\n        self.wait(2)  # Wait before the scene exits\n"
  },
  {
    "text": "from manim import *\n\nclass FibonacciSpiralScene(Scene):\n    def construct(self):\n        fibonacci_numbers = [0, 1]\n        for _ in range(5):\n            next_number = fibonacci_numbers[-1] + fibonacci_numbers[-2]\n            fibonacci_numbers.append(next_number)\n\n        colors = [YELLOW, GREEN, BLUE, RED, PURPLE, ORANGE]\n\n        arcs = VGroup()\n        start_angle = 0\n        for i, number in enumerate(fibonacci_numbers[2:]):\n            angle = PI / 2\n            arc = Arc(radius=number, angle=angle, start_angle=start_angle, color=colors[i % len(colors)])\n            start_angle += angle\n            arcs.add(arc)\n\n        # Place the Arcs to form the Spiral\n        arcs.arrange_in_grid(rows=1, aligned_edge=UP)\n        self.add(arcs)\n\n        self.play(*[Create(arc) for arc in arcs], run_time=2)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n# Constants\nMOON_ORBIT_RADIUS = 3.0\nEARTH_MOON_DISTANCE = 3.8\nEARTH_RADIUS = 0.2\nMOON_RADIUS = 0.05\nMOON_ORBIT_RATE = 0.1\nWAIT_TIME = 15\nMOON_START_PROPORTION = 0.25\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        earth = Dot(radius=EARTH_RADIUS, color=BLUE)\n        self.add(earth)\n\n        # Moon\n        moon_orbit_path = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.5)\n        self.add(moon_orbit_path)\n\n        moon = Dot(radius=MOON_RADIUS, color=GREY)\n        moon.move_to(moon_orbit_path.point_from_proportion(MOON_START_PROPORTION))\n\n        # Moon orbit\n        orbit_val = ValueTracker(MOON_START_PROPORTION)\n\n        def orbit(m):\n            proportion = (orbit_val.get_value() * MOON_ORBIT_RATE) % 1\n            m.move_to(moon_orbit_path.point_from_proportion(proportion))\n        moon.add_updater(orbit)\n\n        self.add(moon)\n\n        # Earth-Moon connection\n        earth_moon_line = Line(earth.get_center(), moon.get_center(), stroke_width=2, color=WHITE)\n\n        def update_line(line):\n            line.put_start_and_end_on(earth.get_center(), moon.get_center())\n        earth_moon_line.add_updater(update_line)\n\n        self.add(earth_moon_line)\n\n        # Animate\n        self.play(orbit_val.set_value, 1, run_time=WAIT_TIME, rate_func=linear)"
  },
  {
    "text": "from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        text = Text(\"Original Text\").to_edge(UP)\n        self.add(text)\n        self.play(Transform(text, Text(\"Transformed Text\").to_edge(DOWN)), run_time=1)\n        square = Square()\n        self.play(GrowFromPoint(square, point=ORIGIN))\n        self.remove(square)"
  },
  {
    "text": "from manim import *\n\nclass ConcentricCirclesScene(Scene):\n    def construct(self):\n        circles = VGroup(*[\n            Circle(radius=i*0.2, stroke_width=15 - i*2, stroke_opacity=0.5).set_color(color=[RED, BLUE])\n            for i in range(1, 15)\n        ])\n        circles.arrange_in_grid(rows=1)\n        self.play(Create(circles), run_time=3)\n        self.wait(1)\n        self.play(circles.animate.shift(UP * 2), run_time=1)\n        self.play(circles.animate.scale(0.5), run_time=1)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass MultipleWavesScene(Scene):\n    def construct(self):\n        wave_list = [Wave(frequency=i, amplitude=0.5) for i in range(1, 5)]\n        waves_group = VGroup(*wave_list).arrange(DOWN, buff=0.5).move_to(ORIGIN)\n        self.add(waves_group)\n        self.play(*[wave.create_wave() for wave in wave_list])\n        self.wait(4)"
  },
  {
    "text": "from manim import *\n\nclass CoupledPendulumScene(Scene):\n    def construct(self):\n        # Create two pendulums\n        pendulum1 = Pendulum(\n            initial_theta=PI / 6,\n            length=3,\n            bob_radius=0.2,\n            color=RED,\n        )\n        pendulum2 = Pendulum(\n            initial_theta=-PI / 6,\n            length=3,\n            bob_radius=0.2,\n            color=BLUE,\n        )\n\n        # Position second pendulum\n        pendulum2.shift(RIGHT * pendulum1.length)\n\n        # Create a spring connecting the two pendulums\n        spring = Spring(\n            body_a=pendulum1.bob,\n            body_b=pendulum2.bob,\n            color=YELLOW\n        )\n\n        # Add pendulums and spring to the scene\n        self.add(pendulum1, pendulum2, spring)\n\n        # Animate pendulums swinging and spring reacting\n        self.play(\n            MoveAlongPath(pendulum1.bob, pendulum1.create_arc_trajectory()),\n            MoveAlongPath(pendulum2.bob, pendulum2.create_arc_trajectory()),\n            rate_func=there_and_back,\n            run_time=3\n        )\n\n        # Keep the scene displayed\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass DiceRollSimulation(Scene):\n    def construct(self):\n        die_face = 0\n        roll_counts = [0] * 6  # List to hold counts of each face\n        roll_count_text = [\n            always_redraw(lambda i=i: Text(f\"{roll_counts[i]}\").next_to(die_face_mob, DOWN).shift(RIGHT * (i - 2.5) * 0.6))\n            for i in range(6)\n        ]\n\n        die_face_mob = Square(side_length=1)\n        die_face_label = always_redraw(lambda: Text(str(die_face)).move_to(die_face_mob.get_center()))\n        die_face_group = VGroup(die_face_mob, die_face_label)\n\n        self.add(die_face_group)\n        self.add(*roll_count_text)\n\n        for i in range(6):\n            self.play(FadeIn(roll_count_text[i]))\n\n        for _ in range(100):\n            die_face = random.randint(1, 6)\n            roll_counts[die_face - 1] += 1\n            self.play(\n                Transform(die_face_label, Text(str(die_face)).move_to(die_face_mob.get_center())),\n                run_time=0.1\n            )\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PieChartScene(Scene):\n    def construct(self):\n        pie_chart = PieChart(\n            values=[30, 45, 25],\n            colors=[RED, GREEN, BLUE],\n            radius=2,\n            labels=[\"Red\", \"Green\", \"Blue\"],\n            pie_slice_colors=[RED, GREEN, BLUE],\n            start_angle=90,\n            slice_spacing=0.02\n        )\n\n        percentages = pie_chart.get_percentages()\n\n        for percent, label in zip(percentages, pie_chart.labels):\n            label.next_to(percent, UP)\n\n        self.add(pie_chart)\n        self.play(\n            AnimationGroup(\n                *[Write(label) for label in pie_chart.labels],\n                lag_ratio=0.5\n            )\n        )"
  },
  {
    "text": "class ColorChangingCircles(Scene):\n    def construct(self):\n        def update_color(circle, dt):\n            color = color_gradient([BLUE, GREEN, YELLOW, RED], dt % 1)\n            circle.set_fill(color, opacity=0.5)\n\n        circle_group = VGroup(*[Circle(radius=0.2 + i * 0.1).shift(i * 0.3 * RIGHT) for i in range(10)])\n        self.add(circle_group)\n        self.play(AnimationGroup(*[UpdateFromFunc(circle, update_color) for circle in circle_group], lag_ratio=0.1))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([\n            \"#f55e61\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\"\n        ])\n\n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n        \n        squares = VGroup()\n        for index, number in enumerate(fib_numbers[2:]):\n            color = next(colors)\n            square = Square(side_length=number).set_stroke(color, width=3).set_fill(color, opacity=0.5)\n            squares.add(square)\n        \n        squares.arrange_in_grid(buf=0)\n        center_of_spiral = squares.get_center()\n        \n        self.play(AnimationGroup(*[FadeIn(square, shift=0.5*UP) for square in squares], lag_ratio=0.2))\n        self.wait()\n        \n        arcs = VGroup()\n        for s1, s2 in zip(squares[:-1], squares[1:]):\n            angle = 90 * DEGREES if s2.get_y() < s1.get_y() else -90 * DEGREES\n            radius = abs(s1.get_width() - s2.get_width()) / 2\n            arc = Arc(radius=radius, angle=angle, arc_center=s1.get_center())\n            arc.move_arc_center_to(s1.get_center())\n            arcs.add(arc)\n        \n        arcs.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)\n        self.play(AnimationGroup(*[ShowCreation(arc) for arc in arcs], lag_ratio=0.4))\n        self.wait()\n\n        last_square = squares[-1]\n        circles = VGroup()\n        for n in fib_numbers[2:]:\n            circle = Circle(radius=n/2).set_stroke(BLACK, width=3)\n            circle.move_to(last_square)\n            last_square = circle\n            circles.add(circle)\n        \n        self.play(AnimationGroup(*[FadeIn(circle) for circle in circles], lag_ratio=0.7))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicArithmeticScene(Scene):\n    def construct(self):\n        # Define colors\n        background_color = WHITE\n        text_color = BLACK\n        operation_color = BLUE\n\n        # Set background color\n        self.camera.background_color = background_color\n\n        # Create equation parts\n        first_number = MathTex(\"3\", color=text_color).scale(2)\n        second_number = MathTex(\"2\", color=text_color).scale(2)\n        result_number = MathTex(\"6\", color=text_color).scale(2)\n        times_sign = MathTex(\"\\\\times\", color=operation_color).scale(2)\n\n        # Arrange equation on the screen\n        equation = VGroup(first_number, times_sign, second_number).arrange(RIGHT)\n        equals_sign = MathTex(\"=\", color=operation_color).scale(2)\n        equals_sign.next_to(equation, RIGHT)\n        result_number.next_to(equals_sign, RIGHT)\n\n        # Animate equation parts\n        self.play(Write(equation), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(equals_sign), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(result_number), run_time=0.5)\n\n        # Highlight the operation\n        highlight_rect = SurroundingRectangle(times_sign, color=operation_color)\n        self.play(Create(highlight_rect))\n        self.wait(0.5)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(equation, equals_sign, result_number, highlight_rect)), run_time=0.7)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PieChartExample(Scene):\n    def construct(self):\n        colors = [BLUE_D, GREEN_D, YELLOW_D, RED_D, PURPLE_D, ORANGE_D, PINK_D]\n        data = {'Blueberry': 60, 'Green Apple': 10, 'Lemon': 30, 'Watermelon': 20, 'Grape': 15, 'Orange': 50, 'Strawberry': 25}\n        pie_chart = PieChart(values=data.values(), radius=1.5, colors=colors, labels=data.keys(), label_font_size=24, stroke_width=1)\n        \n        legends = pie_chart.get_legend()\n        legends.scale(0.5).to_corner(UR, buff=0.5).shift(LEFT * 0.5)\n        \n        self.play(Create(pie_chart), run_time=1)\n        self.play(FadeIn(legends), run_time=1)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SineWaveApproximation(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 10, 1], y_range=[-2, 2, 1])\n        sine_curve = axes.plot(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(axes), Create(sine_curve))\n        self.wait(1)\n\n        text = MathTex(r\"\\text{Sine wave approximation with polynomials}\")\n        text.to_edge(UP)\n        self.play(Write(text))\n        self.wait(1)\n\n        polynomial_curve = axes.plot(lambda x: x - (x**3)/6, color=GREEN)\n        self.play(Create(polynomial_curve))\n        self.wait(1)\n\n        dot_at_pi = Dot(color=RED).move_to(axes.c2p(np.pi, np.sin(np.pi)))\n        self.play(FadeIn(dot_at_pi))\n        self.wait(1)\n\n        line_approx = DashedLine(start=axes.c2p(np.pi, 0), end=axes.c2p(np.pi, np.sin(np.pi)), color=YELLOW)\n        self.play(Create(line_approx))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = [\n            \"#f55e61\",\n            \"#5fcb50\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\",\n            \"#34a853\",\n            \"#bf2626\",\n            \"#3333FF\",\n            \"#b3a77d\",\n            \"#b85842\"\n        ]\n        \n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n\n        squares = VGroup()\n        for index, fib_num in enumerate(fib_numbers[2:]):\n            square = Square(\n                side_length=fib_num,\n                color=colors[index % len(colors)],\n                fill_opacity=0.5\n            )\n            squares.add(square)\n        \n        spirals = VGroup()\n        start_point = ORIGIN\n        angle = 0\n        for index, square in enumerate(squares):\n            square.move_to(start_point)\n            spirals.add(Arc(\n                start_angle=angle,\n                angle=TAU/4,\n                radius=square.side_length/2,\n                color=colors[index % len(colors)]\n            ).move_arc_center_to(start_point))\n            if index % 4 == 0:\n                start_point += square.side_length * RIGHT / 2\n                start_point += squares[index - 1].side_length * UP / 2 if index > 0 else ORIGIN\n                angle += TAU / 4\n            elif index % 4 == 1:\n                start_point += square.side_length * UP / 2\n                start_point += squares[index - 1].side_length * LEFT / 2\n                angle += TAU / 4\n            elif index % 4 == 2:\n                start_point += square.side_length * LEFT / 2\n                start_point += squares[index - 1].side_length * DOWN / 2\n                angle += TAU / 4\n            else:\n                start_point += square.side_length * DOWN / 2\n                start_point += squares[index - 1].side_length * RIGHT / 2\n                angle += TAU / 4\n\n        fibonacci_spiral = VGroup(squares, spirals).move_to(ORIGIN)\n        self.play(Create(fibonacci_spiral), run_time=4)\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass GrowingCircles(Scene):\n    def construct(self):\n        circle_array = VGroup(*[Circle(radius=i*0.3, color=BLUE, fill_opacity=0.5) for i in range(1, 6)])\n        circle_array.arrange_in_grid(rows=1, buff=1)\n        self.play(AnimationGroup(*(GrowFromCenter(circle) for circle in circle_array), lag_ratio=0.5))\n        self.wait(1)\n\n        for i in range(len(circle_array) - 1, 0, -1):\n            circle_to_swap = circle_array[i - 1]\n            self.play(\n                circle_array[i].animate.move_to(circle_to_swap.get_center()),\n                circle_to_swap.animate.move_to(circle_array[i].get_center()),\n                run_time=0.5\n            )\n            circle_array[i - 1], circle_array[i] = circle_array[i], circle_array[i - 1]\n            self.wait(0.1)\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TorusKnot(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        torus_knot = ParametricFunction(\n            lambda t: np.array([\n                (2 + np.cos(3 * t)) * np.cos(2 * t),\n                (2 + np.cos(3 * t)) * np.sin(2 * t),\n                np.sin(3 * t)\n            ]),\n            t_range=np.array([0, 2*PI]),\n            color=BLUE\n        )\n        self.play(Create(torus_knot))\n        self.begin_ambient_camera_rotation(rate=0.5)  # Start rotating the camera\n        self.wait(6)"
  },
  {
    "text": "from manim import *\n\nclass IntroScene(Scene):\n    def construct(self):\n        # Create a text title\n        title = Text(\"Welcome to Manim\").scale(1.5).to_edge(UP)\n\n        # Different geometry shapes\n        square = Square(color=YELLOW).to_edge(LEFT)\n        circle = Circle(color=GREEN).next_to(square, RIGHT)\n        triangle = Triangle(color=BLUE).next_to(circle, RIGHT)\n\n        # Add title and shapes to the scene\n        self.play(Write(title))\n        self.play(ShowCreation(square), ShowCreation(circle), ShowCreation(triangle))\n        self.wait(1)\n\n        # Animate transformation of shapes into a single dot\n        dot = Dot().move_to(square.get_center())\n        self.play(Transform(square, dot), Transform(circle, dot.copy()), Transform(triangle, dot.copy()))\n        self.wait(1)\n\n        # Transform the dot into a text message\n        end_text = Text(\"Let's learn Manim!\").next_to(dot, DOWN)\n\n        self.play(Transform(dot, end_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass HappyNewYearScene(Scene):\n    def construct(self):\n        background = Rectangle(width=FRAME_WIDTH, height=FRAME_HEIGHT)\n        background.set_fill(BLACK, 1)\n        self.add(background)\n\n        message = Text(\"Happy New Year 2023!\", font_size=72)\n        message.set_color_by_gradient([BLUE, GREEN])\n        self.play(Write(message))\n        self.wait(1)\n\n        fireworks = VGroup()\n\n        for i in range(5):\n            color = random.choice([RED, YELLOW, GREEN, BLUE, PURPLE])\n            firework = self.create_firework(3 * RIGHT * np.random.uniform(-3, 3)\n                + 3 * UP * np.random.uniform(0, 2), color)\n            fireworks.add(firework)\n\n        self.play(LaggedStart(*fireworks, lag_ratio=0.7))\n        self.wait(2)\n\n    def create_firework(self, position, color):\n        sparks = VGroup()\n        for _ in range(20):\n            angle = TAU * np.random.random()\n            velocity = np.random.uniform(0.5, 3)\n            spark = ParametricFunction(\n                lambda t: position + np.array([np.cos(angle), np.sin(angle), 0]) * t * velocity,\n                t_min=0,\n                t_max=0.5,\n                fill_opacity=0,\n            ).set_color(color).set_stroke(width=0.2)\n            sparks.add(spark)\n\n        return Write(sparks, run_time=1, rate_func=linear)"
  },
  {
    "text": "from manim import *\nimport numpy as np\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.pooling import PoolingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define the neural network structure\n        nn = NeuralNetwork([\n            Convolutional2DLayer(\n                num_feature_maps=16,\n                feature_map_size=5,\n                kernel_size=3,\n                stride=1,\n                padding='same',\n                activation='relu'\n            ),\n            PoolingLayer(\n                pool_size=2,\n                stride=2,\n                pooling_type='max',\n            ),\n            Convolutional2DLayer(\n                num_feature_maps=32,\n                feature_map_size=5,\n                kernel_size=3,\n                stride=1,\n                padding='valid',\n                activation='relu',\n            ),\n            PoolingLayer(\n                pool_size=2,\n                stride=2,\n                pooling_type='max',\n            ),\n            FeedForwardLayer(120),\n            FeedForwardLayer(10)\n        ])\n        \n        # Place the neural network on the scene\n        nn.move_to(ORIGIN)\n        \n        # Create animations\n        neural_network_intro = Create(nn)\n        \n        # Play animations\n        self.play(neural_network_intro)\n        self.wait()\n        \n        # Show the forward pass through the neural network\n        forward_pass_anim = nn.make_forward_pass_animation()\n        self.play(forward_pass_anim)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([RED, BLUE, GREEN, YELLOW, PURPLE])\n\n        # Create a list to hold Fibonacci numbers and add the first two\n        fib_numbers = [0, 1]\n        for _ in range(5):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n\n        squares = VGroup()\n        for index, value in enumerate(fib_numbers[2:]):\n            # Create a square with side length corresponding to a Fibonacci number\n            square = Square(side_length=value)\n            square.set_stroke(width=2)\n            square.set_fill(next(colors), opacity=0.5)\n\n            # Position the square based on index\n            if index % 4 == 0:\n                square.next_to(squares, UP, buff=0)\n            elif index % 4 == 1:\n                square.next_to(squares, RIGHT, buff=0)\n            elif index % 4 == 2:\n                square.next_to(squares, DOWN, buff=0)\n            elif index % 4 == 3:\n                square.next_to(squares, LEFT, buff=0)\n\n            squares.add(square)\n\n        # Draw the Fibonacci spiral using quarter-circles inside the squares\n        spiral = VMobject()\n        for i, square in enumerate(squares):\n            angle_start = i * PI / 2  # Start angle of each quarter-circle\n            arc = Arc(radius=square.side_length / 2,\n                      start_angle=angle_start,\n                      angle=PI/2)\n            arc.move_arc_center_to(square.get_corner(UP + RIGHT) +\n                                   RotateVector(square.side_length/2 * DOWN, angle_start))\n            spiral.add(arc)\n\n        spiral.set_color_by_gradient(BLUE, GREEN)\n\n        # Group squares and spiral for easier handling\n        fib_spiral = VGroup(squares, spiral)\n\n        # Animate\n        self.play(LaggedStart(*[DrawBorderThenFill(sq) for sq in squares], lag_ratio=0.5))\n        self.play(ShowCreation(spiral), run_time=4)\n        self.wait(2)\n\n        # Center the whole group of squares and spiral on the screen\n        self.play(fib_spiral.animate.to_edge(UP, buff=1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        square = Square(color=PURPLE)\n        trace_path = TracedPath(square.get_center)\n        self.add(square, trace_path)\n        self.play(square.animate.shift(RIGHT*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(UP*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(LEFT*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(DOWN*3), run_time=2)\n        self.remove(square, trace_path)"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define neural network architecture\n        architecture = [\n            {\"layer_type\": \"Input\", \"units\": 784},  # 28x28 pixels input image\n            {\"layer_type\": \"Dense\", \"units\": 128, \"activation\": \"relu\"},\n            {\"layer_type\": \"Dense\", \"units\": 64, \"activation\": \"relu\"},\n            {\"layer_type\": \"Output\", \"units\": 10, \"activation\": \"softmax\"}\n        ]\n\n        # Create a VGroup to hold neural network layers\n        nn_layers = VGroup()\n        layer_spacing = 0.5\n\n        # Create neural network layers based on architecture and add to VGroup\n        for index, layer_info in enumerate(architecture):\n            layer_text = f\"{layer_info['layer_type']}\\\\n{layer_info['units']}\"\n            if \"activation\" in layer_info:\n                layer_text += f\"\\\\n{layer_info['activation']}\"\n            layer = Rectangle(height=1, width=2)\n            layer_text = Text(layer_text, font_size=24)\n            layer_group = VGroup(layer, layer_text)\n            layer_group.arrange(DOWN)\n            \n            # Position each layer\n            if index > 0:\n                layer_group.next_to(nn_layers, RIGHT, buff=layer_spacing)\n            \n            nn_layers.add(layer_group)\n        \n        # Center the entire neural network on screen\n        nn_layers.move_to(ORIGIN)\n\n        # Animate the creation of the neural network\n        self.play(LaggedStart(*[Create(layer) for layer in nn_layers], lag_ratio=0.2))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        # Create a square and make it move in a circular path\n        square = Square(color=BLUE_C)\n        square.add_updater(lambda mobj, dt: mobj.rotate(dt).shift(RIGHT*dt))\n\n        # Create a traced path for the square\n        traced_path = TracedPath(square.get_center, stroke_width=6, stroke_color=YELLOW)\n\n        # Add the square and the traced path to the scene\n        self.add(square, traced_path)\n\n        # Play the animation for a few seconds\n        self.wait(4)\n\n        # Cease the rotation and movement\n        square.clear_updaters()\n\n        # Wait a bit before finishing\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n\nclass SineWaveOnComplexPlane(ComplexPlane):\n    def get_sine_wave_dots(self):\n        input_dot = Dot(color=GREEN)\n        output_dot = always_redraw(lambda: Dot(point=self.n2p(np.sin(self.p2n(input_dot.get_center()))),\n                                               color=BLUE))\n        return input_dot, output_dot\n\n\nclass SineWaveAnimation(Scene):\n    def construct(self):\n        complex_plane = SineWaveOnComplexPlane()\n        complex_plane.add_coordinates()\n        self.add(complex_plane)\n\n        input_dot, output_dot = complex_plane.get_sine_wave_dots()\n        input_dot.move_to(complex_plane.n2p(0))\n\n        wave_path = TracedPath(output_dot.get_center, stroke_color=RED, min_distance_to_new_point=0.1)\n\n        self.add(input_dot, output_dot, wave_path)\n\n        self.play(input_dot.animate.shift(RIGHT*PI*2), run_time=5, rate_func=linear)\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#fdf1db\"\nTEXT_COLOR = \"#2b2b2b\"\nLIGHT_YELLOW_COLOR = \"#f7dc5c\"\nLIGHT_GREEN_COLOR = \"#7bd389\"\nLIGHT_BLUE_COLOR = \"#85a3e0\"\nLIGHT_ORANGE_COLOR = \"#ff9f40\"\nLIGHT_PURPLE_COLOR = \"#b78be0\"\n\ndef ease_in_out_quad(t):\n    return 2 * t * t if t < 0.5 else -1 + (4 - 2 * t) * t\n\ndef LucasNumberSquare(size, color):\n    rect = Rectangle(width=size, height=size, color=color, fill_opacity=0.5)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale_to_fit_width(min(0.8 * size, 3))\n    text.move_to(rect.get_center())\n\n    return Group(rect, text)\n\nclass LucasSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            LIGHT_YELLOW_COLOR,\n            LIGHT_GREEN_COLOR,\n            LIGHT_BLUE_COLOR,\n            LIGHT_ORANGE_COLOR,\n            LIGHT_PURPLE_COLOR\n        ]\n        sequence = [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n        squares = VGroup()\n        positions = [UP, RIGHT, DOWN, LEFT]\n        current_position = 3 * LEFT + 2 * UP\n\n        for i, number in enumerate(sequence):\n            color = colors[i % len(colors)]\n            square = LucasNumberSquare(number, color)\n            square.move_to(current_position)\n            squares.add(square)\n\n            if i != 0:\n                move_direction = positions[i % 4]\n                current_position += (sequence[i - 1] + number / 2) * move_direction\n\n        for i, square in enumerate(squares):\n            self.play(\n                FadeIn(square[0], run_time=0.5),\n                Write(square[1]),\n                rate_func=ease_in_out_quad\n            )\n            self.wait(0.1)\n\n        spiral_start = squares[0].get_center()\n        arm_length = 0.5\n        spiral = VMobject(color=TEXT_COLOR)\n        spiral.set_points_as_corners([spiral_start, spiral_start + RIGHT * arm_length])\n\n        for i in range(1, len(sequence)):\n            arm_length += sequence[i - 1]\n            direction = positions[(i - 1) % 4]\n            new_corner = spiral.points[-1] + direction * arm_length\n            spiral.add_points_as_corners([new_corner])\n\n            self.play(\n                ShowCreation(spiral),\n                run_time=1,\n                rate_func=linear,\n            )\n\n        self.wait(2)\n\n        self.play(\n            *[FadeOut(mobj) for mobj in self.mobjects],\n            run_time=1.5\n        )\n"
  },
  {
    "text": "from manim import *\n\nclass SimplePendulum(Scene):\n    def construct(self):\n        pendulum_length = 3\n        circle_radius = 0.2\n        pendulum_color = BLUE\n        \n        pivot_point = UP * 2\n        pendulum_end = pivot_point + DOWN * pendulum_length\n        pendulum_rod = Line(pivot_point, pendulum_end, stroke_width=3)\n        pendulum_bob = Circle(radius=circle_radius, color=pendulum_color).shift(pendulum_end)\n        \n        pendulum = VGroup(pendulum_rod, pendulum_bob)\n        \n        initial_angle = PI / 6\n        pendulum.rotate(initial_angle, about_point=pivot_point)\n        \n        self.add(pendulum_rod, pendulum_bob)\n        self.wait(0.5)\n        \n        for _ in range(3):\n            self.play(SwingFromSide(pendulum, initial_angle, about_point=pivot_point, rate_func=there_and_back_with_pause))\n            self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nHIGHLIGHT_COLOR = \"#f08a5d\"\n\nconfig.background_color = BACKGROUND_COLOR\n\nclass PrimeFactors(Scene):\n    def construct(self):\n        title = Text(\"Fatores Primos\", color=TEXT_COLOR).to_edge(UP)\n\n        number = Text(\"60 = 2 x 2 x 3 x 5\", color=TEXT_COLOR).next_to(title, DOWN)\n        factors = VGroup(\n            Text(\"2,\", color=HIGHLIGHT_COLOR),\n            Text(\"2,\", color=HIGHLIGHT_COLOR),\n            Text(\"3,\", color=HIGHLIGHT_COLOR),\n            Text(\"5\", color=HIGHLIGHT_COLOR),\n        )\n        factors.arrange(RIGHT, buff=0.2).next_to(number, DOWN)\n\n        braces = Brace(factors, DOWN, color=TEXT_COLOR)\n        braces_text = braces.get_text(\"Fatores Primos\", color=TEXT_COLOR)\n\n        self.add(title)\n        self.play(Write(number))\n        self.play(ReplacementTransform(number.copy(), factors))\n        self.play(GrowFromCenter(braces), Write(braces_text))\n        self.wait(2)"
  },
  {
    "text": "self.play(Transform(text, Text(\"Fade In\").shift(UP*2.0)), run_time=0.5)\ncircle = Circle()\nself.play(FadeIn(circle))\nself.play(Transform(text, Text(\"Fade Out\").shift(UP*2.0)), run_time=0.5)\nself.play(FadeOut(circle))"
  },
  {
    "text": "from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        square = Square()\n        animated_boundary = AnimatedBoundary(square, colors=[PURPLE, TEAL, YELLOW], cycle_rate=2)\n        self.add(square, animated_boundary)\n        self.play(ScaleInPlace(square, 1.5), run_time=2)\n        self.wait(1)\n        self.play(Rotate(square, PI/2), run_time=2)\n        self.wait(1)\n        self.remove(animated_boundary) # Remove only boundary to freeze on last color\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\n# Define colors used in the animation\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#ffffff\"\nHIGHLIGHT_COLOR = \"#ff6666\"\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PrimeNumberScene(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        # Create a title text\n        title = Text(\"Prime Numbers\", color=TEXT_COLOR).scale(1.5)\n\n        # Create a list of prime numbers\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        primes_text = VGroup(\n            *[Text(str(prime), color=HIGHLIGHT_COLOR).scale(0.7) for prime in primes]\n        ).arrange_in_grid(cols=5, buff=0.8).next_to(title, DOWN)\n\n        # Display the title and then the prime numbers\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(AnimationGroup(*[FadeIn(number) for number in primes_text], lag_ratio=0.1))\n        self.wait(2)\n        \n        # Emphasize each prime number sequentially\n        for number in primes_text:\n            self.play(number.animate.set_color(HIGHLIGHT_COLOR))\n            self.wait(0.4)\n        \n        # Fade out the entire scene\n        self.play(FadeOut(VGroup(title, primes_text)))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=BLUE, fill_opacity=0.5),\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=GREEN, fill_opacity=0.5),\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=RED, fill_opacity=0.5),\n        )\n        # Arrange layers vertically with a specified distance between them\n        layers.arrange(DOWN, buff=0.5)\n\n        # Add layer labels\n        for i, layer in enumerate(layers):\n            label = Text(f\"Layer {i+1}\", color=WHITE).scale(0.5)\n            label.move_to(layer.get_center())\n            layer.add(label)\n\n        # Create arrows between layers\n        arrows = VGroup()\n        for i in range(len(layers) - 1):\n            arrow = Arrow(start=layers[i].get_bottom(), end=layers[i+1].get_top(), buff=0.1)\n            arrows.add(arrow)\n\n        # Create the full neural network diagram and move it to the center\n        neural_net = VGroup(layers, arrows)\n        neural_net.move_to(ORIGIN)\n\n        # Animation\n        self.play(FadeIn(neural_net, shift=UP))\n        self.wait(1)\n        self.play(Transform(layers[0], layers[0].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n        self.play(Transform(layers[1], layers[1].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n        self.play(Transform(layers[2], layers[2].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n\n        # Fade out animation\n        self.play(FadeOut(neural_net, shift=DOWN))"
  },
  {
    "text": "from manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLUE).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLUE).scale(2),\n        ).arrange(RIGHT, buff=2)\n\n        equals_sign = MathTex(r\"=\", color=WHITE).scale(2)\n        equals_sign.next_to(fractions[0], RIGHT)\n\n        fractions.add(equals_sign)\n\n        arrows = VGroup(\n            Arrow(fractions[0].get_bottom() + DOWN, fractions[1].get_bottom() + DOWN, color=GREEN),\n            Arrow(fractions[1].get_bottom() + DOWN, fractions[0].get_bottom() + DOWN, color=GREEN)\n        ).arrange(DOWN, buff=0.3)\n        arrows.next_to(fractions, DOWN, buff=0.5)\n\n        text = VGroup(\n            Tex(r\"Multiplicado por 2\", color=GREEN).scale(0.7),\n            Tex(r\"Dividido por 2\", color=GREEN).scale(0.7)\n        )\n        text[0].next_to(arrows[0], DOWN)\n        text[1].next_to(arrows[1], DOWN)\n\n        self.play(Write(fractions))\n        self.play(GrowFromCenter(arrows[0]), Write(text[0]))\n        self.play(GrowFromCenter(arrows[1]), Write(text[1]))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(fractions, arrows, text)))\n        self.wait(0.5)"
  },
  {
    "text": "from manim import *\n\nclass MObjectShowcase(Scene):\n    def construct(self):\n        title = Text(\"A Showcase of MObjects\").to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        mobject_grid = VGroup(*[\n            VGroup(\n                Square(),\n                Circle(),\n                Triangle(),\n                Annulus(),\n                Ellipse(),\n                Dot(),\n                Arrow(),\n                Star()\n            ),\n            VGroup(\n                Text(\"Text\"),\n                MathTex(r\"\\int_a^b f(x)\\,dx\"),\n                Integer(42),\n                DecimalNumber(3.14),\n                BulletedList(\"First\", \"Second\", \"Third\"),\n                Code(\"print('Hello, World!')\", language=\"Python\")\n            )\n        ]).arrange(DOWN, buff=LARGE_BUFF)\n        \n        for submobjects in mobject_grid:\n            submobjects.arrange(RIGHT, buff=LARGE_BUFF)\n        \n        mobject_grid.scale(0.5)\n        mobject_grid.move_to(ORIGIN)\n        \n        self.play(LaggedStart(*[FadeIn(mobj, shift=DOWN) for mobj in mobject_grid], lag_ratio=0.2))\n        self.wait(2)\n\n        self.play(LaggedStart(*[ApplyWave(mobj) for mobj in mobject_grid[0]], lag_ratio=0.2))\n        self.play(LaggedStart(*[Indicate(mobj) for mobj in mobject_grid[1]], lag_ratio=0.2))\n        self.wait()\n\n        self.play(FadeOut(mobject_grid), FadeOut(title))\n        self.wait()"
  },
  {
    "text": "class ShapeOverlay(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.7)\n        yellow_hexagon = RegularPolygon(n=6, color=YELLOW, fill_opacity=0.5)\n        yellow_hexagon.next_to(red_triangle, UP)\n        self.play(FadeIn(red_triangle), GrowFromCenter(yellow_hexagon))\n        self.wait(1)\n        self.play(FadeOut(red_triangle), ShrinkToPoint(yellow_hexagon, UP))"
  },
  {
    "text": "from manim import *\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-4, 4])\n        curve = axes.plot(lambda x: x**3 - 3*x, color=GREEN)\n        line = axes.plot(lambda x: 3*x - 3, color=RED)\n        dot = Dot(color=ORANGE).move_to(axes.c2p(1, -2))\n\n        tangent = always_redraw(lambda: TangentLine(curve, alpha=dot.get_center()[0], length=4, color=ORANGE))\n        \n        self.play(Create(axes), Create(curve))\n        self.play(Create(line))\n        self.add(dot, tangent)\n        self.play(MoveAlongPath(dot, curve), run_time=4, rate_func=linear)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        title = Text(\"Manim Wave Effects\").to_edge(UP)\n        self.play(Write(title))\n\n        subtitle = Text(\"Various wave animations\").next_to(title, DOWN)\n        self.play(Write(subtitle))\n\n        square_wave = Square().set_fill(BLUE, opacity=0.5)\n        self.play(FadeIn(square_wave))\n        self.play(ApplyWave(square_wave))\n        self.play(ApplyWave(square_wave, rate_func=linear))\n        self.play(ApplyWave(square_wave, amplitude=0.2))\n        \n        self.play(FadeOut(square_wave))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DampedOscillator(Scene):\n    def construct(self):\n        # Introduce the differential equation\n        ode = MathTex(r\"y'' + 2\\gamma y' + \\omega^2 y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Add an explanation for the type of equation\n        explanation1 = Text(\"Damped harmonic oscillator equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the characteristic equation\n        char_eq = MathTex(r\"r^2 + 2\\gamma r + \\omega^2 = 0\")\n        self.play(ReplacementTransform(ode.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solutions of the characteristic equation\n        explanation2 = Text(\"Characteristic equation solutions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = -\\gamma \\pm \\sqrt{\\gamma^2 - \\omega^2}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # Display the general solution\n        general_solution = MathTex(r\"y = e^{-\\gamma x}(C_1 \\cos(\\sqrt{\\omega^2 - \\gamma^2}x) + C_2 \\sin(\\sqrt{\\omega^2 - \\gamma^2}x))\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation3 = Text(\"General solution of the damped oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(explanation1), FadeOut(general_solution))\n        self.wait(1)\n\n        # Restate the general solution\n        final_solution = MathTex(r\"y = e^{-\\gamma x}(A \\cos(\\sqrt{\\omega^2 - \\gamma^2}x) + B \\sin(\\sqrt{\\omega^2 - \\gamma^2}x))\")\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral_x = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral_x))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral_x, middle_integral_y))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}z \\,dz\", r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1, shift=DOWN), FadeOut(final_solution, shift=DOWN))\n        self.wait(1)\n        conclusion = Text(\"The triple integral evaluates to 1/4\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x y z^2]_{0}^{3} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2} x y^2 z^2]_{0}^{2} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{3}{2} x^2 y^2 z^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for formal solution\n        explanation1 = Text(\"Consider a trial solution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Trial solution step\n        trial_solution = MathTex(r\"y = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(problem, trial_solution))\n        self.wait(1)\n\n        # Explanation for initial conditions\n        explanation2 = Text(\"Apply initial conditions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying initial conditions\n        initial_conditions = MathTex(r\"A = y(0), \\quad \\omega B = y'(0)\")\n        self.play(Write(initial_conditions))\n        self.wait(1)\n\n        # General solution with conditions\n        general_solution = MathTex(r\"y = y(0)\\cos(\\omega t) + \\frac{y'(0)}{\\omega}\\sin(\\omega t)\")\n        self.play(Transform(trial_solution, general_solution))\n        self.play(Transform(initial_conditions, MathTex(r\"\\text{for } y(0), y'(0) \\text{ given}\")))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        explanation3 = Text(\"Resulting harmonic oscillator solution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation3))\n        self.play(Write(general_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eqn = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eqn))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution format\n        explanation2 = Text(\"The general solution can be written as u(x, t) = F(x - ct) + G(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(wave_eqn, general_solution))\n        self.wait(1)\n\n        # Explanation for specific solutions\n        explanation3 = Text(\"Specific solutions are derived from initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying Trigonometric Substitution Problem\n        problem = MathTex(r\"\\int \\frac{1}{\\sqrt{1-x^2}} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Choosing a substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), dx = \\cos(\\theta) d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Showing substituted integral\n        substituted_integral = MathTex(r\"= \\int \\frac{\\cos(\\theta)}{\\sqrt{1-\\sin^2(\\theta)}} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplify the integral using pythagorean identity\n        simplified_integral = MathTex(r\"= \\int \\cos(\\theta) d\\theta\")\n        self.play(Transform(substituted_integral, simplified_integral))\n        self.wait(2)\n\n        # Solve the integral\n        integral_solution = MathTex(r\"= \\sin(\\theta) + C\")\n        self.play(Transform(simplified_integral, integral_solution))\n        self.wait(1)\n\n        # Back substitution\n        back_substitution = Text(\"Back substitute to get the answer in terms of x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, back_substitution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\arcsin(x) + C\")\n        self.play(Transform(integral_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Display the series to be calculated\n        series_problem = MathTex(r\"S = \\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for partial sums\n        explanation1 = Text(\"Use partial sums to approach the series' value\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Partial sum notation\n        partial_sum = MathTex(r\"S_N = \\sum_{n=1}^{N} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(series_problem, partial_sum))\n        self.wait(1)\n\n        # Representing the series with partial sums\n        partial_sum_example = MathTex(r\"S_5 = 1 + \\frac{1}{4} + \\frac{1}{9} + \\frac{1}{16} + \\frac{1}{25}\")\n        self.play(ReplacementTransform(partial_sum, partial_sum_example))\n        self.wait(2)\n\n        # Explanation for the known limit\n        explanation2 = Text(\"The series converges to a known value\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Series limit is pi squared over 6\n        series_solution = MathTex(r\"S = \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(partial_sum_example, series_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(series_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        substitution_explanation = MathTex(r\"x = \\sin(\\theta), \\, dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(explanation1))\n        self.play(Write(substitution_explanation))\n        self.wait(2)\n\n        # Substituting the values\n        substitution_step = MathTex(r\"= \\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta)d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substitution_step))\n        self.wait(2)\n\n        # Simplifying the integral\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta)d\\theta\")\n        self.play(ReplacementTransform(substitution_step, simplified_integral))\n        self.wait(2)\n\n        # Explanation for further steps\n        explanation2 = Text(\"Now integrate using a trigonometric identity\", font_size=24)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Writing the trigonometric identity\n        trig_identity = MathTex(r\"\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}\")\n        self.play(Write(trig_identity))\n        self.wait(2)\n\n        # Applying the identity\n        with_identity = MathTex(r\"= \\frac{1}{2} \\int (1+\\cos(2\\theta))d\\theta\")\n        self.play(ReplacementTransform(simplified_integral, with_identity))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} (\\theta + \\frac{1}{2}\\sin(2\\theta)) + C\")\n        self.play(ReplacementTransform(with_identity, final_solution))\n        self.wait(1)\n\n        # Convert back to x\n        back_to_x = MathTex(r\"= \\frac{1}{2} (\\arcsin(x) + \\frac{x\\sqrt{1-x^2}}{2}) + C\")\n        self.play(ReplacementTransform(final_solution, back_to_x))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(back_to_x))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Function\n        function = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_riemann_rectangles(function, x_range=[0, 2], dx=0.1, color=PURPLE, fill_opacity=0.5)\n\n        # Display axes and function\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n\n        # Show function and area under curve\n        self.play(Create(function))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Title of the action\n        title = Text(\"Area under the curve f(x) = x^2 from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_value = MathTex(r\"A = \\int_0^2 x^2 \\,dx\")\n        area_solution = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Write(area_value))\n        self.wait(1)\n        self.play(ReplacementTransform(area_value, area_solution))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(title), FadeOut(area_solution), FadeOut(area), FadeOut(function), FadeOut(axes), FadeOut(labels))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        wave_explanation = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(wave_explanation))\n        self.wait(2)\n\n        # General solution for the wave equation\n        wave_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, wave_solution))\n        self.wait(2)\n\n        # Explanation of general solution\n        solution_explanation = Text(\"The general solution can be expressed as two moving waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, solution_explanation))\n        self.wait(2)\n\n        # Displaying initial conditions\n        initial_conditions = MathTex(r\"u(x, 0) = f(x) + g(x)\", r\"\\quad\", r\"\\frac{\\partial u}{\\partial t}\\Big|_{t=0} = -cf'(x) + cg'(x)\")\n        initial_conditions_arranged = VGroup(initial_conditions[0], initial_conditions[2]).arrange(DOWN)\n        self.play(FadeOut(wave_solution), Write(initial_conditions_arranged))\n        self.wait(2)\n\n        # Boundary condition explanation\n        boundary_explanation = Text(\"The specific solution also depends on initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(solution_explanation, boundary_explanation))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The propagation speed is denoted by c.\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of demonstration\", font_size=36)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eqn = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eqn))\n        self.wait(1)\n\n        # Adding a subtext for the equation\n        subtext_eqn = Text(\"Classical wave equation\", font_size=24).next_to(wave_eqn, DOWN)\n        self.play(FadeIn(subtext_eqn))\n        self.wait(2)\n\n        # Introducing a specific solution form\n        solution_text = Text(\"Consider a solution of the form:\", font_size=24).to_edge(UP)\n        self.play(Write(solution_text))\n        self.wait(1)\n\n        # Display the specific solution form\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eqn, specific_solution))\n        self.wait(2)\n\n        # Explain the constants\n        constants_expl = MathTex(r\"A =\", \" amplitude,\", r\"\\ k =\", \" wavenumber,\", r\"\\ \\omega =\", \" angular frequency\")\n        self.play(FadeIn(constants_expl))\n        self.wait(3)\n\n        # Transition to the general solution\n        general_solution = Text(\"General solutions are formed by combinations of these specific solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(solution_text, general_solution))\n        self.wait(2)\n\n        # Clear everything for last message\n        self.clear()\n        self.wait(1)\n        \n        # Display final message\n        final_message = Text(\"Thanks for watching!\", font_size=36)\n        self.play(FadeIn(final_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2}xy \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}x \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation of the type of PDE\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(pde, general_solution))\n        self.wait(2)\n\n        # Explanation of the general solution\n        explanation2 = Text(\"u(x, t) represents the displacement at point x and time t.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific solution with initial conditions\n        specific_solution = MathTex(r\"u(x, 0) = \\phi(x), \\quad \\frac{\\partial u}{\\partial t}(x, 0) = \\psi(x)\")\n        self.play(ReplacementTransform(general_solution, specific_solution))\n        self.wait(2)\n\n        # Explanation of specific solution\n        explanation3 = Text(\"The functions \u03c6 and \u03c8 represent the initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(specific_solution), FadeOut(explanation1))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The wave equation governs the propagation of waves.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate w.r.t. x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate w.r.t. y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate w.r.t. z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}z \\,dz\", r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Apply the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power rule step\n        power_step = MathTex(r\"\\int x^{n} \\,dx = \\frac{1}{n+1}x^{n+1} + C\")\n        self.play(ReplacementTransform(problem.copy(), power_step))\n        self.play(FadeOut(explanation1))\n        self.wait(1)\n\n        # Explanation for definite integration\n        explanation2 = Text(\"Calculate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Definite integral\n        definite_integral = MathTex(r\"\\left.\\frac{1}{n+1}x^{n+1} \\right|_0^1\")\n        self.play(ReplacementTransform(power_step, definite_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left.\\frac{1}{3}x^3 \\right|_0^1\", \"=\", \"\\frac{1}{3}\")\n        self.play(Transform(definite_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(Text(\"Area under the parabola from 0 to 1 is 1/3\", font_size=24)))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}z^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\frac{1}{2}x y z^2 \\Big|_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n        \n        # Explanation for second integral\n        explanation2 = Text(\"Next, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Second integral step\n        second_integral = MathTex(r\"= \\int_{0}^{1} \\frac{9}{2} y x^2 \\Big|_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, second_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= 9 \\int_{0}^{1} y^2 \\,dy\", r\"= 9 \\cdot \\frac{1}{3} y^3 \\Big|_{0}^{1}\", r\"= 3\")\n        self.play(ReplacementTransform(second_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[-1]))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the topic\n        title = Text(\"Fourier Series Decomposition\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Move title to the top\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Displaying the Fourier series formula for a periodic function f\n        fourier_series_formula = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left[a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right)\\right]\"\n        )\n        self.play(Write(fourier_series_formula))\n        self.wait(2)\n\n        # Explanation of the components of the formula\n        explanation1 = Text(\n            \"Here, P is the period of function f.\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\n            \"The coefficients a_0, a_n, and b_n are calculated using integrals.\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Example of calculating a coefficient\n        coefficient_calculation = MathTex(\n            r\"a_n = \\frac{2}{P} \\int_{0}^{P} f(x) \\cos\\left(\\frac{2\\pi nx}{P}\\right)dx\"\n        )\n        self.play(ReplacementTransform(fourier_series_formula, coefficient_calculation))\n        self.wait(2)\n\n        # The importance of the Fourier series in signal processing\n        importance_text = Text(\n            \"Fourier series play a crucial role in signal processing and electrical engineering.\",\n            font_size=24\n        ).next_to(coefficient_calculation, DOWN)\n        self.play(Write(importance_text))\n        self.wait(2)\n\n        # Clean up the scene\n        self.clear()  # Clear the screen\n        self.wait(1)\n\n        # Conclusion with the Fourier series formula displayed again\n        self.play(Write(fourier_series_formula))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function_tex = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation of the integral bounds\n        bounds_explanation = Text(\"We'll find the area from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(bounds_explanation))\n        self.wait(2)\n\n        # Integration process\n        integration_process = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(function_tex.copy(), integration_process))\n        self.wait(1)\n\n        # Explanation of evaluating the bounds\n        evaluation_explanation = Text(\"Place the bounds into the antiderivative\", font_size=24).to_edge(UP)\n        self.play(Transform(bounds_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Display the result of the integration\n        result = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_process, result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with final answer\n        self.play(Write(result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the fundamental theorem of calculus\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\").move_to(UP*2)\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= [\\frac{x^{3}}{3}]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Replacing with definite boundaries\n        boundaries_applied = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\")\n        self.play(ReplacementTransform(solution1, boundaries_applied))\n        self.wait(1)\n\n        # Explanation for calculating the result\n        explanation2 = Text(\"Calculate the result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 9 - \\frac{1}{3}\")\n        self.play(ReplacementTransform(boundaries_applied, final_result))\n        self.wait(2)\n\n        # Simplifying further\n        simplified_result = MathTex(r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(final_result, simplified_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final simplified result\n        self.play(Write(simplified_result))\n        self.wait(1)\n"
  },
  {
    "text": "from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the heat equation\n        equation = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for physical meaning\n        explanation1 = Text(\"The heat equation describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=DOWN))\n        self.wait(2)\n\n        # Example of a solution\n        example_solution = MathTex(r\"u(x, t) = \\frac{1}{\\sqrt{4 \\pi \\alpha t}} e^{-\\frac{x^2}{4 \\alpha t}}\")\n        self.play(Transform(equation, example_solution))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation2 = Text(\"This solution represents heat conduction in a rod as time progresses.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Discuss initial conditions\n        initial_conditions = Text(\"Initial and boundary conditions are crucial for specific solutions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, initial_conditions))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.play(FadeIn(equation, shift=UP))\n        self.wait(1)\n\n        # Display steady-state solution\n        steady_state = MathTex(r\"u(x) = ax + b\")\n        self.play(Transform(equation, steady_state))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Display the limits of integration\n        limits = MathTex(r\"[2^4/4, 3^4/4]\")\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        solution1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Simplifying the result\n        explanation2 = Text(\"Simplifying the result:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Further simplification\n        final_answer = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        wave_explanation = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(wave_explanation))\n        self.wait(2)\n        \n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n        \n        # Explanation for characteristics\n        characteristics = Text(\"The functions f and g represent waves traveling in opposite directions.\",\n                               font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, characteristics))\n        self.wait(2)\n\n        # Displaying a specific solution example\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(general_solution, specific_solution))\n        self.wait(1)\n\n        # Explanation for a specific solution\n        specific_explanation = Text(\"A specific solution can represent a sinusoidal wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, specific_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the specific solution again to conclude\n        self.play(Write(specific_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int_{-1}^{1}\\int_{0}^{\\pi}\\int_{0}^{1} r^2 \\sin\\theta \\, dr\\,d\\theta\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation_r = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_r))\n        self.wait(2)\n\n        r_integral = MathTex(r\"= \\int_{-1}^{1}\\int_{0}^{\\pi} [ \\frac{r^3}{3} \\sin\\theta ]_{0}^{1} \\,d\\theta\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), r_integral))\n        self.wait(1)\n\n        explanation_theta = Text(\"Now integrate with respect to \\\\( \\\\theta \\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_r, explanation_theta))\n        self.wait(2)\n\n        theta_integral = MathTex(r\"= \\int_{-1}^{1} [ -\\frac{\\cos\\theta}{3} ]_{0}^{\\pi} \\,dz\")\n        self.play(ReplacementTransform(r_integral, theta_integral))\n        self.wait(1)\n\n        explanation_z = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_r, explanation_z))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= [ -\\frac{2z}{3} ]_{-1}^{1}\", r\"= -\\frac{2}{3} - \\left(-\\frac{2}{3} \\right)\", r\"= \\frac{4}{3}\")\n        self.play(ReplacementTransform(theta_integral, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        u_substitution = MathTex(r\"\\frac{1}{2}\\int e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), u_substitution))\n        self.wait(1)\n\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(u_substitution, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve_graph = self.get_graph()\n        area = self.get_area_under_curve(curve_graph)\n\n        # Show curve and shaded area as area under the curve\n        self.play(Create(curve_graph), Create(area))\n        self.wait(2)\n\n        # Show the label of the curve\n        label = self.get_curve_label(curve_graph)\n        self.play(Write(label))\n        self.wait(2)\n\n        # Explain the area under the curve\n        explanation = Text(\"Area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and show just the explanation\n        self.clear()\n        self.play(Write(explanation))\n        self.wait(2)\n\n    def get_graph(self):\n        return FunctionGraph(lambda x: x**2, color=BLUE, x_range=[0,2])\n\n    def get_area_under_curve(self, graph):\n        return area := graph.get_riemann_rectangles(x_range=[0,2], dx=0.1, stroke_width=0.1)\n\n    def get_curve_label(self, graph):\n        return MathTex(\"y = x^2\").next_to(graph, UP + RIGHT)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(2)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[1]))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the function\n        function_label = MathTex(r\"f(x) = x^2\").to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Plotting the function\n        graph = FunctionGraph(lambda x: x**2, x_range=[-2, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Specifying the area of interest\n        area_label = MathTex(r\"\\int_{0}^{1} x^2 \\,dx\").next_to(graph, DOWN)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Coloring the area under the curve\n        area = graph.get_area(x_range=[0, 1], color=[BLUE, GREEN], opacity=0.5)\n        self.play(DrawBorderThenFill(area))\n        self.wait(2)\n\n        # Calculating the area\n        area_solution = MathTex(r\"=\\dfrac{1}{3}\").to_edge(DOWN)\n        self.play(ReplacementTransform(area_label, area_solution))\n        self.wait(1)\n\n        # Clear the scene and show the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        integral_problem = MathTex(r\"\\iint_{S} (x^2 + y^2) dS\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        param_explanation = Text(\"Parametrize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(param_explanation))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (r\\sin\\phi\\cos\\theta, r\\sin\\phi\\sin\\theta, r\\cos\\phi)\")\n        self.play(ReplacementTransform(integral_problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the surface element\n        surf_elem_explanation = Text(\"Compute the surface element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(param_explanation, surf_elem_explanation))\n        self.wait(2)\n\n        # Surface element step\n        surface_element = MathTex(r\"dS = r^2\\sin\\phi d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, surface_element))\n        self.wait(1)\n\n        # Integrate problem converted\n        integrate_converted = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} (r^2\\sin^2\\phi) r^2\\sin\\phi d\\phi d\\theta\")\n        self.play(ReplacementTransform(surface_element, integrate_converted))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        solve_integral_explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(param_explanation, solve_integral_explanation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\\pi r^4 \\int_{0}^{\\pi} \\sin^3\\phi d\\phi\")\n        self.play(ReplacementTransform(integrate_converted, final_solution))\n        self.wait(1)\n\n        # Final result after integration\n        final_result = MathTex(r\"= \\frac{4}{3}\\pi r^4\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *_x000D_\n_x000D_\nclass QuadraticFormulaExample(Scene):_x000D_\n    def construct(self):_x000D_\n        # Displaying the quadratic equation_x000D_\n        equation = MathTex(\"ax^2 + bx + c = 0\")_x000D_\n        self.play(Write(equation))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Explanation for using the quadratic formula_x000D_\n        explanation1 = Text(\"Use the quadratic formula to solve for x\", font_size=24).to_edge(UP)_x000D_\n        self.play(Write(explanation1))_x000D_\n        self.wait(2)_x000D_\n_x000D_\n        # Showing the quadratic formula_x000D_\n        quadratic_formula = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{{b^2-4ac}}}}{{2a}}\")_x000D_\n        self.play(ReplacementTransform(equation, quadratic_formula))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Explanation for solution_x000D_\n        explanation2 = Text(\"Solve for roots\", font_size=24).to_edge(UP)_x000D_\n        self.play(Transform(explanation1, explanation2))_x000D_\n        self.wait(2)_x000D_\n_x000D_\n        # Possible solutions_x000D_\n        solutions = MathTex(r\"x_1 = \\frac{{-b + \\sqrt{{b^2-4ac}}}}{{2a}}\", \",\", _x000D_\n                            r\"x_2 = \\frac{{-b - \\sqrt{{b^2-4ac}}}}{{2a}}\")_x000D_\n        self.play(ReplacementTransform(quadratic_formula, solutions))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Clear the scene and conclude_x000D_\n        self.clear()_x000D_\n        self.wait(1)_x000D_\n        self.play(Write(Text(\"The solutions are x_1 and x_2\", font_size=24)))_x000D_\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Display the ODE\n        ode = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explain the main terms\n        mass_term_explanation = Text(\"This is the mass term\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(mass_term_explanation, shift=UP))\n        self.wait(2)\n        self.play(FadeOut(mass_term_explanation, shift=DOWN))\n\n        spring_term_explanation = Text(\"This is the spring constant term\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(spring_term_explanation, shift=UP))\n        self.wait(2)\n        self.play(FadeOut(spring_term_explanation, shift=DOWN))\n\n        # Form characteristic equation\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(Transform(ode, char_eq))\n        self.wait(1)\n\n        # Solve the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(ode, roots))\n        self.wait(1)\n\n        # General solution for harmonic oscillator\n        gen_solution = MathTex(r\"x(t) = C_1\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + C_2\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(gen_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation = Text(\"General solution for the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and animate the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(gen_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function\n        curve = lambda x: 0.1 * x ** 2\n        \n        # Plot the function\n        graph = Axes(\n            x_range=[-3, 3],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        ).get_graph(curve, color=GREEN)\n        \n        # Display the function\n        graph_label = graph.get_label(label='f(x) = 0.1x^2').shift(UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = graph.get_riemann_rectangles(x_range=[0, 2], dx=0.1, input_sample_type=\"center\", stroke_width=0.5, stroke_color=BLACK)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the definite integral\n        definite_integral = MathTex(r\"\\int_0^2 0.1x^2 \\,dx\")\n        definite_integral.to_edge(UP)\n        self.play(Write(definite_integral))\n        self.wait(1)\n\n        # Calculating the area\n        area_calculation = MathTex(r\"= [\\frac{1}{30} x^3]_0^2\")\n        area_calculation.next_to(definite_integral, DOWN)\n        self.play(Write(area_calculation))\n        self.wait(1)\n\n        # Show final result\n        final_result = MathTex(r\"= \\frac{1}{30} \\cdot 2^3 - \\frac{1}{30} \\cdot 0^3\", r\"= \\frac{8}{30}\", r\"= \\frac{4}{15}\")\n        final_result.next_to(area_calculation, DOWN)\n        self.play(Write(final_result))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final calculated area\n        self.add(graph, graph_label)\n        self.play(FadeIn(area), Write(final_result))\n        self.wait(3)\n"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for u-substitution\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting the substitution\n        subst_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"du = 2 \\,dx\", r\"\\quad\", r\"\\frac{1}{2}du = dx\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for the new integral form\n        explanation2 = Text(\"Rewrite the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Rewritten integral with u\n        rewritten_integral = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(subst_step, rewritten_integral))\n        self.wait(1)\n\n        # Explanation for integration result\n        explanation3 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(rewritten_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParabolaTangentExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y = x^2, \\, P(2, 4), \\, \\text{find the tangent at P}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Draw the graph\n        graph = FunctionGraph(lambda x : x**2, color=BLUE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Mark the point and tangent\n        point = Dot(ax.i2gp(2, graph), color=YELLOW)\n        label = MathTex(r\"P(2, 4)\").next_to(point, RIGHT)\n        tangent = Line(start=point.get_center() + LEFT*3, end=point.get_center() + RIGHT*3, color=GREEN)\n        self.add(point, label)\n        self.play(GrowFromCenter(tangent))\n        self.wait(2)\n\n        # Explanation for the derivative\n        explanation1 = Text(\"Use the derivative for the slope of the tangent\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"\\frac{d}{dx}(x^2) = 2x\")\n        self.play(Write(derivative_step))\n        self.wait(1)\n\n        # Slope at point P\n        slope_at_P = MathTex(r\"2x|_{x=2} = 4\")\n        self.play(Transform(derivative_step, slope_at_P))\n        self.wait(1)\n\n        # Equation of the tangent\n        tangent_eq = MathTex(r\"y - 4 = 4(x - 2)\")\n        self.play(Write(tangent_eq))\n        self.wait(1)\n\n        # Final tangent equation\n        final_tangent_eq = MathTex(r\"y = 4x - 4\")\n        self.play(ReplacementTransform(tangent_eq, final_tangent_eq))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_tangent_eq))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of Wave Equation\n        description = Text(\"This describes the propagation of waves.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying solution formula\n        solution_formula = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, solution_formula))\n        self.wait(2)\n\n        # Explanation of solution components\n        explanation = Text(\"f and g are arbitrary functions representing waveforms.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, explanation))\n        self.wait(2)\n\n        # Displaying a specific example\n        example_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(solution_formula, example_solution))\n        self.wait(1)\n\n        # Explanation of specific example\n        example_explanation = Text(\"This is a monochromatic plane wave.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, example_explanation))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(example_solution), FadeOut(description))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display Fourier Series definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n \\cos\\left(\\frac{2\\pi n x}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi n x}{P}\\right)\\right)\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Explanation about Fourier Series\n        explanation1 = Text(\n            \"A Fourier series is a way to represent a function as a sum of sinusoidal bases.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Specific example with a square wave\n        explanation2 = Text(\n            \"For example, a square wave can be approximated by a Fourier series.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Display the square wave approximation equation\n        square_wave_approx = MathTex(\n            r\"f(x) \\approx \\sum_{n=1,3,5}^{\\infty} \\frac{4}{n\\pi} \\sin\\left(\\frac{2\\pi n x}{P}\\right)\"\n        )\n        self.play(ReplacementTransform(fourier_series_def, square_wave_approx))\n        self.wait(2)\n\n        # Explanation for convergence\n        explanation3 = Text(\n            \"The series converges to the actual function as the number of terms increases.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(square_wave_approx))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Writing the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"A = \\int_{a}^{b} x^2 \\,dx\")\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Showing area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2], color=BLUE)\n        area = area = Integral(curve, (0, 2))\n        self.play(Create(curve))\n        self.play(Write(area))\n        self.wait(1)\n\n        # Calculating the integral\n        integral_calculation = MathTex(r\"A = \\frac{1}{3} x^3 \\Big|_a^b\")\n        self.play(Transform(area_problem, integral_calculation))\n        self.wait(1)\n\n        # Substitute the limits\n        limits_substituted = MathTex(r\"A = \\frac{1}{3} b^3 - \\frac{1}{3} a^3\")\n        self.play(ReplacementTransform(integral_calculation, limits_substituted))\n        self.wait(1)\n\n        # Displaying final answer\n        final_answer = MathTex(r\"A = \\frac{1}{3} (b^3 - a^3)\")\n        self.play(ReplacementTransform(limits_substituted, final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        ode = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Show the characteristic equation explanation\n        char_eq_expl = Text(\"Characteristic equation:\", font_size=24).to_edge(UP)\n        self.play(FadeIn(char_eq_expl))\n        self.wait(2)\n\n        # Write the characteristic equation\n        char_eq = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(Transform(ode, char_eq))\n        self.wait(2)\n\n        # Solve the characteristic equation\n        sol_expl = Text(\"Solve for r:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_expl, sol_expl))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = 1\")\n        self.play(Transform(ode, roots))\n        self.wait(2)\n\n        # Display the general solution to the ODE\n        general_sol = MathTex(r\"y = (C_1 + C_2 x + C_3 x^2) e^x\")\n        self.play(FadeOut(ode), FadeIn(general_sol))\n        self.wait(2)\n\n        # General solution explanation\n        gen_sol_expl = Text(\"General solution for the ODE:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_expl, gen_sol_expl))\n        self.wait(2)\n\n        # Conclude the scene\n        self.play(FadeOut(char_eq_expl), FadeOut(general_sol))\n        self.wait(1)\n        self.play(Write(general_sol))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        function = lambda x: 0.1 * x**2\n        area = 4  # Area from x = 0 to x = 4\n\n        # Display the function graph\n        graph = FunctionGraph(function, x_range=[-1, 5])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Show the area under the curve\n        shaded_area = area_between_curves(\n            graph,\n            x_range=[0, area],\n            fill_opacity=0.3,\n            fill_color=BLUE\n        )\n        self.play(FadeIn(shaded_area))\n        self.wait(2)\n\n        # Present the calculation of the area\n        calculation = MathTex(r\"A = \\int_0^4 0.1x^2 \\,dx\")\n        self.play(Write(calculation))\n        self.wait(2)\n\n        # Display the result of the integration\n        result = MathTex(r\"A = \\left[ \\frac{0.1x^3}{3} \\right]_0^4\")\n        self.play(ReplacementTransform(calculation, result))\n        self.wait(2)\n\n        # Result simplification\n        final_result = MathTex(r\"A = \\frac{64}{30} - 0\")\n        self.play(ReplacementTransform(result, final_result))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(graph), FadeOut(shaded_area), FadeOut(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral\n        trig_identity = MathTex(r\"\\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Transform(problem, trig_identity))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Displaying the area under the curve\n        curve_text = Text(\"Area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(curve_text))\n        self.play(Write(axes), Write(graph), Write(graph_label))\n        self.wait(1)\n\n        # Coloring the area under the curve\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculating the area using definite integral\n        integral = MathTex(r\"\\int_0^2 x^2 \\, dx\")\n        integral.to_edge(UP+LEFT)\n        self.play(Transform(curve_text, integral))\n        self.wait(1)\n\n        integral_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integral_result.next_to(integral, DOWN)\n        self.play(Write(integral_result))\n        self.wait(1)\n\n        evaluate_integral = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", \"=\", r\"\\frac{8}{3}\")\n        evaluate_integral.next_to(integral_result, DOWN)\n        self.play(Write(evaluate_integral))\n        self.wait(2)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        final_result = MathTex(r\"\\text{Area} = \\frac{8}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the original ODE\n        ode_text = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n\n        # Explanation for characteristic equation derivation\n        char_eq_explanation = Text(\"Derive the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(char_eq_explanation))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(ReplacementTransform(ode_text.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for finding the roots of the characteristic equation\n        roots_explanation = Text(\"Find the roots of the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, roots_explanation))\n        self.wait(2)\n\n        # Displaying the roots\n        roots = MathTex(r\"r = 1\", r\"\\\\ r = 1\", r\"\\\\ r = 1\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # Explanation for the general solution\n        general_sol_explanation = Text(\"Write down the general solution\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, general_sol_explanation))\n        self.wait(2)\n\n        # Writing the general solution of the ODE\n        general_solution = MathTex(r\"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Final step: Concluding the process\n        conclusion = Text(\"This is the general solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, conclusion))\n        self.wait(2)\n\n        # Clearing everything and showing the final result only\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation of a simple harmonic oscillator\n        equation = MathTex(r\"m \\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Write down the explanation for solving the equation\n        explanation1 = Text(\"We assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display the assumed solution form\n        assumed_solution = MathTex(r\"x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)\")\n        self.play(ReplacementTransform(equation.copy(), assumed_solution))\n        self.wait(2)\n\n        # Show explanation for angular frequency\n        explanation2 = Text(\"Where\", font_size=24).shift(UP * 3)\n        angular_frequency = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\", font_size=24).next_to(explanation2, DOWN)\n        self.play(Write(explanation2), Write(angular_frequency))\n        self.wait(2)\n\n        # Transform previous text into the explanation for general solution\n        explanation3 = Text(\"Giving the general solution to the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(1)\n\n        # Show the general solution for Simple Harmonic Motion\n        general_solution = MathTex(r\"x(t) = C_1 \\cos(\\sqrt{\\frac{k}{m}} t) + C_2 \\sin(\\sqrt{\\frac{k}{m}} t)\")\n        self.play(ReplacementTransform(assumed_solution, general_solution))\n        self.wait(2)\n\n        # Final explanation about the constants determination\n        explanation4 = Text(\"Constants C1 and C2 are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(1)\n\n        # Clearing everything to conclude the scene\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"This is a simple harmonic motion solution!\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        function = MathTex(r\"f(x) = x^2\")\n        area = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area))\n        self.wait(2)\n\n        # Show the definite integral bounds\n        bounds = MathTex(r\"a=1, \\quad b=2\")\n        self.play(Write(bounds))\n        self.wait(2)\n\n        # Perform the definite integral\n        definite_integral = MathTex(r\"A = \\int_{1}^{2} x^2 \\,dx\")\n        self.play(ReplacementTransform(area, definite_integral))\n        self.wait(2)\n\n        # Solve the definite integral\n        solved_integral = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_{1}^{2}\")\n        self.play(ReplacementTransform(definite_integral, solved_integral))\n        self.wait(2)\n\n        # Calculate the area value\n        area_value = MathTex(r\"A = \\frac{2^3}{3} - \\frac{1^3}{3}\")\n        self.play(ReplacementTransform(solved_integral, area_value))\n        self.wait(2)\n\n        # Simplify the result\n        simplified_result = MathTex(r\"A = \\frac{7}{3}\")\n        self.play(ReplacementTransform(area_value, simplified_result))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area under the curve is 7/3.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(simplified_result), Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialFunctionScene(Scene):\n    def construct(self):\n        # Display the function's formula\n        formula = MathTex(r\"f(x) = e^{x}\")\n        self.play(Write(formula))\n        self.wait(1)\n\n        # Show the graph title\n        graph_title = Text(\"Plotting the exponential function\", font_size=24).to_edge(UP)\n        self.play(Write(graph_title))\n        self.wait(2)\n\n        # Draw the graph\n        graph = self.get_graph()\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Show the derivative's formula\n        derivative = MathTex(r\"f'(x) = e^{x}\")\n        self.play(Write(derivative))\n        self.wait(1)\n\n        # Explanation for the derivative\n        explanation = Text(\"Derivative of the exponential function\", font_size=24).to_edge(UP)\n        self.play(Transform(graph_title, explanation))\n        self.wait(2)\n\n        # Clear the scene and display the derivative\n        self.clear()\n        self.wait(1)\n        self.play(Write(derivative))\n        self.wait(1)\n\n    def get_graph(self):\n        graph = FunctionGraph(\n            lambda x: np.exp(x),\n            color=BLUE,\n            x_range=[-3, 3],\n        )\n        return graph\n"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Solution form\n        explanation2 = Text(\"The solution can be written as u(x, t) = f(x-ct) + g(x+ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the form of the solution\n        solution_form = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(Transform(wave_eq, solution_form))\n        self.wait(1)\n\n        # Adding details about the functions\n        explanation3 = Text(\"Where f and g are arbitrary functions determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Show d'Alembert's Formula\n        dalemberts_formula = MathTex(r\"u(x, t) = \\frac{1}{2}[f(x-ct) + f(x+ct)] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} g(s) ds\")\n        self.play(Transform(wave_eq, dalemberts_formula))\n        self.wait(1)\n\n        # Explain d'Alembert's Formula\n        explanation4 = Text(\"This is known as d'Alembert's Formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(wave_eq), FadeOut(explanation1))\n        self.wait(1)\n        conclude_message = Text(\"The wave equation models vibrational phenomena.\", font_size=24)\n        self.play(FadeIn(conclude_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanTheoremScene(Scene):\n    def construct(self):\n        # Define a right triangle\n        right_triangle = Polygon(ORIGIN, 2*RIGHT, 2*RIGHT+3*UP)\n        squares = VGroup()\n        # Square for the hypotenuse\n        squares.add(Square(side_length=5).move_to(right_triangle.get_corner(UR)+0.5*UL+0.5*LEFT))\n        # Square for the vertical side\n        squares.add(Square(side_length=3).move_to(right_triangle.get_corner(DR)+1.5*LEFT+0.5*DOWN))\n        # Square for the horizontal side\n        squares.add(Square(side_length=2).move_to(right_triangle.get_corner(UR)+1*RIGHT+0.5*UP))\n\n        # Draw right triangle and squares\n        self.play(Create(right_triangle))\n        self.play(Create(squares))\n        self.wait(1)\n\n        # Label lengths of sides of the triangle and squares\n        triangle_leg_a = Tex(\"a\").move_to(2*RIGHT+1.5*UP)\n        triangle_leg_b = Tex(\"b\").move_to(1*RIGHT+3*UP)\n        hypotenuse_label = Tex(\"c\").move_to(3.5*RIGHT+1.5*UP)\n\n        square_label_a = Tex(\"a^2\").move_to(right_triangle.get_corner(DR)+1.5*LEFT+1.5*DOWN)\n        square_label_b = Tex(\"b^2\").move_to(right_triangle.get_corner(UR)+1*RIGHT+2.5*UP)\n        square_label_c= Tex(\"c^2\").move_to(right_triangle.get_corner(UR)+2.5*LEFT+1*UP)\n\n        # Play the side labels animation\n        self.play(Write(triangle_leg_a), Write(triangle_leg_b), Write(hypotenuse_label))\n        self.play(Write(square_label_a), Write(square_label_b), Write(square_label_c))\n        self.wait(2)\n\n        # Display Pythagorean theorem equation\n        theorem_text = Tex(\"a^2 + b^2 = c^2\").to_edge(DOWN)\n        self.play(Write(theorem_text))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(right_triangle), FadeOut(squares), FadeOut(triangle_leg_a), FadeOut(triangle_leg_b), FadeOut(hypotenuse_label), FadeOut(square_label_a), FadeOut(square_label_b), FadeOut(square_label_c), FadeOut(theorem_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Create plot and area\n        axes = Axes(x_range=[0, 5], y_range=[0, 10], axis_config={\"color\": BLUE})\n        f = lambda x: x**2\n        graph = axes.plot(f, color=WHITE)\n        area = axes.get_area(graph, x_range=[0, 2], color=[BLUE, GREEN])\n\n        # Labels for the curve and shaded area\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        area_label = Tex(\"Area under curve\\\\nfrom x=0 to x=2\").next_to(area, RIGHT, buff=0.5)\n\n        # Animation\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(graph_label), Write(area_label))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(area), FadeOut(area_label))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate area under the parabola\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Anti-derivative step\n        antid_step = MathTex(r\"\\int x^2 \\,dx = \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(problem.copy(), antid_step))\n        self.wait(1)\n\n        # Explanation for computing the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the limits\n        limits_step = MathTex(r\"\\Bigg|_0^2 \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(antid_step, limits_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\left. \\frac{1}{3}(2)^3 \\right|_0^2 = \\frac{8}{3}\")\n        self.play(ReplacementTransform(limits_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S (\\nabla \\times \\vec{F}) \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for curl of F\n        explanation1 = Text(\"First, find the curl of F\", font_size=24).to_edge(UP)\n        self.play(Transform(problem, explanation1))\n        self.wait(2)\n\n        # Replace with equation of curl of F\n        curl_f = MathTex(r\"\\nabla \\times \\vec{F} = (P, Q, R)\")\n        self.play(ReplacementTransform(problem, curl_f))\n        self.wait(1)\n\n        # Explanation for dot product with dS\n        explanation2 = Text(\"Now, compute the dot product with dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Replace with dot product computation\n        dot_product = MathTex(r\"(\\nabla \\times \\vec{F}) \\cdot d\\vec{S} = P\\,dydz + Q\\,dzdx + R\\,dxdy\")\n        self.play(ReplacementTransform(curl_f, dot_product))\n        self.wait(1)\n\n        # Explanation for final step of the surface integral\n        explanation3 = Text(\"Finally, integrate over the surface S\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral computation\n        final_integral = MathTex(r\"\\iint_S (P\\,dydz + Q\\,dzdx + R\\,dxdy)\")\n        self.play(ReplacementTransform(dot_product, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"\\iint_S (P\\,dydz + Q\\,dzdx + R\\,dxdy) = \\text{Flux through S}\")\n        self.play(Transform(final_integral, final_solution))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass ConceptOfLimitExample(Scene):\n    def construct(self):\n        # Display the function and a point approaching a value\n        func_graph = MathTex(r\"f(x) = \\frac{1}{1+x^2}\")\n        point_label = MathTex(r\"x = a\")\n        self.play(Write(func_graph))\n        self.wait(1)\n\n        # Moving the point on the function graph\n        self.play(Write(point_label))\n        self.wait(2)\n\n        # Expression for the limit\n        limit_expr = MathTex(r\"\\lim_{x \\to a} f(x)\")\n        self.play(Transform(func_graph, limit_expr))\n        self.wait(2)\n\n        # Explanation of the limit's meaning\n        explanation = Text(\"We observe f(x) as x approaches a\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show a value for 'a' and the corresponding limit value\n        a_value = MathTex(r\"a = 2\")\n        limit_value = MathTex(r\"\\lim_{x \\to 2} \\frac{1}{1+x^2} = \\frac{1}{5}\")\n        self.play(Write(a_value))\n        self.play(Transform(limit_expr, limit_value))\n        self.wait(2)\n\n        # Clear the scene and show the final limit value\n        self.clear()\n        self.play(Write(limit_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the example\n        title = Text(\"Fourier Series Example\", font_size=36)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        \n        # Displaying Fourier Series Definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0\",\n            r\"+ \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Coefficients explanation\n        coefficients_explanation = Text(\n            \"Coefficients are calculated based on function's periodicity\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(coefficients_explanation))\n        self.wait(3)\n        \n        # Transition to specific example\n        specific_example = Text(\n            \"For a square wave, coefficients have distinct values\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(coefficients_explanation, specific_example))\n        self.wait(3)\n\n        # Displaying the square wave's Fourier Series\n        square_wave_fs = MathTex(\n            r\"f(x) = \\frac{4}{\\pi}\",\n            r\"\\sum_{n=1,3,5}^{\\infty} \\frac{(-1)^{(n-1)/2}}{n} \\sin(nx)\"\n        )\n\n        self.play(ReplacementTransform(fourier_series_def, square_wave_fs))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(square_wave_fs), FadeOut(specific_example))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Inner integral w.r.t r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(2)\n\n        # Middle integral simplified\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Outer integral w.r.t theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{3}[\\cos(\\theta)]_{0}^{\\pi/2} \")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicSeriesConvergence(Scene):\n    def construct(self):\n        # Introducing the Harmonic series\n        harmonic_series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\")\n        self.play(Write(harmonic_series))\n        self.wait(1)\n\n        # Discuss convergence\n        convergence_text = Text(\"Does this series converge?\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_text))\n        self.wait(2)\n\n        # Applying the integral test\n        integral_test = MathTex(r\"\\int_1^\\infty \\frac{1}{x} \\,dx\")\n        self.play(Transform(harmonic_series, integral_test))\n        self.wait(1)\n\n        # Display divergence explanation\n        divergence_explanation = Text(\"This improper integral diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_text, divergence_explanation))\n        self.wait(1)\n\n        # Writing the steps for the integral test result\n        integral_steps = MathTex(r\"\\lim_{b \\to \\infty} \\ln{|x|}_1^b\")\n        self.play(ReplacementTransform(integral_test, integral_steps))\n        self.wait(1)\n\n        # Conclude with divergence of the series\n        divergent_result = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\", r\"\\text{ diverges}\")\n        self.play(ReplacementTransform(integral_steps, divergent_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Reaffirm the result\n        reaffirm_conclusion = Text(\"The harmonic series diverges.\", font_size=24)\n        self.play(Write(reaffirm_conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Area under the curve from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral setup\n        integral_setup = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_setup))\n        self.wait(1)\n\n        # Explanation for the antiderivative\n        explanation2 = Text(\"Compute antiderivative\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Antiderivative result\n        antiderivative_result = MathTex(r\"\\left[\\dfrac{1}{3}x^3\\right]_0^2 = \\dfrac{8}{3}\")\n        self.play(ReplacementTransform(integral_setup, antiderivative_result))\n        self.wait(1)\n\n        # Clear the scene and show final area value\n        self.play(FadeOut(explanation1))\n        self.clear()\n        self.wait(1)\n        final_area_value = MathTex(r\"\\text{Area} = \\dfrac{8}{3}\")\n        self.play(Write(final_area_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Mention it's a second-order PDE\n        explanation1 = Text(\"This is a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(Transform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Comment on the solution\n        explanation2 = Text(\"It represents waves moving in both directions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Special solution case\n        special_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(general_solution, special_solution))\n        self.wait(2)\n\n        explanation3 = Text(\"This is a specific sinusoidal wave solution.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the screen\n        self.play(FadeOut(special_solution), FadeOut(explanation1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 5, 1], y_range=[0, 6, 1], axis_config={\"color\": BLUE})\n\n        # Define the curve and the area under the curve\n        function = lambda x: 0.1 * (x - 2) ** 2 + 1\n        curve = axes.plot(function, color=RED)\n        shaded_area = axes.get_area(curve, x_range=[2, 4], color=BLUE, opacity=0.5)\n\n        # Labels for the curve and area under curve\n        curve_label = axes.get_graph_label(curve, label='y = f(x)')\n        area_label = Tex(\"Area under curve\").move_to(shaded_area).shift(DOWN * 0.5)\n\n        # Display axes, function curve, and area under curve\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n        self.play(FadeIn(shaded_area), Write(curve_label), Write(area_label))\n        self.wait(2)\n\n        # Explanation showing calculation of area\n        explanation = Text(\"Calculated as definite integral from a to b\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display a final message\n        final_message = Text(\"The calculated area is the definite integral\", font_size=32, color=GOLD)\n        self.play(Write(final_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1, 5], y_range=[-1, 6], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: 0.1 * (x - 2)**2 + 1, color=GREEN)\n        area = axes.get_area(graph, x_range=(0,4), color=GREY, opacity=0.5)\n        label = MathTex(r\"f(x) = 0.1(x-2)^2 + 1\").next_to(graph, UP)\n\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.play(Write(label))\n        self.wait(2)\n\n        # Explanation of the area calculation\n        explanation = Text(\"This shaded area represents the integral from 0 to 4\",\n                           font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculation of the area\n        calculation = MathTex(r\"\\int_0^4 0.1(x-2)^2 + 1 \\,dx\")\n        self.play(ReplacementTransform(label.copy(), calculation), FadeOut(explanation))\n        self.wait(1)\n\n        # Solution\n        solution = MathTex(r\"A = \\frac{8}{3} + 4\")\n        self.play(ReplacementTransform(calculation, solution))\n        self.wait(2)\n\n        # Clear the scene and show only the solution\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesApprox(Scene):\n    def construct(self):\n        # Display the function to be approximated\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Introduction to Taylor Series\n        taylor_explanation = Text(\"Approximate using Taylor Series at x=0:\", font_size=24).to_edge(UP)\n        self.play(Write(taylor_explanation))\n        self.wait(2)\n\n        # Taylor Series formula\n        taylor_formula = MathTex(r\"f(x) \\approx f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\dots + \\frac{f^{(n)}(0)}{n!}x^n\")\n        self.play(Write(taylor_formula))\n        self.wait(2)\n\n        # Calculating the first few terms\n        first_terms = MathTex(r\"1 + x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\frac{x^4}{24}\")\n        self.play(ReplacementTransform(taylor_formula, first_terms))\n        self.wait(1)\n\n        # Explanation for stopping at 4th degree\n        taylor_stop_explanation = Text(\"Stopping at the 4th-degree polynomial\", font_size=24).to_edge(UP)\n        self.play(Transform(taylor_explanation, taylor_stop_explanation))\n        self.wait(2)\n\n        # Show graph of the function and the approximation\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[0, 8],\n            axis_config={\"color\": BLUE},\n        )\n        original_graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        approx_graph = axes.plot(lambda x: 1 + x + x**2 / 2 + x**3 / 6 + x**4 / 24, color=RED)\n        graphs = VGroup(axes, original_graph, approx_graph).scale(0.6).to_edge(DOWN)\n\n        # Display the graphs on the scene\n        self.play(Write(axes), Write(original_graph), Write(approx_graph))\n        self.wait(2)\n\n        # Legend\n        legend = VGroup(\n            original_graph.copy().set_color(WHITE),\n            Text(\"Original function\", font_size=18),\n            approx_graph.copy().set_color(WHITE),\n            Text(\"4th-degree approximation\", font_size=18)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(axes, RIGHT, aligned_edge=UP)\n        self.play(Write(legend))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(first_terms))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial u}{\\partial t} - \\alpha^2 \\nabla^2 u = 0\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation for the heat equation\n        explanation1 = Text(\"This PDE represents the Heat Equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution form\n        explanation2 = Text(\"The solution describes how heat evolves over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying separation of variables\n        separation_of_vars = MathTex(r\"u(x, t) = X(x)T(t)\")\n        self.play(Transform(pde, separation_of_vars))\n        self.wait(1)\n\n        # Displaying the separated equations\n        separated_pde = MathTex(r\"\\frac{T'}{\\alpha^2 T} = \\frac{X''}{X} = -\\lambda\")\n        self.play(Write(separated_pde))\n        self.wait(2)\n\n        # Explanation for boundary conditions\n        explanation3 = Text(\"Boundary conditions will give specific solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(separation_of_vars))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass EulerFormulaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"e^{ix} = \\cos(x) + i\\sin(x)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Euler's formula\n        explanation = Text(\"Euler's formula relates complex exponentials to trigonometric functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Transform the formula to its real and imaginary parts\n        real_part = MathTex(r\"\\cos(x) = \\Re\\{e^{ix}\\}\")\n        imaginary_part = MathTex(r\"\\sin(x) = \\Im\\{e^{ix}\\}\")\n        self.play(Transform(problem, real_part))\n        self.wait(1)\n        self.play(Transform(problem, imaginary_part))\n        self.wait(1)\n\n        # Applying Euler's formula in polar form\n        euler_polar = MathTex(r\"e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\")\n        self.play(ReplacementTransform(problem, euler_polar))\n        self.wait(1)\n\n        # Show polar representation\n        point = Dot(radius=0.1).move_to(RIGHT)\n        circle = Circle(radius=1).move_to(ORIGIN)\n        line = DashedLine(ORIGIN, point)\n        angle = Angle(ORIGIN, point, radius=0.5, other_angle=False)\n\n        polar_form = VGroup(circle, line, angle, point)\n        polar_form_label = MathTex(r\"\\theta\").move_to(0.3*UP + 0.2*RIGHT)\n        \n        self.play(FadeIn(polar_form), FadeIn(polar_form_label))\n        self.wait(2)\n\n        # Clear the scene and conclude with the original problem\n        self.clear()\n        self.wait(1)\n        self.play(Write(problem))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Describing the motion\n        motion_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explaining the terms\n        explanation1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Frequency of the oscillator\n        explanation2 = Text(r\"The term $\\omega$ is the angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution to the motion equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(motion_eq, solution))\n        self.wait(1)\n\n        # Describing the amplitude and phase\n        explanation3 = Text(\"Here, A is amplitude and \u03c6 is the phase.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and show conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area we want to find\n        curve_text = MathTex(r\"y = x^2\", font_size=36)\n        curve_text.to_edge(UP)\n        self.play(Write(curve_text))\n        self.wait(1)\n\n        # Define the function and the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        shaded_area = area = self.get_area(curve, [0, 2])\n        \n        # Show the function and the shaded area\n        self.play(Create(curve), Create(shaded_area))\n        self.wait(2)\n\n        # Display the integral expression defining the shaded area\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral.next_to(curve_text, DOWN)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Solving the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integral_solution.next_to(integral, DOWN)\n        self.play(Transform(integral, integral_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        final_result.next_to(integral_solution, DOWN)\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(curve), FadeOut(shaded_area), FadeOut(curve_text), FadeOut(integral))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} \\int_{0}^{\\pi} r \\sin(\\theta) d\\theta\\,dr\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to \\(\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2} [-\\cos(\\theta)]_{0}^{\\pi} dr\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Solution after inner integral\n        solved_inner = MathTex(r\"= \\int_{0}^{2} [-(-1) - (-1)] dr\")\n        self.play(ReplacementTransform(inner_integral, solved_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(r\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_solution = MathTex(r\"= \\left[ 2r \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(solved_inner, final_solution))\n        self.wait(1)\n\n        # Calculation of the final solution\n        calculated_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, calculated_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series Definition\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Initial Explanation\n        explanation1 = Text(\"This represents a Fourier series.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"Here, a_n and b_n are the Fourier coefficients.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing an example with fixed limits\n        example_eq = MathTex(r\"a_n = \\frac{1}{\\pi} \\int_{-\\pi}^\\pi f(x) \\cos(nx) dx\", r\"\\quad\",\n                             r\"b_n = \\frac{1}{\\pi} \\int_{-\\pi}^\\pi f(x) \\sin(nx) dx\")\n        self.play(ReplacementTransform(fourier_series, example_eq))\n        self.wait(2)\n\n        # Explanation for the orthogonality of sine and cosine\n        explanation3 = Text(\"Sines and cosines are orthogonal functions over this interval.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show an application of Fourier series\n        self.clear()\n        self.wait(1)\n        application = Text(\"Fourier series are used in signal processing and many areas of physics.\", font_size=24)\n        self.play(FadeIn(application))\n        self.wait(2)\n\n        # Conclude the demonstration\n        self.wait(1)\n        self.play(FadeOut(application))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{2+1}}{3} \\right|_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution step 1: Substituting the upper limit of integration\n        final_solution_step1 = MathTex(r\"= \\Big( \\frac{3^3}{3} \\Big) -\")\n        self.play(ReplacementTransform(solution1.copy(), final_solution_step1))\n        self.wait(1)\n\n        # Final solution step 2: Substituting the lower limit of integration\n        final_solution_step2 = MathTex(r\"\\Big( \\frac{1^3}{3} \\Big)\")\n        final_solution_step2.next_to(final_solution_step1, RIGHT)\n        self.play(Write(final_solution_step2))\n        self.wait(1)\n\n        # Combine the final solution steps\n        final_solution_combined = MathTex(r\"= \\Big( \\frac{27}{3} \\Big) - \\Big( \\frac{1}{3} \\Big)\")\n        self.play(Transform(final_solution_step1, final_solution_combined))\n        self.remove(final_solution_step2)\n        self.wait(1)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= 9 - \\frac{1}{3}\")\n        self.play(ReplacementTransform(final_solution_step1, simplified_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(simplified_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Display the integral to solve\n        integral = MathTex(r\"\\int \\sqrt{1+x^2} \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Show the substitution\n        substitution = Text(\"Use trigonometric substitution: \"\n                            \"x = tan(theta)\", font_size=24).to_edge(UP)\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Show the dx and sqrt changes\n        changes = MathTex(r\"dx = sec^2(\\theta) d\\theta, \\quad\",\n                          r\"\\sqrt{1+x^2} = \\sqrt{1+\\tan^2(\\theta)}\")\n        self.play(Write(changes))\n        self.wait(2)\n\n        # Show the new integral\n        new_integral = MathTex(r\"= \\int \\sqrt{1+\\tan^2(\\theta)} sec^2(\\theta) d\\theta\")\n        self.play(ReplacementTransform(integral.copy(), new_integral))\n        self.wait(1)\n\n        # Simplify the integral using trigonometric identity\n        simplification = Text(\"Use identity: \"\n                              \"1+tan^2(theta) = sec^2(theta)\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, simplification))\n        self.wait(2)\n\n        # Integral after simplification\n        simplified_integral = MathTex(r\"= \\int sec^3(\\theta) d\\theta\")\n        self.play(ReplacementTransform(new_integral, simplified_integral))\n        self.wait(1)\n\n        # Explain further steps\n        further_steps = Text(\"This requires integration techniques \"\n                             \"like reduction formulae\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, further_steps))\n        self.wait(2)\n\n        # Conclude the problem\n        conclusion = Text(\"Skipping to the solution after \"\n                          \"applying reduction formulae\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, conclusion))\n        self.wait(1)\n\n        # The final answer\n        final_answer = MathTex(r\"= \\frac{1}{2} \\left( sec(\\theta)tan(\\theta) + ln|sec(\\theta)+tan(\\theta)| \\right) + C\")\n        self.play(ReplacementTransform(simplified_integral, final_answer))\n        self.wait(1)\n\n        # Clear the scene and show the final conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using a trigonometric identity\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2 sin(x) cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Solving using the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), identity_applied))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(1)\n\n        # Clear the scene and show conclusion\n        self.clear()\n        self.wait(1)\n        final_solution = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx = - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dA\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Express dA in polar coordinates as r dr d\u03b8\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral with polar coordinates\n        polar_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_integral))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation2 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Inner integral after r integration\n        r_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(polar_integral, r_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(r_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{3}\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(3)\n\n        # Explanation for final answer\n        explanation4 = Text(\"The final answer is \u03c0/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[\\frac{1}{2}r^2\\right]_0^1 d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[\\frac{1}{2}\\theta\\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}\\pi\")\n        self.play(Transform(final_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        circle.set_fill(PINK, opacity=0.5)\n\n        # Create a square\n        square = Square()\n        square.set_fill(YELLOW, opacity=0.5)\n\n        # Display the circle\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into the square\n        self.play(Transform(circle, square))\n        self.wait(1)\n\n        # Annotate the transformation\n        transform_text = Text(\"A circle transforms into a square\", font_size=24).to_edge(DOWN)\n        self.play(Write(transform_text))\n        self.wait(2)\n\n        # Fade out the square and the text\n        self.play(FadeOut(square), FadeOut(transform_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        context = Text(\"This represents a one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(context))\n        self.wait(2)\n\n        solution_hint = Text(\"Seek solutions of the form u(x, t) = f(x - ct) or u(x, t) = g(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(context, solution_hint))\n        self.wait(2)\n\n        wave_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, wave_solution))\n        self.wait(1)\n\n        specific_harmonic = Text(\"For harmonic waves, f and g can be sine or cosine functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(context, specific_harmonic))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(wave_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} (r^2 \\sin(\\theta))\\,r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{r^4}{4} \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4} \\sin(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of solution\n        conclusion = MathTex(r\"= 0\")\n        self.play(Transform(final_solution, conclusion))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The polar double integral evaluates to 0\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use the identity: sin(2x) = 2 sin(x) cos(x)\", font_size=24)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral using the identity\n        rewritten_integral = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Transform(problem, rewritten_integral))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(rewritten_integral, integration_step))\n        self.wait(2)\n\n        # Displaying the substitution\n        substitution = Text(\"Now substitute back for x\", font_size=24)\n        self.play(Transform(explanation1, substitution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final solution\n        explanation3 = Text(\"Solve the remaining integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= -\\frac{1}{3} \\cos(\\frac{\\pi}{2}) + \\frac{1}{3} \\cos(0)\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)\n\n        # Simplified even further to numeric solution\n        numeric_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(Transform(final_solution, numeric_solution))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2}\", \"=\",\n                          \"c^2\", r\"\\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Discuss the equation\n        eq_description = Text(\n            \"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(eq_description, shift=UP))\n        self.wait(2)\n\n        # Show the general solution to the equation\n        gen_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, gen_solution))\n        self.wait(2)\n\n        # Describe the general solution\n        solution_description = Text(\n            \"The solution represents traveling waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(eq_description, solution_description))\n        self.wait(2)\n\n        # Discuss characteristic lines\n        char_lines = MathTex(r\"x - ct = k_1, x + ct = k_2\",\n                             tex_environment=\"align*\")\n        self.play(FadeOut(eq_description), FadeOut(wave_eq), FadeIn(char_lines))\n        self.wait(2)\n\n        # Explain characteristic lines\n        char_lines_description = Text(\n            \"Characteristic lines of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(char_lines_description))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(FadeIn(char_lines_description), FadeIn(char_lines))\n        self.wait(1)\n        self.play(FadeOut(char_lines_description), FadeOut(char_lines))\n        self.wait(1)\n\n        # Show initial and boundary conditions\n        init_boundary_conditions = Text(\n            \"Solutions also require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Write(init_boundary_conditions))\n        self.wait(3)\n\n        # Conclude the scene\n        self.play(FadeOut(init_boundary_conditions))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for the convergence test\n        explanation_convergence = Text(\"Test for convergence using the p-test\", font_size=24)\n        self.play(Write(explanation_convergence))\n        self.wait(2)\n\n        # Showing the p-test result\n        p_test_result = MathTex(r\"\\text{Since } p = 2 > 1, \\text{the series converges.}\")\n        self.play(Transform(series_problem, p_test_result))\n        self.wait(2)\n\n        # Explanation for comparison with integral\n        explanation_integral = Text(\"Compare with a known convergent integral\", font_size=24).shift(UP*3)\n        self.play(Transform(explanation_convergence, explanation_integral))\n        self.wait(2)\n\n        # Comparison with integral\n        integral_comparison = MathTex(r\"\\int_{1}^{\\infty} \\frac{1}{x^2} \\,dx \\text{ converges, so does our series}\")\n        self.play(ReplacementTransform(series_problem, integral_comparison))\n        self.wait(2)\n\n        # Final statement\n        final_statement = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ converges}\")\n        self.play(ReplacementTransform(integral_comparison, final_statement))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation_convergence), FadeOut(final_statement))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier Series definition\n        series_def = MathTex(r\" f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(series_def))\n        self.wait(1)\n\n        # Explanation of Fourier Series\n        explanation = Text(\"Fourier Series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Example function\n        function = MathTex(r\"f(x) = \\cos(x) + \\frac{1}{3} \\cos(3x)\")\n        self.play(Transform(series_def, function))\n        self.wait(1)\n\n        # Highlighting cosine terms\n        highlight = SurroundingRectangle(series_def[1][12:23], color=YELLOW)\n        self.play(Create(highlight))\n        self.wait(1)\n\n        # Explanation of coefficients\n        coeffs_explanation = Text(\"The coefficients determine the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, coeffs_explanation))\n        self.wait(2)\n\n        # Displaying one term of the series\n        one_term = MathTex(r\"a_n \\cos(nx)\")\n        self.play(FadeOut(highlight), Transform(series_def[1], one_term))\n        self.wait(1)\n\n        # Conclusion on Fourier Series\n        conclusion = Text(\"Fourier Series are used in many fields such as signal processing\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of Demonstration\", font_size=36)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        function = MathTex(r\"f(x) = x^2\")\n        area_under_curve_text = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(function, DOWN)\n        self.play(Write(function), Write(area_under_curve_text))\n        self.wait(1)\n\n        # Explanation for calculating the area\n        explanation1 = Text(\"Find the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\int_0^2 x^2 \\,dx = \\frac{x^3}{3} \\bigg|_0^2\")\n        self.play(ReplacementTransform(area_under_curve_text, integration_step))\n        self.wait(1)\n\n        # Explanation for definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Find the area under x^2 from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrating the function\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        explanation2 = Text(\"Plug in the upper and lower limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing the evaluation of the bounds\n        evaluation_step = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Convert into numbers\n        final_solution = MathTex(r\"= \\frac{1}{3} (27) - \\frac{1}{3} (1)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and present the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass QuadraticEquationExample(Scene):\n    def construct(self):\n        # Displaying the quadratic equation\n        equation = MathTex(r\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation of discriminant\n        explanation1 = Text(\"The discriminant of the equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the discriminant\n        discriminant = MathTex(r\"\\Delta = b^2 - 4ac\")\n        self.play(ReplacementTransform(equation.copy(), discriminant))\n        self.wait(1)\n\n        # Explanation of roots based on discriminant\n        explanation2 = Text(\"Nature of roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Types of roots\n        roots_type = VGroup(\n            MathTex(r\"\\Delta > 0\", r\"\\Rightarrow\", r\"\\text{Real and Distinct}\"),\n            MathTex(r\"\\Delta = 0\", r\"\\Rightarrow\", r\"\\text{Real and Equal}\"),\n            MathTex(r\"\\Delta < 0\", r\"\\Rightarrow\", r\"\\text{Complex Roots}\")\n        ).arrange(DOWN, aligned_edge=LEFT)\n\n        self.play(ReplacementTransform(discriminant, roots_type))\n        self.wait(1)\n\n        # Formula for roots\n        formula_for_roots = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{\\Delta} }}{2a}\")\n        self.play(Write(formula_for_roots))\n        self.wait(1)\n\n        # Explanation for the formula\n        explanation3 = Text(\"Formula for calculating the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show roots formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(formula_for_roots))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Apply the limits after integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        solution1 = MathTex(r\"= \\frac{2^{3+1}}{3+1} - \\frac{0^{3+1}}{3+1}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        explanation2 = Text(\"Evaluate the expression using limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4} =\", \"\\\\frac{16}{4} - 0 =\", \"4\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^\\infty e^{-x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the improper integral\n        explanation1 = Text(\"Setup as a limit for the improper integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the limit\n        limit_setup = MathTex(r\"= \\lim_{a \\to \\infty} \\int_2^a e^{-x} \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), limit_setup))\n        self.wait(1)\n\n        # Integration step\n        integration_step = MathTex(r\"= \\lim_{a \\to \\infty} [-e^{-x}]_2^a\")\n        self.play(ReplacementTransform(limit_setup, integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the limit\n        explanation2 = Text(\"Evaluate the limit as a approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= e^{-2}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral result\n        x_integral_result = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), x_integral_result))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral result\n        y_integral_result = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(x_integral_result, y_integral_result))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(y_integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The result of the triple integral is:\", font_size=24).to_edge(UP)))\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Setting up the integral computation\n        integral_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem, integral_step))\n        self.wait(2)\n\n        # Explanation for evaluating the antiderivative\n        explanation = Text(\"Evaluate the antiderivative at the bounds\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\cos(\\pi) - (-\\cos(0))]\")\n        self.play(Transform(integral_step, final_solution))\n        self.wait(1)\n\n        solution_simplified = MathTex(r\"= [1 - (-1)]\")\n        self.play(Transform(final_solution, solution_simplified))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(solution_simplified, solution_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Present the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Add explanation about the wave equation\n        wave_explanation = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(wave_explanation, shift=UP))\n        self.wait(3)\n\n        # Show general solution to the wave equation\n        general_wave_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_wave_solution))\n        self.play(FadeOut(wave_explanation, shift=UP))\n        self.wait(2)\n\n        # Discuss particular solution\n        particular_solution_text = Text(\"Particular solutions are found using initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(general_wave_solution, wave_eq))\n        self.play(FadeIn(particular_solution_text, shift=UP))\n        self.wait(3)\n\n        # Conclude and clear the scene\n        self.play(FadeOut(wave_eq), FadeOut(particular_solution_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DefiniteIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        definite_integral_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(definite_integral_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{4} \\right|_{0}^{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Evaluation of the definite integral\n        explanation2 = Text(\"Evaluate at the bounds 0 and 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_{0}^{2} = \\frac{2^4}{4} - \\frac{0^4}{4} = 4\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function to be integrated\n        function_tex = MathTex(r\"y = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Draw the graph\n        axes = Axes(\n            x_range=[-1, 3],\n            y_range=[-1, 9],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        area_problem.to_edge(UP)\n        self.play(Transform(function_tex, area_problem))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Show the result of the integration\n        result = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^2 = \\frac{8}{3}\")\n        self.play(Write(result))\n        self.wait(1)\n\n        # Clear the scene and display only the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitution(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Introduction of trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Defining the substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), \\, dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Substituting into the integral\n        substituted_integral = MathTex(r\"= \\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplifying the integral with a trigonometric identity\n        explanation2 = Text(\"Use the Pythagorean identity:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(substituted_integral, simplified_integral))\n        self.wait(2)\n\n        # Integrating the simplified integral\n        integrated_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(simplified_integral, integrated_solution))\n        self.wait(1)\n\n        # Back-substituting using the original substitution\n        explanation3 = Text(\"Back-substitute using x = sin(\u03b8):\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        back_substituted_solution = MathTex(r\"= \\frac{\\arcsin(x)}{2} + \\frac{x\\sqrt{1-x^2}}{2} + C\")\n        self.play(ReplacementTransform(integrated_solution, back_substituted_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display final answer\n        self.play(Write(back_substituted_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying a function f(x)\n        function_tex = MathTex(r\"f(x) = \\sin(x)\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation for Fourier Series\n        explanation1 = Text(\"Fourier Series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier Series formula\n        fourier_series_formula = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty}(a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(ReplacementTransform(function_tex, fourier_series_formula))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"The coefficients are determined by the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Coefficients for sin(x)\n        coefficients = MathTex(r\"a_0=0, \\ a_n=0, \\ b_n=\\frac{2}{\\pi(1-n^2)} \\ for \\ n\\ odd\")\n        self.play(ReplacementTransform(fourier_series_formula, coefficients))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show approximation of sin(x) using first 3 non-zero terms of the Fourier Series\n        approximation = MathTex(r\"f(x) \\approx \\frac{4}{\\pi} (\\sin(x) - \\frac{\\sin(3x)}{9} + \\frac{\\sin(5x)}{25})\")\n        self.play(Write(approximation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\frac{\\pi}{2} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral of sine\n        explanation1 = Text(\"Integrate the sine function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Evaluation step\n        evaluation_step = MathTex(r\"= [-\\cos(\\frac{\\pi}{2})] - [-\\cos(0)]\")\n        self.play(Transform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the result\n        explanation2 = Text(\"Evaluate the cosine values at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 1 - (-1)\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Simplify final solution\n        final_simplified = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(final_solution, final_simplified))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_simplified))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fourier Series Demo\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Fourier series equation\n        fourier_series = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right) \\right]\"\n        )\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Display the partial sum of the Fourier series\n        partial_sum = MathTex(\n            r\" S_N(x) = a_0 + \\sum_{n=1}^{N} \\left[ a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right) \\right]\"\n        )\n        self.play(Transform(fourier_series, partial_sum))\n        self.wait(2)\n\n        # Explanation that we approximate using partial sums\n        explanation = Text(\"We approximate functions using partial sums of the series.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Display the approximation for N=3\n        three_term_approx = MathTex(\n            r\" S_3(x) = a_0 + a_1 \\cos\\left(\\frac{2\\pi x}{P}\\right) + b_1 \\sin\\left(\\frac{2\\pi x}{P}\\right) + a_2 \\cos\\left(\\frac{4\\pi x}{P}\\right) + b_2 \\sin\\left(\\frac{4\\pi x}{P}\\right) + a_3 \\cos\\left(\\frac{6\\pi x}{P}\\right) + b_3 \\sin\\left(\\frac{6\\pi x}{P}\\right)\"\n        ).scale(0.7)\n        self.play(ReplacementTransform(partial_sum, three_term_approx))\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(explanation), FadeOut(three_term_approx))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing the area under the curve\n        integral_expr = MathTex(r\"\\int_0^3\", r\"x^2\", r\"\\,dx\")\n        self.play(Write(integral_expr))\n        self.wait(1)\n\n        # Highlight the function to integrate\n        function_highlight = SurroundingRectangle(integral_expr[1], color=YELLOW)\n        self.play(Create(function_highlight))\n        self.wait(1)\n\n        # Explain the definite integral represents area\n        explanation = Text(\"The definite integral represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Perform integration\n        integral_solution = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_expr, integral_solution))\n        self.wait(1)\n\n        # Calculate the final area value\n        final_area = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(integral_solution, final_area))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(final_area, final_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(final_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Display the Pythagorean theorem\n        theorem = MathTex('a^2 + b^2 = c^2')\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Show the triangle\n        triangle = Triangle().scale(2)\n        sides_text = VGroup(\n            MathTex('a').next_to(triangle, LEFT),\n            MathTex('b').next_to(triangle, DOWN),\n            MathTex('c').move_to(triangle.get_center())\n        )\n        self.play(Create(triangle))\n        self.play(Write(sides_text))\n        self.wait(2)\n\n        # Square on each side\n        squares = VGroup(\n            Square().scale(0.5).next_to(triangle, LEFT),\n            Square().scale(0.5).next_to(triangle, DOWN),\n            Square().scale(0.7).align_to(triangle, UP+RIGHT)\n        )\n        self.play(Create(squares))\n        self.wait(1)\n\n        # Mapping squares to theorem\n        mapping = VGroup(\n            Arrow(start=theorem[0].get_top(), end=squares[1].get_center()),\n            Arrow(start=theorem[2].get_top(), end=squares[0].get_center()),\n            Arrow(start=theorem[4].get_top(), end=squares[2].get_center())\n        )\n        self.play(ShowCreation(mapping))\n        self.wait(2)\n\n        # Clear scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text('Pythagorean Theorem Proved!', font_size=36)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier Series formula\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier Series represents periodic functions.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explaining coefficients\n        explanation2 = Text(\"The coefficients a_n and b_n are specific to the function's shape.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Displaying the formula for coefficients\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) dx\", r\"\\\\\",\n                               r\"b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) dx\"\n        ).next_to(fourier_series, DOWN)\n        self.play(Write(coefficients))\n        self.wait(3)\n\n        # Explanation of convergence\n        explanation3 = Text(\"The series converges to f(x) as n approaches infinity.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Fourier Series decompose periodic functions into harmonic components.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left[\\frac{x^{3+1}}{3+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from a to b:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the solution with bounds\n        evaluated_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_0^2\")\n        self.play(Transform(solution1, evaluated_solution))\n        self.wait(1)\n\n        solution2 = MathTex(r\"= \\left. \\frac{1}{4}x^4 \\right|_0^2\")\n        self.play(Transform(evaluated_solution, solution2))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}(2^4) - \\frac{1}{4}(0^4)\")\n        self.play(Transform(solution2, final_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= 4\")\n        self.play(Transform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        integral_x = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), integral_x))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(integral_x, integral_y))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaParametricSurface(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Displaying the parametric surface equation\n        surface_eq = MathTex(r\"S(u,v) = f(u,v)\\hat{i} + g(u,v)\\hat{j} + h(u,v)\\hat{k}\")\n        surface_eq.next_to(problem, DOWN)\n        self.play(Write(surface_eq))\n        self.wait(2)\n\n        # Explaining the formula for surface area element in parametric form\n        explanation1 = Text(\"For a surface parametrized by u and v\", font_size=24)\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface area element formula\n        dS_formula = MathTex(r\"dS = \\left| \\frac{\\partial S}{\\partial u} \\times \\frac{\\partial S}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(surface_eq.copy(), dS_formula))\n        self.wait(2)\n\n        # Displaying the integral with the surface area element\n        integral_with_dS = MathTex(r\"\\iint_S \\left| \\frac{\\partial S}{\\partial u} \\times \\frac{\\partial S}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(problem.copy(), integral_with_dS))\n        self.wait(1)\n\n        # Explaining how to solve the integral\n        explanation2 = Text(\"Solve the below double integral to find the surface area\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution placeholder (not solved)\n        final_solution = Text(\"Surface area = ...\", font_size=24)\n        final_solution.to_edge(UP)\n        self.play(ReplacementTransform(explanation1, final_solution))\n        self.wait(2)\n\n        # Finish the scene\n        self.play(FadeOut(final_solution), FadeOut(integral_with_dS))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass QuadraticEquationScene(Scene):\n    def construct(self):\n        # Display the quadratic equation\n        equation = MathTex(\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Display the formula for finding roots\n        roots_formula = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{{b^2 - 4ac}}}}{{2a}}\")\n        self.play(Write(roots_formula))\n        self.wait(1)\n\n        # Transition to Discriminant\n        discriminant = MathTex(r\"D = b^2 - 4ac\")\n        self.play(ReplacementTransform(roots_formula.copy(), discriminant))\n        self.wait(2)\n\n        # Discuss the nature of roots based on discriminant\n        roots_nature = Text(\"Nature of roots depends on D\", font_size=24).to_edge(DOWN)\n        self.play(Write(roots_nature))\n        self.wait(2)\n\n        # Example with positive discriminant\n        example_positive_D = MathTex(r\"D = 1^2 - 4(1)(-1) = 5\")\n        self.play(ReplacementTransform(discriminant, example_positive_D))\n        self.wait(1)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude by displaying the nature of roots\n        conclusion = Text(\"D > 0, Two distinct real roots\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplifying inner integral result\n        inner_result = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, inner_result))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [ -\\frac{1}{3} \\cos(\\theta) ]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_result, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{3} \\cos(\\pi) + \\frac{1}{3} \\cos(0)\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying final solution\n        solution_simplified = MathTex(r\"= -\\frac{1}{3}(-1) + \\frac{1}{3}(1) = \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, solution_simplified))\n        self.wait(2)\n\n        # Display final answer\n        final_answer = Text(\"Final Answer: \\( \\frac{2}{3} \\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(curve))\n        self.wait(1)\n\n        # Displaying the area question\n        area_question = MathTex(r\"\\text{Find the area under }\",\n                                r\"f(x)\", r\"\\text{ from }\", r\"x = -1\", r\"\\text{ to }\", r\"x = 2\")\n        area_question.next_to(curve, DOWN)\n        self.play(Write(area_question))\n        self.wait(2)\n\n        # Setting up the integral\n        integral = MathTex(r\"A = \\int_{-1}^{2} (3 - x^2) \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calculation = MathTex(r\"A = \\left[3x - \\frac{1}{3}x^3\\right]_{-1}^{2}\")\n        self.play(Transform(integral, integral_calculation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"A = \\left(6 - \\frac{8}{3}\\right) - \\left(3 + \\frac{1}{3}\\right) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(integral, final_solution))\n        self.wait(1)\n\n        # Show final answer on screen\n        final_answer = Text(\"Area under the curve is 7/3\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait()\n\n        # Display the integral symbol with limits\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Calculation of the integral\n        calculation = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(Transform(integral, calculation))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(integral))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the scene\n        title = Text(\"Fourier Series Approximation\").scale(0.9)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Define the function to be approximated\n        original_function = MathTex(r\"f(x) = x^2\").next_to(title, DOWN)\n        self.play(FadeIn(original_function))\n        self.wait(1)\n\n        # Show the nth partial sum of Fourier series\n        fourier_series = MathTex(r\"S_n(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} [a_n \\cos(nx) + b_n \\sin(nx)]\", font_size=24)\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explain the coefficients\n        coefficients_info = Text(\n            \"Coefficients a_n and b_n are calculated based on f(x)\", \n            font_size=24).next_to(fourier_series, DOWN)\n        self.play(Write(coefficients_info))\n        self.wait(2)\n\n        # Define the Fourier series approximation for n=5\n        approximation = MathTex(r\"S_5(x) = \\frac{a_0}{2} + \\sum_{n=1}^{5} [a_n \\cos(nx) + b_n \\sin(nx)]\", font_size=24)\n        self.play(Transform(fourier_series, approximation))\n        self.wait(2)\n\n        # Remove everything and display only the approximation\n        self.play(FadeOut(title), FadeOut(original_function), FadeOut(coefficients_info))\n        self.wait(1)\n        self.play(Write(approximation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation in One Dimension\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        wave_eq.next_to(title, DOWN)\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Describing the wave equation\n        description = Text(\"Describes the propagation of waves, like sound and light.\", font_size=24)\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(wave_eq, DOWN)\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for the general solution\n        explanation = Text(\"The general solution consists of two functions representing waves travelling in opposite directions.\", font_size=24)\n        explanation.to_edge(UP)\n        self.play(Transform(description, explanation))\n        self.wait(3)\n\n        # Specific Example of a sine wave solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        specific_solution.next_to(general_solution, DOWN)\n        self.play(Write(specific_solution))\n        self.wait(2)\n\n        # Explanation for specific sine wave solution\n        explanation2 = Text(\"An example of a specific solution: a sine wave with amplitude A, wavenumber k, and angular frequency \u03c9.\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(description, explanation2))\n        self.wait(3)\n\n        # Clear the scene and conclude with the sine wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4}\\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries 0 and 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\left(\\frac{2^{4}}{4}\\right) - \\left(\\frac{0^{4}}{4}\\right)\")\n        self.play(ReplacementTransform(solution1, evaluation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        conclusion = Text(\"The definite integral evaluates to 4\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = x^2 - 4x + 4\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Show the area problem\n        area_problem = MathTex(r\"\\text{Area} = \\int_0^2 (x^2 - 4x + 4) \\, dx\")\n        self.play(ReplacementTransform(function_tex, area_problem))\n        self.wait(2)\n\n        # Set up the definite integral\n        setup_integral = MathTex(r\"= \\left[ \\frac{x^3}{3} - 2x^2 + 4x \\right]_0^2\")\n        self.play(Transform(area_problem, setup_integral))\n        self.wait(2)\n\n        # Calculate the area\n        calculate_area = MathTex(r\"= \\left( \\frac{8}{3} - 8 + 8 \\right) - \\left( 0 - 0 + 0 \\right)\")\n        self.play(Transform(setup_integral, calculate_area))\n        self.wait(2)\n\n        # Final answer\n        final_area = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(calculate_area, final_area))\n        self.wait(1)\n\n        # Highlighting the final answer\n        self.play(FocusOn(final_area))\n        self.wait(1)\n\n        # Cleanup and show only the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"= -\\frac{1}{3}(\\cos(\\pi) - \\cos(0)) = \\frac{2}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the function to differentiate\n        function = MathTex(r\"f(x) = x^3 + 3x^2 + 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Moving to the top of the screen\n        function_to_diff = function.to_edge(UP)\n\n        # Explanation for calculating derivative\n        explanation1 = Text(\"Calculating the derivative\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"f'(x) = 3x^2 + 6x + 2\")\n        self.play(ReplacementTransform(function.copy(), derivative_step))\n        self.wait(1)\n\n        # Explanation for finding critical points\n        explanation2 = Text(\"Find critical points\", font_size=24).to_edge(DOWN)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Critical points solution\n        critical_points_solution = MathTex(r\"x=-2, x=-\\frac{1}{3}\")\n        self.play(ReplacementTransform(derivative_step, critical_points_solution))\n        self.wait(1)\n\n        # Clearing the scene and concluding\n        self.clear()\n        self.wait(1)\n        self.play(Write(critical_points_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area to calculate\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        area_text = MathTex(r\"\\int_0^2 f(x) \\,dx\")\n        problem_group = VGroup(function, area_text).arrange(DOWN)\n        self.play(Write(problem_group))\n        self.wait(1)\n\n        # Plot the function\n        graph = FunctionGraph(lambda x: np.exp(-x**2), x_range=[0,2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = Integral(graph.curve, x_range=[0,2], color=YELLOW)\n        self.play(Write(area))\n        self.wait(2)\n\n        # Numerical approximation\n        approximation_text = Text(\"Numerical approximation:\", font_size=24).to_edge(UP)\n        self.play(Write(approximation_text))\n        self.wait(1)\n\n        # Riemann sum rectangles\n        riemann_rectangles = RiemannRectangles(graph, x_range=[0,2], dx=0.2)\n        self.play(ReplacementTransform(area.copy(), riemann_rectangles))\n        self.wait(1)\n\n        # Explanation for Riemann sum\n        explanation = Text(\"The area is approximated with rectangles\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_text, explanation))\n        self.wait(3)\n\n        # Value of the approximation\n        approximate_value = MathTex(r\"\\approx 0.8821\")\n        self.play(Write(approximate_value))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(approximate_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        apply_identity = MathTex(r\"= \\frac{1}{2}\\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, apply_identity))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4}\\cos(2x) + C\")\n        self.play(Write(integration_step.next_to(apply_identity, DOWN)))\n        self.wait(1)\n\n        # Clear the scene and display the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and its graph\n        func = lambda x: 0.1 * (x - 3) ** 2\n        graph = FunctionGraph(func, x_range=[0, 5])\n        self.play(ShowCreation(graph))\n        self.wait(1)\n\n        # Display the problem on the scene\n        problem = MathTex(r\"\\int_0^5 0.1(x-3)^2 \\,dx\")\n        problem.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation to show the area under the curve\n        area_explain = Text(\"Shaded area represents the integral\", font_size=24).next_to(problem, DOWN)\n        self.play(Write(area_explain))\n        self.wait(2)\n\n        # Shade the area under the graph\n        area = Integral(func, (x, 0, 5)).set_color(BLUE)\n        self.play(ShowCreation(area))\n        self.wait(2)\n\n        # Calculate the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{0.1}{3}(x-3)^3 \\right]_0^5\")\n        integral_solution.next_to(area_explain, DOWN)\n        self.play(Write(integral_solution))\n        self.wait(1)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\frac{0.1}{3}(5-3)^3 - \\frac{0.1}{3}(0-3)^3\")\n        self.play(ReplacementTransform(integral_solution, evaluation))\n        self.wait(2)\n\n        # Show final result\n        final_result = MathTex(r\"= 0.1(8) - 0.1(-27)\", r\"= 0.8 + 2.7\", r\"= 3.5\")\n        final_result.scale(0.8)\n        final_result.next_to(evaluation, DOWN)\n        self.play(Write(final_result))\n        self.wait(1)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Setup axes\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n        # Setup function\n        func_graph = axes.plot(lambda x: x**2, color=RED)\n        func_label = axes.get_graph_label(func_graph, label='x^2')\n\n        # Display axes and function\n        self.play(Create(axes), Create(func_graph), Write(func_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(func_graph, x_range=(0, 2), color=GREEN, opacity=0.3)\n        area_label = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=WHITE).next_to(area, UP)\n        \n        self.play(FadeIn(area), Write(area_label))\n        self.wait(1)\n        \n        # Show the definite integral value\n        answer = MathTex(r\"\\frac{8}{3}\", color=WHITE).next_to(area_label, DOWN)\n        self.play(Write(answer))\n        self.wait(1)\n\n        # Fade out all elements\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(func_label), FadeOut(area), FadeOut(area_label), FadeOut(answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{4} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the integral from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluation steps\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the graph\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.3)\n        \n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        \n        # Show the area under the curve\n        area_label = MathTex(r\"\\text{Area} = \\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        self.play(FadeIn(area), Write(area_label))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_calculation = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_label, area_calculation))\n        self.wait(1)\n\n        # Final area\n        final_area = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(area_calculation, final_area))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(final_area))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode = MathTex(r\"m \\frac{d^2x}{dt^2} + b \\frac{dx}{dt} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation of the physical context\n        explanation1 = Text(\"Damped Harmonic Oscillator\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation for the associate characteristic equation\n        explanation2 = Text(\"Associated characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Writing the characteristic equation\n        char_eq = MathTex(r\"mr^2 + br + k = 0\")\n        self.play(ReplacementTransform(ode.copy(), char_eq))\n        self.wait(2)\n\n        # Calculate the roots of the characteristic equation\n        roots_title = Text(\"Roots of the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, roots_title))\n        roots = MathTex(r\"r = \\frac{-b \\pm \\sqrt{b^2 - 4mk}}{2m}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(2)\n\n        # Display the general solution depending on the discriminant\n        solution_title = Text(\"General solution depends on the discriminant\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_title))\n        different_cases = VGroup(\n            MathTex(r\"\\text{If } \\Delta > 0: x(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t}\"),\n            MathTex(r\"\\text{If } \\Delta = 0: x(t) = (C_1 + C_2 t) e^{-bt / 2m}\"),\n            MathTex(r\"\\text{If } \\Delta < 0: x(t) = e^{-bt / 2m}(C_1 \\cos{\\omega t} + C_2 \\sin{\\omega t})\")\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.5)\n\n        self.play(Write(different_cases))\n        self.wait(2)\n\n        # Clear scene and conclude with the case of critical damping\n        self.clear()\n        self.wait(1)\n        crit_damping = Text(\"Case of critical damping (\\\\(\\\\Delta = 0\\\\))\", font_size=24)\n        crit_solution = MathTex(r\"x(t) = (C_1 + C_2 t) e^{-bt / 2m}\")\n        self.play(Write(crit_damping))\n        self.wait(1)\n        self.play(Write(crit_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (\\sin(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Evaluating the solution\n        evaluate_solution = MathTex(r\"= \\frac{1}{3} (\\sin(\\pi) - 0)\")\n        self.play(ReplacementTransform(final_solution, evaluate_solution))\n        self.wait(2)\n\n        # Solution result\n        solution_result = MathTex(r\"= 0\")\n        self.play(ReplacementTransform(evaluate_solution, solution_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 8, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes labels\n        x_label = axes.get_x_axis_label(MathTex(\"x\"))\n        y_label = axes.get_y_axis_label(MathTex(\"y\")).shift(VRIGHT)\n\n        # The function to plot\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Area under curve\n        area = axes.get_area(func_graph, x_range=[0,2], color=GREEN, opacity=0.3)\n\n        # Integral symbol\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\", font_size=30).to_corner(UR)\n\n        # Displaying the graph\n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.play(Create(func_graph))\n        self.play(FadeIn(area))\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Evaluate the integral\n        result = MathTex(r\"=\\frac{2^3}{3} - \\frac{0^3}{3}\", r\"=\\frac{8}{3}\", font_size=30).next_to(integral, DOWN)\n\n        self.play(Transform(integral, result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation of SHM\n        shm_eq = MathTex(r\"m\\ddot{x} + kx = 0\")\n        self.play(Write(shm_eq))\n        self.wait(1)\n\n        # Show the explanation for introducing angular frequency\n        explanation1 = Text(\"Introduce angular frequency\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Define angular frequency\n        omega_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(Transform(shm_eq, omega_eq))\n        self.wait(1)\n\n        # Rewrite the SHM equation using angular frequency\n        rewritten_shm = MathTex(r\"\\ddot{x} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(shm_eq.copy(), rewritten_shm))\n        self.wait(2)\n\n        # Show the solution to the SHM equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(Write(solution))\n        self.wait(1)\n\n        # Explanation for the solution\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Demonstrate the concept of phase difference\n        phase_diff = MathTex(r\"\\phi\", r\" \\text{ is the phase difference}\")\n        self.play(Write(phase_diff))\n        self.wait(2)\n\n        # Clear the scene and show only the final solution\n        self.play(FadeOut(explanation1), FadeOut(phase_diff))\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaExample(Scene):\n    def construct(self):\n        # Function to integrate\n        function_tex = MathTex(r\"f(x, y) = \\sqrt{1 - x^2 - y^2}\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explain the problem\n        problem_statement = Text(\"Find the surface area of the upper hemisphere of a unit sphere\", font_size=24).to_corner(UL)\n        self.add(problem_statement)\n        self.wait(2)\n\n        # Surface area integral in spherical coordinates\n        integral_tex = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{\\pi/2} \\sin(\\phi) d\\phi d\\theta\")\n        self.play(Transform(function_tex, integral_tex))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation_setup = Text(\"Setup the integral using spherical coordinates\", font_size=24).next_to(problem_statement, DOWN, buff=0.5)\n        self.play(Write(explanation_setup))\n        self.wait(2)\n\n        # Evaluate the phi integral\n        phi_integral = MathTex(r\"= \\int_{0}^{2\\pi} [-\\cos(\\phi)]_{0}^{\\pi/2} d\\theta\")\n        self.play(ReplacementTransform(integral_tex, phi_integral))\n        self.wait(1)\n\n        # Explanation for phi integral\n        explanation_phi = Text(\"Integrate with respect to phi\", font_size=24).next_to(explanation_setup, DOWN, buff=0.5)\n        self.play(Write(explanation_phi))\n        self.wait(2)\n\n        # Evaluated phi integral\n        evaluated_phi = MathTex(r\"= \\int_{0}^{2\\pi} 1 d\\theta\")\n        self.play(ReplacementTransform(phi_integral, evaluated_phi))\n        self.wait(1)\n\n        # Explanation for theta integral\n        explanation_theta = Text(\"Finally, integrate with respect to theta\", font_size=24).next_to(explanation_phi, DOWN, buff=0.5)\n        self.play(Write(explanation_theta))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [2\\pi \\theta]_{0}^{2\\pi} = 4\\pi\")\n        self.play(ReplacementTransform(evaluated_phi, final_solution))\n        self.wait(1)\n\n        # Display final result\n        final_result = Text(\"Surface area of the hemisphere is \\(4\\pi\\)\", font_size=24).next_to(explanation_theta, DOWN, buff=0.5)\n        self.play(Write(final_result))\n        self.wait(3)\n\n        # Conclusion of the scene\n        self.play(FadeOut(function_tex), FadeOut(problem_statement), FadeOut(explanation_setup), FadeOut(explanation_phi), FadeOut(explanation_theta), FadeOut(final_solution), FadeOut(final_result))"
  },
  {
    "text": "from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        # Write an initial text\n        text_begin = Text(\"Let's learn about quadratic functions!\", font_size=36)\n        self.play(Write(text_begin))\n        self.wait(2)\n\n        # Creating the quadratic formula\n        quadratic_formula = MathTex(r\"f(x) = ax^2 + bx + c\")\n        self.play(Transform(text_begin, quadratic_formula))\n        self.wait(2)\n\n        # Showing an example quadratic function\n        example_quadratic = MathTex(r\"f(x) = 2x^2 - 3x + 1\")\n        self.play(ReplacementTransform(quadratic_formula, example_quadratic))\n        self.wait(2)\n\n        # Showing the graph of the function\n        axes = Axes(x_range=[-3, 3], y_range=[-5, 5])\n        quadratic_graph = axes.plot(lambda x: 2*x**2 - 3*x + 1, color=BLUE)\n        graph_label = axes.get_graph_label(quadratic_graph, label='f(x)')\n\n        self.play(Write(axes), Write(quadratic_graph), Write(graph_label))\n        self.wait(2)\n\n        # Pointing out the vertex of the parabola\n        vertex_dot = Dot(axes.i2gp(-3/4, quadratic_graph), color=YELLOW)\n        vertex_annotation = Text(\"Vertex\").next_to(vertex_dot, UP)\n        self.play(FadeIn(vertex_dot), Write(vertex_annotation))\n        self.wait(2)\n\n        # Clear the scene and display the vertex formula\n        self.clear()\n        vertex_formula = MathTex(r\"Vertex\\, (h, k) = \\left( -\\frac{b}{2a}, f\\left(-\\frac{b}{2a}\\right) \\right)\")\n        self.play(Write(vertex_formula))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(\n            r\"\\iiint_D\", \"xyz\", r\"\\,dx\\,dy\\,dz\", \n            r\"\\quad (D:\", r\"\\ 0 \\leq x \\leq 1,\",\n            r\"\\ 0 \\leq y \\leq 1,\",\n            r\"\\ 0 \\leq z \\leq 1)\"\n        )\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Start with innermost integral (with respect to x)\n        explanation1 = Text(\"Integrate with respect to x:\", font_size=24).to_edge(UP)\n        inner_integral = MathTex(r\"= \\int_0^1 \\int_0^1 [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(Write(explanation1))\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(2)\n\n        # Then the middle integral (with respect to y)\n        explanation2 = Text(\"Now, integrate with respect to y:\", font_size=24).to_edge(UP)\n        middle_integral = MathTex(r\"= \\int_0^1 [\\frac{1}{2}xz(y^2)]_{0}^{1} \\,dz\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(2)\n\n        # Final integral step (with respect to z)\n        explanation3 = Text(\"Finally, integrate with respect to z:\", font_size=24).to_edge(UP)\n        final_solution = MathTex(r\"= [\\frac{1}{2}z]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(Transform(explanation1, explanation3))\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Conclude by showing the final solution\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Power rule for definite integrals\n        power_rule_definite = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule_definite))\n        self.wait(2)\n\n        # Evaluating the limits\n        limits_eval = MathTex(r\"=\\left. \\frac{x^{3}}{3} \\right|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), limits_eval))\n        self.wait(1)\n\n        # Solution after limits are substituted\n        solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(Transform(limits_eval, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Show final answer\n        final_answer = Text(\"The area under the curve from 0 to 1 is 1/3.\", font_size=24).next_to(final_solution, DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_solution), Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ \\frac{1}{3}r^3 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the inner integral bounds\n        evaluated_inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner_integral))\n        self.wait(1)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[ \\frac{1}{3} \\theta \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} \\cdot 2\\pi\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x^2yz]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}x^2 \\cdot \\frac{3}{2}y]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2}y]_{0}^{2} \\,dy\", r\"= [\\frac{3}{2}y^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicSeriesConvergence(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for divergence of the harmonic series\n        explanation1 = Text(\"The harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Divergence proof setup\n        divergence_proof = MathTex(r\"= 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + \\dots\")\n        self.play(ReplacementTransform(problem, divergence_proof))\n        self.wait(2)\n\n        # Grouping terms for comparison\n        comparison_step = MathTex(r\"> 1 + \\frac{1}{2} + \\left(\\frac{1}{4} + \\frac{1}{4}\\right) + \\left(\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8}\\right) + \\dots\")\n        self.play(ReplacementTransform(divergence_proof, comparison_step))\n        self.wait(2)\n\n        # Explanation for comparison with series that sums to infinity\n        explanation2 = Text(\"Each group in parentheses sums to at least 1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplifying the comparison\n        simplified_comparison = MathTex(r\"> 1 + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + \\dots\")\n        self.play(ReplacementTransform(comparison_step, simplified_comparison))\n        self.wait(2)\n\n        # Conclusion that the series diverges\n        conclusion = Text(\"Hence, the harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(explanation1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^{\\infty} (a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation for Fourier coefficients\n        explanation1 = Text(\"Determine the Fourier coefficients\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier coefficients equations\n        coeff_a0 = MathTex(r\"a_0 = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\, dx\")\n        coeff_an = MathTex(r\"a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(nx) \\, dx\")\n        coeff_bn = MathTex(r\"b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(nx) \\, dx\")\n        coeffs_group = VGroup(coeff_a0, coeff_an, coeff_bn).arrange(DOWN)\n        self.play(ReplacementTransform(fourier_series.copy(), coeffs_group))\n        self.wait(1)\n\n        # Explanation for partial sum\n        explanation2 = Text(\"Partial sum approximation of the series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Partial sum of Fourier series\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^{N} (a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(ReplacementTransform(coeffs_group, partial_sum))\n        self.wait(1)\n\n        # Explanation for convergence\n        explanation3 = Text(\"Convergence of the Fourier series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Visualizing the convergence of the Fourier series\n        convergence = Text(\"Visualizing the convergence for N terms...\", font_size=24)\n        self.clear()\n        self.play(Write(convergence))\n        self.wait(1)\n\n        # Final waiting time before conclusion\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass GaussianIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for switching to polar coordinates\n        explanation1 = Text(\"Use polar coordinates to solve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up polar coordinates\n        polar_setup = MathTex(r\"= \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\\right)^2\")\n        self.play(ReplacementTransform(problem.copy(), polar_setup))\n        self.wait(1)\n\n        # Showing integral over a circle\n        circle_integral = MathTex(r\"= \\int \\int e^{-(x^2 + y^2)} \\,dx\\,dy\")\n        self.play(ReplacementTransform(polar_setup, circle_integral))\n        self.wait(1)\n\n        # Transform to polar coordinates\n        polar_transform = MathTex(r\"= \\int_0^{2\\pi} \\int_0^{\\infty} e^{-r^2} r \\,dr\\,d\\theta\")\n        self.play(ReplacementTransform(circle_integral, polar_transform))\n        self.wait(1)\n\n        # Integration in polar coordinates\n        integration_polar = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(polar_transform, integration_polar))\n        self.wait(1)\n\n        # Explanation for taking the square root\n        explanation2 = Text(\"Taking the square root of the result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\sqrt{\\pi}\")\n        self.play(ReplacementTransform(integration_polar, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} \\rho^2 \\sin(\\phi) d\\rho\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}\\rho^3 \\sin(\\phi)]_{0}^{1} d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\phi) d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner_integral))\n        self.wait(1)\n        \n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (-\\cos(\\phi))]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(simplified_inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculation of the final result\n        final_result = MathTex(r\"= \\frac{1}{3} (1 - (-1)) = \\frac{2}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)\n        \n        # Complete Scene\n        complete_scene = VGroup(explanation2, final_solution, final_result).arrange(DOWN)\n        self.play(Transform(VGroup(explanation1, simplified_inner_integral, final_result), complete_scene))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explain the variables\n        variables_explanation = Text(\"m: mass, k: spring constant\", font_size=24).to_edge(UP)\n        self.play(FadeIn(variables_explanation, shift=UP))\n        self.wait(2)\n\n        # Formation of the characteristic equation\n        char_eq = MathTex(r\"\\lambda^2 + \\frac{k}{m} = 0\")\n        self.play(ReplacementTransform(diff_eq.copy(), char_eq))\n        self.wait(1)\n\n        # Explain characteristic equation\n        explanation = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(variables_explanation, explanation))\n        self.wait(2)\n\n        # Characteristic roots\n        roots = MathTex(r\"\\lambda = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution for the oscillator\n        general_solution = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation2 = Text(\"General solution for simple harmonic motion\", font_size=24).to_edge(UP)\n        self.play(Transform(variables_explanation, explanation2))\n        self.wait(2)\n\n        # Clear the scene and show only the general solution\n        self.clear()\n        final_message = Text(\"Visualizing Simple Harmonic Motion\", font_size=32)\n        self.play(FadeIn(final_message, shift=UP))\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Step to integrate by substitution\n        subst_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution evaluation\n        final_evaluation = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2 = \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integration_step, final_evaluation))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= 4 - 0 = 4\")\n        self.play(ReplacementTransform(final_evaluation, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iint_S (x^2+y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(r, \\theta) = (r\\cos\\theta, r\\sin\\theta, h(r))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the calculation of dS\n        explanation2 = Text(\"Calculate differential area element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Differential area step\n        differential_area = MathTex(r\"dS = |S_r \\times S_\\theta| \\, drd\\theta\")\n        self.play(ReplacementTransform(parameterization, differential_area))\n        self.wait(1)\n\n        # Explanation for setting limits of integration\n        explanation3 = Text(\"Set limits of integration for r and \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limits of integration step\n        limits_of_integration = MathTex(r\"\\int_0^R \\int_0^{2\\pi} (r^2) |S_r \\times S_\\theta| \\,drd\\theta\")\n        self.play(ReplacementTransform(differential_area, limits_of_integration))\n        self.wait(1)\n\n        # Explanation for final evaluation\n        explanation4 = Text(\"Evaluate the integrals\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_0^R \\int_0^{2\\pi} r^3 \\,drd\\theta\")\n        self.play(ReplacementTransform(limits_of_integration, final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the problem of finding the area under a curve\n        problem_text = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Show the graph of f(x)\n        axes = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: 0.1 * x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        \n        self.play(Create(axes), Write(graph_label))\n        self.wait(1)\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = axes.get_area(graph, x_range=[2, 8], color=[RED, ORANGE], opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n        \n        # Explanation of integral as area under the curve\n        explanation_text = Text(\"Integral represents the area under f(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Value of the definite integral\n        integral_value = MathTex(r\"A = \\int_{2}^{8} 0.1x^2 \\,dx = \\frac{4^3}{3} - \\frac{2^3}{3}\")\n        self.play(ReplacementTransform(problem_text, integral_value))\n        self.wait(1)\n\n        # Show numerical value of the area\n        numerical_value = MathTex(r\"A \\approx 21.333\")\n        self.play(FadeOut(explanation_text), ReplacementTransform(integral_value, numerical_value))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.play(Write(numerical_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # f(x) = x^2\n        func = axes.plot(lambda x: x**2, color=WHITE)\n        func_label = axes.get_graph_label(func, label='x^2')\n\n        # Area under curve\n        area = axes.get_area(func, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Display axes, function, and area\n        self.play(Write(axes), Write(func), FadeIn(func_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").to_corner(UL)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show the area calculation\n        integration_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integration_result.next_to(problem, DOWN)\n        self.play(Write(integration_result))\n        self.wait(1)\n\n        # Show definite integral result\n        final_result = MathTex(r\"= \\frac{1}{3}2^3 - \\frac{1}{3}0^3 =\", r\"\\frac{8}{3}\")\n        final_result.next_to(integration_result, DOWN)\n        self.play(ReplacementTransform(integration_result, final_result))\n        self.wait(1)\n\n        # Clear the scene and conclude with the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigFunctionExample(Scene):\n    def construct(self):\n        # Displaying the trigonometric function\n        trig_func = MathTex(r\"\\int_0^{\\frac{\\pi}{2}} \\sin(x) \\,dx\")\n        self.play(Write(trig_func))\n        self.wait(1)\n\n        # Explanation for the definite integral\n        explanation1 = Text(\"Definite integral of a trigonometric function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calc = MathTex(r\"= [-\\cos(x)]_0^{\\frac{\\pi}{2}}\")\n        self.play(ReplacementTransform(trig_func.copy(), integral_calc))\n        self.wait(1)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Solve the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 1\")\n        self.play(ReplacementTransform(integral_calc, final_result))\n        self.wait(1)\n\n        # Clear the scene and present final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2} xz^2y]_{0}^{2} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} x^2z^2y]_{-1}^{1} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2} y^2]_{0}^{1}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty}(a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"The coefficients a_n and b_n are specific to the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Display coefficients\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) dx,\\ b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(2)\n\n        # Explanation of convergence\n        explanation3 = Text(\"The series converges to f(x) as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(coefficients))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve1 = MathTex(r\"f(x) = 3x + 2\").to_edge(UP)\n        curve2 = MathTex(r\"g(x) = x^2 - 1\").next_to(curve1, DOWN)\n\n        self.play(Write(curve1))\n        self.wait(1)\n        self.play(Write(curve2))\n        self.wait(1)\n\n        problem = MathTex(r\"\\int_1^3\", r\"(3x + 2)\", r\"-\", r\"(x^2 - 1)\", r\"dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        integral_setup = MathTex(r\"= \\int_1^3\", r\"2x - x^2 + 3\", r\"dx\")\n        self.play(ReplacementTransform(problem, integral_setup))\n        self.wait(2)\n\n        evaluation = MathTex(r\"= [x^2 - \\frac{1}{3}x^3 + 3x]_1^3\")\n        self.play(ReplacementTransform(integral_setup, evaluation))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= (9 - \\frac{1}{3}(27) + 9)\", r\"-\", r\"(1 - \\frac{1}{3}(1) + 3)\")\n        self.play(ReplacementTransform(evaluation, final_answer))\n        self.wait(2)\n\n        simplified = MathTex(r\"= (9 - 9 + 9)\", r\"-\", r\"(1 - \\frac{1}{3} + 3)\")\n        self.play(ReplacementTransform(final_answer, simplified))\n        self.wait(2)\n\n        result = MathTex(r\"= 9 - 0 +\", r\"2\\frac{2}{3}\")\n        self.play(ReplacementTransform(simplified, result))\n        self.wait(2)\n\n        self.play(FadeOut(curve1), FadeOut(curve2), FadeOut(result))\n        self.wait(1)\n\n        conclusion = Text(\"The area between f(x) and g(x) from x=1 to x=3 is 11 2/3\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass LinearTransformationExample(Scene):\n    def construct(self):\n        matrix = [[1, 2], [2, 1]]\n        matrix_tex = MathTex(r\"\\begin{pmatrix} 1 & 2 \\\\ 2 & 1 \\end{pmatrix}\")\n        matrix_tex.to_edge(UP)\n\n        self.play(Write(matrix_tex))\n        self.wait(1)\n\n        # Linear transformation\n        transform_title = Text(\"Linear transformation effect\", font_size=24).to_edge(UP)\n        self.play(Transform(matrix_tex, transform_title))\n        self.wait(1)\n\n        # Create a grid and vector\n        grid = NumberPlane()\n        vector = Arrow([0, 0, 0], [1, 1, 0], buff=0, color=YELLOW)\n        self.play(Create(grid), GrowArrow(vector))\n        self.wait(1)\n\n        # Apply matrix transformation\n        transformed_vector = vector.copy()\n        transformed_vector.apply_matrix(matrix)\n        transformed_vector.set_color(RED)\n\n        self.play(Transform(vector, transformed_vector))\n        self.wait(1)\n\n        final_text = Text(\"Transformed Vector\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} \\frac{1}{2}x^2yz \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}x^2yz^2 \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for the outermost integral\n        explanation3 = Text(\"Lastly, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}x^2y\\frac{z^3}{3} \\bigg|_{0}^{1}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Calculating the definite integral\n        definite_integral = MathTex(r\"= \\frac{1}{12}\")\n        self.play(Transform(final_solution, definite_integral))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n        self.play(Write(definite_integral))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x^2yz]_{0}^{3} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} \\cdot 3x^2 \\cdot \\frac{1}{2}y^2z]_{0}^{2} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2} \\cdot 3 \\cdot \\frac{1}{2} \\cdot \\frac{1}{3}z^3]_{0}^{1}\", r\"= \\frac{3}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of parameterization of S\n        explanation1 = Text(\"Parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterized surface\n        parameterized_surface = MathTex(r\"\\vec{r}(u,v) = u\\vec{i} + v\\vec{j} + f(u,v)\\vec{k}\")\n        self.play(ReplacementTransform(problem.copy(), parameterized_surface))\n        self.wait(1)\n\n        # Explanation for cross product\n        explanation2 = Text(\"Compute the cross product of partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Cross product step\n        cross_product = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| du\\,dv\")\n        self.play(ReplacementTransform(parameterized_surface, cross_product))\n        self.wait(1)\n\n        # Explanation for dot product\n        explanation3 = Text(\"Take dot product with vector field\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Dot product step\n        dot_product = MathTex(r\"\\vec{F} \\cdot d\\vec{S} = \\vec{F} \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) du\\,dv\")\n        self.play(ReplacementTransform(cross_product, dot_product))\n        self.wait(1)\n\n        # Explanation for evaluating integral\n        explanation4 = Text(\"Evaluate the double integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integrated solution\n        integrated_solution = MathTex(r\"\\iint_D \\vec{F} \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) du\\,dv\")\n        self.play(ReplacementTransform(dot_product, integrated_solution))\n        self.wait(1)\n\n        # Solution to the problem\n        final_solution = Text(\"The surface area is given by the evaluated integral\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass EulersFormula(Scene):\n    def construct(self):\n        # Introducing Euler's formula\n        title = Text(\"Euler's Formula\").scale(1.5)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Move title up\n        self.play(ApplyMethod(title.to_edge, UP))\n        self.wait(1)\n\n        # Euler's formula\n        formula = MathTex(r\"e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\")\n        self.play(FadeIn(formula))\n        self.wait(1)\n\n        # Visualize the complex plane\n        plane = NumberPlane(\n            x_range=(-4, 4, 1), \n            y_range=(-3, 3, 1)\n        )\n        self.play(Write(plane))\n        self.wait(1)\n\n        # Angle theta on the complex plane\n        angle = ValueTracker(0)\n        radius = 2\n        line = always_redraw(lambda: Line(start=plane.c2p(0, 0), end=plane.c2p(radius * np.cos(angle.get_value()), radius * np.sin(angle.get_value())), color=BLUE))\n        dot = always_redraw(lambda: Dot(plane.c2p(radius * np.cos(angle.get_value()), radius * np.sin(angle.get_value())), color=RED))\n\n        # Add angle line and dot on the plane\n        self.play(Write(line), FadeIn(dot))\n        self.wait(1)\n\n        # Animate the angle change\n        self.play(angle.animate.set_value(2 * PI), run_time=4, rate_func=linear)\n        self.wait(1)\n\n        # Final explanation of Euler's formula\n        explanation = Text(\n            \"As theta varies, e^(i*theta) traces out the unit circle in the complex plane.\", \n            font_size=24\n        ).to_edge(DOWN)\n\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # End scene with Euler's formula\n        self.play(Write(formula))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CubicFunctionApproximation(Scene):\n    def construct(self):\n        axis = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Original function\n        original_function = axis.plot(lambda x: x**3, color=GREEN)\n        original_function_label = axis.get_graph_label(original_function, label='x^3')\n\n        self.play(Create(axis), Create(original_function), Write(original_function_label))\n        self.wait(2)\n\n        # Linear approximation\n        linear_approx = axis.plot(lambda x: 3*x - 2, color=RED)\n        linear_approx_label = axis.get_graph_label(linear_approx, label='3x-2', x_val=-2, direction=UP)\n\n        self.play(Create(linear_approx), Write(linear_approx_label))\n        self.wait(1)\n\n        # Quadratic approximation\n        quadratic_approx = axis.plot(lambda x: x**2 - 2*x + 1, color=ORANGE)\n        quadratic_approx_label = axis.get_graph_label(quadratic_approx, label='x^2-2x+1', x_val=0, direction=UP)\n\n        self.play(ReplacementTransform(linear_approx, quadratic_approx), Transform(linear_approx_label, quadratic_approx_label))\n        self.wait(1)\n\n        # Cubic approximation\n        cubic_approx = axis.plot(lambda x: 0.1*x**3 + 0.2*x**2 - 0.5*x - 1, color=PURPLE)\n        cubic_approx_label = axis.get_graph_label(cubic_approx, label='0.1x^3+0.2x^2-0.5x-1', x_val=-1, direction=UP)\n\n        self.play(ReplacementTransform(quadratic_approx, cubic_approx), Transform(quadratic_approx_label, cubic_approx_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the cubic approximation\n        self.play(Write(cubic_approx), Write(cubic_approx_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for formula of infinite geometric series\n        explanation1 = Text(\"To find S, use the formula for an infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up condition |r| < 1\n        condition = MathTex(r\"|r| < 1\")\n        self.play(Write(condition))\n        self.wait(3)\n        self.play(FadeOut(condition))\n        \n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(series.copy(), sum_formula))\n        self.wait(1)\n\n        # Explanation for geometric series convergence\n        explanation2 = Text(\"This converges only if |r| < 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example with actual numbers\n        example = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        numeric_formula = MathTex(r\"S = \\frac{1}{1-\\frac{1}{2}} = 2\")\n        self.play(Transform(series, example))\n        self.wait(1)\n        self.play(ReplacementTransform(example, numeric_formula))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(numeric_formula))\n        conclusion = Text(\"The sum of the series is 2.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the integral problem\n        integral_text = MathTex(r\"\\int_1^3\", r\"x^2\", r\"\\,dx\")\n        integral_text.to_edge(UP)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Show the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[1,3], color=BLUE)\n        area = area = Integral(curve, (1, 3), fill_opacity=0.3)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(1)\n\n        # Calculate the integral\n        calculation = MathTex(r\"=\", r\"\\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(integral_text.copy()[1], calculation))\n        self.wait(1)\n\n        # Evaluation part\n        evaluation = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", \"=\", \"9 - \\frac{1}{3}\", \"=\", r\"\\frac{26}{3}\")\n        self.play(ReplacementTransform(calculation, evaluation))\n        self.wait(1)\n\n        # Show final answer on the screen\n        final_answer = MathTex(r\"\\frac{26}{3}\").move_to(evaluation)\n        self.play(Transform(evaluation, final_answer))\n        self.wait(1)\n\n        # Conclude by showing the area equals the final answer\n        conclusion = VGroup(curve, area, final_answer).scale(0.7).to_corner(DL)\n        self.play(FadeOut(integral_text), Transform(evaluation, conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the function\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explain what the area under the curve represents\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Set up the integral\n        integral = MathTex(r\"\\int_0^2 e^{-x^2} \\,dx\")\n        self.play(Transform(function, integral))\n        self.wait(1)\n\n        # Explain numerical approximation since it can't be expressed in elementary functions\n        explanation2 = Text(\"We'll approximate the integral numerically\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, explanation2))\n        self.wait(2)\n\n        # Show approximation step\n        approximation = MathTex(r\"\\approx 0.88208\")\n        self.play(Transform(integral, approximation))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(approximation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Set up the axes\n        axes = Axes(\n            x_range=[0, 2, 0.5],\n            y_range=[0, 2, 0.5],\n            axis_config={\"color\": BLUE},\n        )\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Define the curve and area under the curve\n        curve = axes.plot(lambda x: x**2, x_range=[0, 1.5], color=RED)\n        area = axes.get_area(curve, x_range=[0, 1.5], color=RED, opacity=0.5)\n        self.play(Create(curve), FadeIn(area))\n        self.wait(1)\n\n        # Adding a label to the curve\n        curve_label = axes.get_graph_label(curve, label='x^2')\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Display the integral that represents the area\n        integral = MathTex(r\"\\int_0^{1.5} x^2 \\,dx\").next_to(area, UP)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Solving the integral, step by step\n        integral_step_1 = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^{1.5}\")\n        self.play(Transform(integral, integral_step_1))\n        self.wait(2)\n\n        integral_step_2 = MathTex(r\"=\\frac{1}{3} (1.5)^3 - \\frac{1}{3} (0)^3\")\n        self.play(Transform(integral, integral_step_2))\n        self.wait(2)\n\n        integral_solution = MathTex(r\"= \\frac{1}{3} \\cdot 3.375\")\n        self.play(Transform(integral, integral_solution))\n        self.wait(2)\n\n        integral_final = MathTex(r\"= 1.125\")\n        self.play(Transform(integral, integral_final))\n        self.wait(2)\n\n        # Clear the scene and show the final solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(integral_final))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Show area under curve\n        area = axes.get_area(graph, x_range=[0, 2])\n\n        curve_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Displaying the problem\n        problem = MathTex(r\"Area\\ under\\ y=x^2\\ from\\ x=0\\ to\\ x=2\")\n        problem.to_edge(UP)\n\n        self.play(Write(problem))\n        self.wait(1)\n        self.play(Create(axes), Create(graph))\n        self.play(FadeIn(area), Write(curve_label))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"Area is 8/3\", font_size=30).to_edge(DOWN)\n\n        self.play(ReplacementTransform(problem, conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem of a definite integral\n        problem = MathTex(r\"\\int_2^4 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule with limits of integration\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left.\\frac{x^{n+1}}{n+1}\\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step with the specific limits\n        solution1 = MathTex(r\"= \\left.\\frac{x^{3+1}}{4}\\right|_2^4\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the Fundamental Theorem of Calculus\n        evaluated_integral = MathTex(r\"= \\frac{4^{4}}{4} - \\frac{2^{4}}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_integral))\n        self.wait(1)\n\n        # Simplify the evaluation step\n        simplified_evaluation = MathTex(r\"= 64 - 4\")\n        self.play(Transform(evaluated_integral, simplified_evaluation))\n        self.wait(1)\n\n        # Final solution of the definite integral\n        final_solution = MathTex(r\"= 60\")\n        self.play(Transform(evaluated_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final confirmed solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricFunctionScene(Scene):\n    def construct(self):\n        # Display the trigonometric function\n        trig_func = MathTex(r\"f(x) = \\sin(x) + \\cos(x)\")\n        self.play(Write(trig_func))\n        self.wait(2)\n\n        # Display the trigonometric identity\n        identity = Text(\"Use a trigonometric identity\", font_size=24).to_edge(UP)\n        self.play(FadeIn(identity))\n        self.wait(2)\n\n        # Apply the identity to rewrite the function\n        rewritten_func = MathTex(r\"f(x) = \\sqrt{2}\\sin(x + \\frac{\\pi}{4})\")\n        self.play(Transform(trig_func, rewritten_func))\n        self.wait(2)\n\n        # Visualize the function's graph\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.sin(x) + np.cos(x), color=WHITE)\n        graph_label = axes.get_graph_label(graph, label=\"f(x)\")\n\n        self.play(Create(axes), Write(graph_label))\n        self.play(ShowCreation(graph))\n        self.wait(2)\n\n        # Clear the scene and display only the graph\n        self.clear()\n        self.play(Create(axes), Write(graph_label), ShowCreation(graph))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CubicFunctionDerivative(Scene):\n    def construct(self):\n        # Displaying the function to be derived\n        original_function = MathTex(r\"f(x) = x^3 + 3x^2 + 3x + 1\")\n        self.play(Write(original_function))\n        self.wait()\n\n        # Explanation for the derivative computation\n        explanation_text = Text(\"Calculating the derivative of the function:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Differentiation step by step using power rule\n        derivative_step1 = MathTex(r\"f'(x) = 3x^2 + 6x + 3\")\n        self.play(ReplacementTransform(original_function.copy(), derivative_step1))\n        self.wait(2)\n\n        # Explanation for simplifying the derivative\n        simplify_text = Text(\"The derivative is already simplified\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_text, simplify_text))\n        self.wait(2)\n\n        # Display final derivative\n        final_derivative = MathTex(r\"f'(x) = 3(x^2 + 2x + 1)\")\n        self.play(ReplacementTransform(derivative_step1, final_derivative))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait()\n\n        # Presenting the final derivative\n        self.play(Write(final_derivative))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [frac{1}{2}x y z^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n        \n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [2 x y]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for outer integral\n        explanation3 = Text(\"Lastly, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [2 x^2]_{0}^{1}\", r\"= 2\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: 0.1*(x-3)**2, x_min=-1, x_max=5)\n        area = Area(curve, x_min=1, x_max=4)\n        \n        eq = MathTex(r\"\\int_{1}^{4} 0.1 (x-3)^2 \\, dx\")\n        eq.to_edge(UP)\n\n        self.play(Write(eq), run_time=1)\n        self.wait(1)\n        \n        self.play(ShowCreation(curve), run_time=2)\n        self.play(FadeIn(area), run_time=2)\n        self.wait(2)\n        \n        result = MathTex(r'A = \\frac{1}{30} \\left[ (x - 3)^3 \\right]_{1}^{4} = \\frac{1}{30}')\n        result.next_to(area, DOWN)\n        \n        self.play(Write(result))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation for the definite integral over an interval\n        explanation1 = Text(\"Area under the curve from x = -1 to x = 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the definite integral\n        definite_integral = MathTex(r\"\\int_{-1}^1 e^{-x^2} \\,dx\")\n        self.play(ReplacementTransform(function_tex.copy(), definite_integral))\n        self.wait(1)\n\n        # Explanation of the numerical method since the integral is non-elementary\n        explanation2 = Text(\"Use numerical methods to estimate the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Numerical solution placeholder (Value would typically be procured by numerical algorithm)\n        numerical_solution = MathTex(r\"\\approx 1.493\")\n        self.play(ReplacementTransform(definite_integral, numerical_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final estimated area\n        self.clear()\n        self.wait(1)\n        self.play(Write(numerical_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation of the problem\n        explanation = Text(\"Find the area under the curve from x=1 to x=3\", font_size=24).move_to(3*UP)\n        self.play(FadeIn(explanation))\n        self.wait(2)\n\n        # Setting up the integral\n        setup_integral = MathTex(r\"= \\left[ \\frac{1}{3} x^3 \\right]_1^3\")\n        self.play(Transform(problem, setup_integral))\n        self.wait(2)\n\n        # Calculating the definite integral\n        evaluation = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\", r\"= \\frac{1}{3} (27) - \\frac{1}{3} (1)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(Transform(problem, evaluation))\n        self.wait(2)\n\n        # Presenting the final answer\n        final_answer = Text(\"Area under the curve is 26/3\", font_size=24).move_to(3*UP)\n        self.play(ReplacementTransform(explanation, final_answer))\n        self.wait(1)\n\n        # Clear the scene and show the final answer\n        self.play(FadeOut(problem))\n        self.wait(1)\n        self.play(FadeIn(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Indicate the area of interest\n        area_description = Text(\"Area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_description))\n        self.wait(2)\n\n        # Setup the definite integral\n        definite_integral = MathTex(r\"\\int_1^2 (3 - x^2) \\,dx\")\n        self.play(Transform(function, definite_integral))\n        self.wait(1)\n\n        # Steps to find the area\n        step1 = MathTex(r\"= \\left[ 3x - \\frac{x^3}{3} \\right]_1^2\")\n        self.play(ReplacementTransform(definite_integral.copy(), step1))\n        self.wait(1)\n\n        step2_description = Text(\"Calculate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(area_description, step2_description))\n        self.wait(2)\n\n        # Show the final result\n        final_area = MathTex(r\"= (6 - \\frac{8}{3}) - (3 - \\frac{1}{3})\", r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(step1, final_area))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The area is 7/3 square units\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\")\n        self.play(Write(series))\n        self.wait(1)\n        \n        # Verbal explanation\n        explanation_text = Text(\"The harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation_text))\n        self.wait(2)\n        \n        # Illustrating partial sums\n        partial_sum = MathTex(r\"s_n = \\sum_{n=1}^{N} \\frac{1}{n}\")\n        self.play(ReplacementTransform(series.copy(), partial_sum))\n        self.wait(1)\n        \n        # Show divergence\n        divergence = MathTex(r\"\\lim_{N \\to \\infty} s_N =\", r\"\\infty\")\n        self.play(Transform(partial_sum, divergence))\n        self.wait(2)\n        \n        # Discussion of the comparison test\n        explanation_test = Text(\"By the comparison test\", font_size=24).next_to(explanation_text, DOWN)\n        self.play(Write(explanation_test))\n        self.wait(2)\n        \n        # Using comparison test\n        comparison = MathTex(r\"\\frac{1}{n} > \\frac{1}{n+1}\")\n        self.play(Write(comparison))\n        self.wait(2)\n        \n        # Clear and conclude\n        self.clear()\n        self.play(Write(Text(\"Thus, the harmonic series does not converge.\", font_size=24)))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderGraphExample(Scene):\n    def construct(self):\n        # Display the graph of the function\n        axes = Axes(\n            x_range=[0, 3],\n            y_range=[0, 4],\n            x_length=5,\n            y_length=3,\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the graph\n        area = axes.get_area(graph, x_range=(0, 2), color=YELLOW, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the area under the graph\n        integral = MathTex(r\"\\int_0^2 x^2 \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Show the integral result\n        integral_result = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\")\n        self.play(Transform(integral, integral_result))\n        self.wait(2)\n\n        integral_value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(Transform(integral_result, integral_value))\n        self.wait(2)\n\n        # Show the conclusion\n        conclusion = Text(\"The area under x^2 from 0 to 2 is 8/3\", font_size=24)\n        conclusion.to_edge(DOWN)\n\n        self.play(Write(conclusion))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final area value\n        self.play(Write(integral_value))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Mention test to be used\n        test_info = Text(\"Using p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(test_info))\n        self.wait(2)\n        \n        # Show p-test criterion\n        p_test = MathTex(r\"p > 1 \\Rightarrow \\text{Convergent}\")\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Apply the test to the series\n        apply_test = MathTex(r\"p = 2 > 1 \\Rightarrow \\text{Convergent}\")\n        self.play(ReplacementTransform(p_test, apply_test))\n        self.wait(2)\n        \n        # Show convergence of the series\n        series_convergence = MathTex(r\"\\Rightarrow \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ converges}\")\n        self.play(Transform(apply_test, series_convergence))\n        self.wait(1)\n\n        # Mention the value it converges to (Basel problem)\n        convergence_value = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        self.play(Write(convergence_value))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The series converges to \\\\(\\\\frac{\\\\pi^2}{6}\\\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear everything\n        self.clear()\n        self.wait(1)\n\n        # Show the conclusion one more time\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Explanation for definite integral\n        definite_integral_explanation = Text(\"Evaluate it from the lower to the upper limit:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, definite_integral_explanation))\n        self.wait(2)\n\n        # Setting up the integral solution\n        solution1 = MathTex(r\"\\left.\\frac{x^{3+1}}{3+1}\\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for calculating the definite integral\n        explanation2 = Text(\"Calculate the values at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculating the definite integral at the bounds\n        solution2 = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(solution1, solution2))\n        self.wait(2)\n\n        # Simplifying the result\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(solution2, final_answer))\n        self.wait(2)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final answer to the problem\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the initial surface integral problem\n        problem = MathTex(r\"\\iint_{S} (x^2 + y^2 + z^2) dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization of S\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface parameterization\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (\\sin(\\phi)\\cos(\\theta), \\sin(\\phi)\\sin(\\theta), \\cos(\\phi))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(2)\n\n        # Explanation for using the parameterization\n        explanation2 = Text(\"Substitute parameterization into integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integral with parameterization substituted\n        integral_param = MathTex(r\"\\int_0^{2\\pi}\\int_0^{\\pi} \\sin^3(\\phi) d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, integral_param))\n        self.wait(1)\n\n        # Explanation for integrating over theta\n        explanation3 = Text(\"Integrate with respect to \\(\\\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integrate over theta\n        integral_theta = MathTex(r\"\\int_0^{\\pi} [\\theta \\sin^3(\\phi)]_0^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(integral_param, integral_theta))\n        self.wait(2)\n\n        # Explanation for final integration over phi\n        explanation4 = Text(\"Now integrate with respect to \\(\\\\phi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integration over phi\n        final_solution = MathTex(r\"(2\\pi) \\int_0^{\\pi} \\sin^3(\\phi) d\\phi\")\n        self.play(ReplacementTransform(integral_theta, final_solution))\n        self.wait(2)\n\n        # Final evaluation of integral\n        solution = MathTex(r\"= (2\\pi) \\left[ -\\frac{\\cos(\\phi)\\sin^2(\\phi)}{3} - \\frac{2\\cos^3(\\phi)}{9} \\right]_0^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass OscillationScene(Scene):\n    def construct(self):\n        title = Text(\"Simple Harmonic Motion\", font_size=34)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Display the equation of motion\n        equation = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation of the terms\n        explanation1 = Tex(\n            \"Where $m$ is mass, \\\\\",\n            \"$\\\\frac{d^2x}{dt^2}$ is acceleration, \\\\\",\n            \"and $k$ is the spring constant.\",\n            font_size=24\n        ).next_to(equation, DOWN)\n\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Forming the characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\", r\"\\quad \\text{where } \\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(equation.copy(), char_eq[0]))\n        self.wait(1)\n        self.play(Write(char_eq[1]))\n        self.wait(2)\n\n        # General solution with sine and cosine\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(FadeOut(explanation1), ReplacementTransform(char_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for general solution\n        explanation2 = Tex(\"General solution with arbitrary constants $A$ and $B$.\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Clear scene for final representation\n        self.clear()\n        self.play(Write(general_solution))\n        explanation3 = Tex(\"This represents the position $x(t)$ over time.\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation3))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve_text = Text(\"Area under the curve y = x^2 between x = 1 and x = 2\")\n        problem = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        self.play(Write(curve_text))\n        self.wait(1)\n        self.play(Transform(curve_text, problem))\n        self.wait(1)\n\n        # Explaining the concept of definite integral\n        explanation = Text(\"The definite integral represents the area under the curve\",\n                           font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculate the antiderivative\n        antiderivative = MathTex(r\"= \\frac{x^3}{3}\\Big|_1^2\")              \n        self.play(ReplacementTransform(problem, antiderivative))\n        self.wait(2)\n\n        # Plugging in the bounds\n        bounds_plug_in = MathTex(r\"= \\left(\\frac{2^3}{3}\\right) - \\left(\\frac{1^3}{3}\\right)\")\n        self.play(ReplacementTransform(antiderivative, bounds_plug_in))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(bounds_plug_in, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Final area is 7/3 units squared\", font_size=36)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V x^2 y^2 z \\,dV\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for z integral\n        explanation1 = Text(\"Integrate with respect to z first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Z integral step\n        z_integral = MathTex(r\"= \\iint_A x^2 y^2 \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dA\")\n        self.play(ReplacementTransform(problem.copy(), z_integral))\n        self.wait(1)\n\n        # Explanation for y integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Y integral step\n        y_integral = MathTex(r\"= \\int_B x^2 \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dx\")\n        self.play(ReplacementTransform(z_integral, y_integral))\n        self.wait(1)\n\n        # Explanation for x integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # X integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_{x_1}^{x_2} \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}\")\n        self.play(ReplacementTransform(y_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialGraphScene(Scene):\n    def construct(self):\n        # Display the function\n        func_title = MathTex(r\"f(x) = e^x\", font_size=36)\n        func_title.to_edge(UP)\n        self.play(Write(func_title))\n        self.wait(1)\n\n        # Display the graph\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        self.play(Create(axes), Write(graph), Write(graph_label))\n        self.wait(1)\n\n        # Graph transformation\n        transformation_title = Text(\"Transformation: f(x) = e^{2x}\", \nfont_size=24).to_edge(UP)\n        new_graph = axes.plot(lambda x: np.exp(2*x), color=RED)\n        new_graph_label = axes.get_graph_label(new_graph, label='e^{2x}')\n\n        self.play(\n            Transform(func_title, transformation_title),\n            ReplacementTransform(graph, new_graph),\n            ReplacementTransform(graph_label, new_graph_label)\n        )\n        self.wait(1)\n\n        # Conclusion\n        conclusion_text = Text(\"Exponential functions growth rate\", \nfont_size=24).to_edge(UP)\n        self.play(Transform(func_title, conclusion_text))\n        self.wait(1)\n\n        # Clear and show only the new graph\n        self.clear()\n        self.play(Write(func_title), Create(axes), Write(new_graph), \nWrite(new_graph_label))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CircleAreaExample(Scene):\n    def construct(self):\n        # Present the problem\n        problem = MathTex(r\"A = \\pi r^2\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show the circle and radius\n        circle = Circle(color=BLUE)\n        radius = Line(start=ORIGIN, end=RIGHT).shift(LEFT).set_color(YELLOW)\n        radius_label = MathTex(r\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromCenter(radius), Write(radius_label))\n        self.wait(2)\n\n        # Present the formula for circle area\n        formula = MathTex(r\"A = \\pi \\cdot\", \"r\", \"^2\")\n        self.play(Transform(problem, formula))\n        self.wait(2)\n\n        # Calculate the area with a specific radius\n        specific_radius = MathTex(r\"r = 2\")\n        specific_area = MathTex(r\"A = \\pi \\cdot 2^2 = 4\\pi\")\n        self.play(Write(specific_radius))\n        self.wait(1)\n        self.play(ReplacementTransform(formula.copy(), specific_area))\n        self.wait(1)\n\n        # Show the new area in the circle\n        updated_area = problem.copy().shift(DOWN * 2)\n        self.play(Transform(problem, specific_area), MoveToTarget(updated_area))\n        self.wait(1)\n\n        # Clear the scene and finish\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The area of the circle is 4 pi\", font_size=24)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the integral\n        integral_text = MathTex(r\"\\int_{2}^{4} (x^2 - 2x + 1) \\,dx\")\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Add explanation about the integrand function\n        function_explanation = Text(\"Function: x^2 - 2x + 1\", font_size=24).to_edge(UP)\n        self.play(Write(function_explanation))\n        self.wait(2)\n\n        # Show the antiderivative\n        antiderivative = MathTex(r\"= \\left[ \\frac{x^3}{3} - x^2 + x \\right]_{2}^{4}\")\n        self.play(ReplacementTransform(integral_text, antiderivative))\n        self.wait(1)\n\n        # Replace explanation with the evaluation step\n        evaluation_explanation = Text(\"Evaluate at 4 and 2\", font_size=24).to_edge(UP)\n        self.play(Transform(function_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Evaluate antiderivative at the bounds\n        evaluated_solution = MathTex(r\"= \\left( \\frac{4^3}{3} - 4^2 + 4 \\right) - \\left( \\frac{2^3}{3} - 2^2 + 2 \\right)\")\n        self.play(ReplacementTransform(antiderivative, evaluated_solution))\n        self.wait(1)\n\n        # Calculate the final result\n        final_result = MathTex(r\"= \\frac{56}{3}\")\n        self.play(Transform(evaluated_solution, final_result))\n        self.wait(1)\n\n        # Clear everything and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\left[\\frac{1}{2}xyz^2\\right]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{9}{2}xy^2\\right]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{9}{2}y^3\\right]_{0}^{1}\", r\"= \\frac{9}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Explanation for properties of solutions\n        explanation2 = Text(\"Its solutions represent waveforms propagating in time and space.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying a particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eq, particular_solution))\n        self.wait(2)\n\n        # Explanation for a harmonic wave\n        explanation3 = Text(\"This is a harmonic wave where A is amplitude, k is wavenumber, and \u03c9 is angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene for the next part\n        self.clear()\n        self.wait(1)\n\n        # Describing boundary conditions\n        boundary_conditions = Text(\"Boundary conditions can alter the form of the solutions.\", font_size=24)\n        self.play(Write(boundary_conditions))\n        self.wait(2)\n\n        # Show various boundary conditions\n        boundary_example1 = MathTex(r\"u(0, t) = 0\")\n        boundary_example2 = MathTex(r'u(L, t) = 0')\n        self.play(Write(boundary_example1))\n        self.wait(1)\n        self.play(Transform(boundary_example1, boundary_example2))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r e^{r\\theta} dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[e^{r\\theta}\\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left(e^{\\theta} - 1\\right) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluating at bounds\n        explanation3 = Text(\"Evaluate the integral at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[e^{\\theta} - \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral.copy(), final_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= e^{\\pi} - \\pi - 1\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_0^4 (4 - x^2) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the graph\n        graph = FunctionGraph(lambda x: 4 - x**2, x_range=[0, 4])\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=(0, 4), color=BLUE, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Integration to find the area\n        integration_step = MathTex(r\"= [4x - \\frac{x^3}{3}]_0^4\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the definite integral\n        explanation2 = Text(\"Evaluate the definite integral for the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (4 \\cdot 4) - \\frac{4^3}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{32}{3}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer.move_to(ORIGIN)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for converting to a closed form\n        explanation1 = Text(\"Convert the geometric series to a closed form\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Setting up the closed form expression\n        closed_form_setup = MathTex(r\"S = \\frac{a}{1 - r}, \\text{ for } |r| < 1\")\n        self.play(ReplacementTransform(problem.copy(), closed_form_setup))\n        self.wait(1)\n        \n        # Apply the closed form to a specific example\n        example_problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        self.play(Write(example_problem))\n        self.wait(1)\n        \n        # Explanation for substituting values into the formula\n        explanation2 = Text(\"Substitute values into the closed form\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation of the specific example\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}}\")\n        self.play(ReplacementTransform(example_problem, example_calculation))\n        self.wait(1)\n        \n        # Showing the final solution\n        final_solution = MathTex(r\"S = 2\")\n        self.play(ReplacementTransform(example_calculation, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Sum of the series is 2\", font_size=36)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_2^3\", r\"x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Display explanation for setting up the integration\n        explanation1 = Text(\"Find the area under the curve from 2 to 3\", font_size=24).shift(UP * 3)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration steps\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_2^3\")\n        self.play(ReplacementTransform(problem[1].copy(), integration_step.next_to(problem[0], RIGHT)))\n        self.wait(1)\n\n        # Showing explanation for evaluating the boundaries\n        explanation2 = Text(\"Evaluate at the boundaries\", font_size=24).shift(UP * 3)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(2)^3\", r\"= 9 - \\frac{8}{3}\", r\"= \\frac{19}{3}\")\n        self.play(ReplacementTransform(integration_step, final_answer))\n        self.wait(1)\n\n        # Cleaning the scene and showing the conclusion\n        self.play(FadeOut(explanation1), FadeOut(problem))\n        self.wait(1)\n        conclusion = Text(\"The area under the curve is 19/3 units\", font_size=24).shift(UP * 3)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Write the equation of the curve\n        curve_eq = MathTex(r\"y = x^2\")\n        self.play(Write(curve_eq))\n        self.wait(1)\n\n        # Explain the goal of finding the area under the curve\n        goal_text = Text(\"Find the area under the curve from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(goal_text))\n        self.wait(2)\n\n        # Display the definite integral for the area under the curve\n        integral = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Transform(curve_eq, integral))\n        self.wait(2)\n\n        # Show the steps of integration\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral, integration_steps))\n        self.wait(2)\n\n        # Evaluate the integral at bounds\n        evaluated_integral = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, evaluated_integral))\n        self.wait(2)\n\n        # Show the final area result\n        area_result = Text(\"Area under curve from 1 to 3 is \\\\(\\\\frac{26}{3}\\\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(area_result))\n        self.wait(2)\n\n        # Remove all objects from the screen\n        self.play(FadeOut(curve_eq, goal_text, evaluated_integral, area_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2\\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Mentioning type of PDE\n        type_pde = Text(\"This is the wave equation, a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(type_pde))\n        self.wait(2)\n\n        # Explaining the term c\n        speed_of_wave = Text(\"Here, c represents the speed of the wave.\", font_size=24).next_to(type_pde, DOWN)\n        self.play(Write(speed_of_wave))\n        self.wait(2)\n\n        # General solution format\n        format_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(equation, format_solution))\n        self.wait(2)\n\n        # Mentioning general solution characteristics\n        characteristics = Text(\"f and g represent arbitrary functions determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(type_pde, characteristics))\n        self.wait(2)\n\n        # Clearing the explanation\n        self.play(FadeOut(speed_of_wave), FadeOut(characteristics))\n        self.wait(1)\n\n        # Displaying general solution again, with initial condition\n        initial_condition = Text(\"u(x, 0) = \\phi(x)\", font_size=24)\n        self.play(Write(initial_condition))\n        self.wait(1)\n        self.play(Write(format_solution))\n        self.wait(2)\n\n        # Wrapping up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"This is a brief overview of the wave equation.\", font_size=24)))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        integral_problem = MathTex(r\"\\int_0^3 x^2 \\,dx\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for calculating the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Antiderivative step\n        antiderivative_step = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_problem.copy(), antiderivative_step))\n        self.wait(1)\n\n        # Solving the antiderivative\n        solve_step = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(antiderivative_step, solve_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(solve_step, final_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the integral\n        integral = MathTex(r\"\\int_{-1}^{2} (3 - x^2) \\,dx\")\n        self.play(Transform(function, integral))\n        self.wait(1)\n\n        # Show the graph of the function\n        graph = FunctionGraph(lambda x: 3 - x**2, x_range=[-1, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Fill the area under the curve\n        area = graph.get_area(-1, 2)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the antiderivative\n        antiderivative = MathTex(r\"= [\\frac{3x}{1} - \\frac{x^3}{3}]_{-1}^{2}\")\n        self.play(Transform(integral, antiderivative))\n        self.wait(1)\n\n        # Evaluating the integral at bounds\n        bounds_evaluation = MathTex(r\"= (6 - \\frac{8}{3}) - (-3 - \\frac{-1}{3})\")\n        self.play(ReplacementTransform(antiderivative, bounds_evaluation))\n        self.wait(1)\n\n        # Show the result\n        result = MathTex(r\"= \\frac{18}{3} - \\frac{8}{3} + 3 + \\frac{1}{3}\", r\"= 14\")\n        self.play(ReplacementTransform(bounds_evaluation, result))\n        self.wait(1)\n\n        # Clear the scene and show only the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = 3x^2 - 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Show the area problem\n        area_problem = MathTex(r\"\\int_1^3 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(2)\n\n        # Set up the integral\n        setup_integral = MathTex(r\"\\int_1^3\", r\"3x^2 - 2x + 1 \\,dx\")\n        self.play(Transform(area_problem, setup_integral))\n        self.wait(1)\n\n        # Perform the integration step\n        integration_step = MathTex(r\"= [\\frac{3}{3}x^3 - \\frac{2}{2}x^2 + x]_1^3\")\n        self.play(ReplacementTransform(setup_integral.copy(), integration_step))\n        self.wait(2)\n\n        # Simplify the integral result\n        simplified_result = MathTex(r\"= [x^3 - x^2 + x]_1^3\")\n        self.play(Transform(integration_step, simplified_result))\n        self.wait(2)\n\n        # Final evaluation\n        final_evaluation = MathTex(r\"= (3^3 - 3^2 + 3) - (1^3 - 1^2 + 1)\", r\"= 27 - 9 + 3 - (1 - 1 + 1)\", r\"= 20\")\n        self.play(ReplacementTransform(simplified_result, final_evaluation))\n        self.wait(2)\n\n        # Clear scene and show the final answer\n        self.clear()\n        self.play(Write(final_evaluation))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesApproximation(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = e^x\").to_edge(UP)\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display nth Taylor Polynomial at 0\n        taylor_polynomial = MathTex(r\"P_n(x) = 1 + x + \\frac{x^2}{2!} + \\cdots + \\frac{x^n}{n!}\")\n        self.play(Write(taylor_polynomial))\n        self.wait(1)\n\n        # Display its graph\n        graph = FunctionGraph(lambda x: np.exp(x), color=WHITE)\n        graph_label = MathTex(r\"y = e^x\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Explanation calculating taylor polynomial\n        explanation1 = Text(\"Calculating the 4th Taylor Polynomial\", font_size=24).to_edge(UP)\n        self.play(Transform(function, explanation1))\n        self.wait(1)\n\n        # Show 4th Taylor Polynomial\n        taylor_4th_poly = MathTex(r\"P_4(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\")\n        self.play(Transform(taylor_polynomial, taylor_4th_poly))\n        self.wait(1)\n\n        # Graph for 4th Taylor Polynomial\n        taylor_4th_graph = FunctionGraph(\n            lambda x: 1 + x + x**2 / math.factorial(2) + x**3 / math.factorial(3) + x**4 / math.factorial(4),\n            color=BLUE\n        )\n        taylor_label = MathTex(r\"P_4(x)\").next_to(taylor_4th_graph, UP)\n        self.play(Create(taylor_4th_graph), Write(taylor_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The blue curve represents the 4th Taylor Polynomial of e^x\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(taylor_label), FadeOut(taylor_4th_graph), FadeOut(conclusion), FadeOut(graph), FadeOut(graph_label), FadeOut(taylor_polynomial), FadeOut(function))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_{S} \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametrization of S\n        explanation1 = Text(\"Parametrize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametrized surface step\n        parametrized_surface = MathTex(r\"\\vec{r}(u, v) = f(u, v)\\hat{i} + g(u, v)\\hat{j} + h(u, v)\\hat{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrized_surface))\n        self.wait(1)\n\n        # Normal vector explanation\n        explanation2 = Text(\"Find the normal vector dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Normal vector calculation\n        normal_vector = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(parametrized_surface, normal_vector))\n        self.wait(1)\n\n        # Final surface integral with parametrization\n        explanation3 = Text(\"Write the surface integral with parametrization\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"\\iint_{D} \\vec{F}( \\vec{r}(u, v) ) \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) dudv\")\n        self.play(ReplacementTransform(normal_vector, final_integral))\n        self.wait(2)\n\n        # Complete the scene\n        self.play(FadeOut(final_integral), FadeOut(explanation1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Display the integral to be solved\n        integral = MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Mentioning the substitution method\n        substitution = Text(\"Using the substitution method\", font_size=24)\n        substitution.to_edge(UP)\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Choosing substitution\n        substitution_eq = MathTex(r\"u = \\sin(x), \\quad du = \\cos(x) dx\")\n        self.play(Write(substitution_eq))\n        self.wait(2)\n\n        # Rewriting the integral with u\n        rewritten_integral = MathTex(r\"= \\int u \\, du\")\n        self.play(ReplacementTransform(integral.copy(), rewritten_integral))\n        self.wait(1)\n\n        # Integration result\n        solved_integral = MathTex(r\"= \\frac{{u^2}}{2} + C\")\n        self.play(Write(solved_integral))\n        self.wait(2)\n\n        # Back-substitution\n        back_substitution = MathTex(r\"= \\frac{{\\sin^2(x)}}{2} + C\")\n        self.play(ReplacementTransform(solved_integral, back_substitution))\n        self.wait(1)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(back_substitution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function to integrate\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n        \n        # Showing the area under the curve to be calculated\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Transform(function_text, area_problem))\n        self.wait(2)\n        \n        # Drawing the curve and shaded area\n        axes = Axes(x_range=[0, 3], y_range=[0, 5], axis_config={\"include_tip\": True})\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        shaded_area = axes.get_area(graph, x_range=(0, 2), color=BLUE, opacity=0.5)\n        \n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n        \n        # Integration calculation\n        integration_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_problem, integration_result))\n        self.wait(2)\n        \n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_result.copy(), final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(shaded_area))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into a square\n        square = Square()\n        self.play(ReplacementTransform(circle, square))\n        self.wait(1)\n\n        # Animate the square changing color\n        self.play(square.animate.set_fill(BLUE, opacity=0.5))\n        self.wait(1)\n\n        # Rotate the square\n        self.play(Rotate(square, PI / 4))\n        self.wait(1)\n\n        # Clear the scene and fade in a text\n        self.clear()\n        final_text = Text(\"Transformation complete!\", font_size=36)\n        self.play(FadeIn(final_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSumExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"S_n = \\sum_{k=0}^{n} ar^k\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the geometric sum formula\n        explanation1 = Text(\"Use the geometric sum formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the sum formula\n        sum_formula = MathTex(r\"S_n = \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(problem.copy(), sum_formula))\n        self.wait(1)\n\n        # Explanation for the specific case when |r| < 1\n        explanation2 = Text(\"For |r| < 1, as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Infinite sum limit\n        infinite_sum = MathTex(r\"S = \\lim_{n \\to \\infty} \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(sum_formula, infinite_sum))\n        self.wait(1)\n\n        # Evaluating the infinite sum\n        infinite_sum_evaluated = MathTex(r\"S = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(infinite_sum, infinite_sum_evaluated))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(infinite_sum_evaluated))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExampleIntegrationByParts(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        ibp_formula = MathTex(r\"\\int u dv = uv - \\int v du\")\n        self.play(Write(ibp_formula))\n        self.wait(2)\n\n        # Choosing u and dv\n        choosing_udv = MathTex(r\"u = x\", r\",\\ dv = e^x \\,dx\")\n        self.play(Write(choosing_udv))\n        self.wait(2)\n\n        # Computing du and v\n        computing_duv = MathTex(r\"du = dx\", r\",\\ v = e^x\")\n        self.play(Write(computing_duv))\n        self.wait(2)\n\n        # Apply formula\n        applied_formula = MathTex(r\"x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(ibp_formula, applied_formula))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(applied_formula, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = MathTex(r\"f(x) = 3 - \\frac{x^3}{3}\", font_size=24).to_edge(UP)\n        axes = Axes(\n            x_range=[0, 2],\n            y_range=[0, 3],\n            axis_config={\"color\": BLUE},\n        )\n        f = lambda x: 3 - (x**3)/3\n        graph = axes.get_graph(f, color=WHITE, x_range=[0, 2])\n\n        self.play(Write(curve))\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.wait(1)\n\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        integral = MathTex(r\"\\int_0^2 (3 - \\frac{x^3}{3}) \\,dx\")\n        self.play(ReplacementTransform(curve, integral))\n        self.wait(1)\n\n        result = MathTex(r\"= [3x - \\frac{x^4}{12}]_0^2\", font_size=24)\n        result.to_edge(DOWN)\n        self.play(Transform(integral, result))\n        self.wait(1)\n\n        final_value = MathTex(r\"= (3(2) - \\frac{2^4}{12}) - (3(0) - \\frac{0^4}{12})\", r\"= 6 - \\frac{16}{12}\", r\"= 6 - \\frac{4}{3}\", r\"= \\frac{18}{3} - \\frac{4}{3}\", r\"= \\frac{14}{3}\", font_size=24)\n        final_value.next_to(result, DOWN)\n        self.play(Write(final_value))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(DOWN)\n        self.play(ReplacementTransform(final_value, conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the curve\n        ax = Axes(\n            x_range=[0, 4],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n        curve = ax.plot(lambda x: 0.25 * x**2, color=YELLOW)\n        area = ax.get_area(curve, x_range=(0, 4), color=GREEN_A, opacity=0.5)\n        self.play(Create(ax), Create(curve))\n        self.wait(1)\n        \n        # Announce the problem\n        problem_text = Text(\"Find the area under y = 0.25x^2 from x=0 to x=4\", font_size=24)\n        problem = problem_text.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(2)\n        \n        # Show the area\n        self.play(FadeIn(area))\n        self.wait(2)\n        \n        # Calculate the area\n        area_calculation = MathTex(r\"A = \\int_{0}^{4} 0.25x^2 \\,dx\")\n        area_calculation.next_to(problem, DOWN)\n        self.play(Write(area_calculation))\n        self.wait(1)\n        \n        # Show the solution\n        solution = MathTex(r\"A = \\left. \\frac{0.25x^3}{3} \\right|_0^4\")\n        solution.next_to(area_calculation, DOWN)\n        self.play(Write(solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"A = \\frac{0.25 \\cdot 4^3}{3} - \\frac{0.25 \\cdot 0^3}{3}\")\n        final_value.next_to(solution, DOWN)\n        self.play(Write(final_value))\n        self.wait(2)\n\n        final_value_simplified = MathTex(r\"A = \\frac{16}{3}\")\n        final_value_simplified.next_to(final_value, DOWN)\n        self.play(Transform(final_value, final_value_simplified))\n        self.wait(2)\n\n        # Clear the scene and show a concluding text\n        self.clear()\n        conclusion_text = Text(\"Area under the curve is 16/3 square units\", font_size=24)\n        self.wait(1)\n        self.play(Write(conclusion_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of the equation\n        explanation1 = Text(\"This is the classic wave equation for a scalar field u.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of c constant\n        explanation2 = Text(\"The constant c represents the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example of a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Explanation for this specific solution\n        explanation3 = Text(\"A harmonic wave solution of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Cleanup and conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and area\n        function = MathTex(r\"f(x) = x^2\")\n        area = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        expl_setup = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(expl_setup))\n        self.wait(2)\n\n        # Performing the integration\n        integration = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(Transform(area, integration))\n        self.wait(2)\n\n        # Explanation for definite integral\n        expl_definite = Text(\"Apply the Fundamental Theorem of Calculus\", font_size=24).to_edge(UP)\n        self.play(Transform(expl_setup, expl_definite))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{1}{3}(27) - \\frac{1}{3}(1)\", \n                                r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, final_answer))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(final_answer), FadeOut(expl_setup))\n        self.wait(1)\n        conclusion = Text(\"The area under f(x) from x=1 to x=3 is 26/3\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: 0.1 * (x - 3) ** 2, x_range=[0, 5])\n        area = Rectangle(width=5, height=3, color=BLUE, fill_opacity=0.5)\n        \n        equation = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        equation.to_edge(UP)\n\n        self.play(Write(equation))\n        self.wait(1)\n        \n        self.play(DrawBorderThenFill(area))\n        self.play(Create(curve))\n        self.wait(1)\n        \n        shaded_area_text = Text(\"Shaded Area represents A\", font_size=24)\n        shaded_area_text.next_to(area, DOWN)\n\n        self.play(Write(shaded_area_text))\n        self.wait(2)\n\n        a_brace = BraceLabel(area, \"a\", DOWN)\n        b_brace = BraceLabel(area, \"b\", DOWN)\n        self.play(GrowFromCenter(a_brace), GrowFromCenter(b_brace))\n        self.wait(1)\n        \n        final_text = Text(\"Area under the curve from a to b\", font_size=24).to_edge(DOWN)\n        self.play(Transform(shaded_area_text, final_text))\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(area), FadeOut(curve), FadeOut(equation),\n                  FadeOut(a_brace), FadeOut(b_brace), FadeOut(shaded_area_text))\n        self.wait(1)\n\n        # Show the concluding text\n        concluding_text = Text(\"Visualization Complete!\", font_size=36)\n        self.play(Write(concluding_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the differential equation\n        diff_eq = MathTex(r\"\\frac{dy}{dx} + 3y = x\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n        \n        # Displaying the integrating factor\n        int_factor = Text(\"Integrating factor: \", font_size=24).to_edge(UP)\n        mu = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.play(Write(mu))\n        self.wait(2)\n        \n        # Multiply the differential equation by integrating factor\n        modified_eq = MathTex(r\"e^{3x}\\frac{dy}{dx} + 3e^{3x}y = xe^{3x}\")\n        self.play(ReplacementTransform(diff_eq.copy(), modified_eq))\n        self.wait(1)\n        \n        # General solution before integration\n        gen_sol_before = Text(\"General solution (before integration):\", font_size=24).to_edge(UP)\n        self.play(Transform(int_factor, gen_sol_before))\n        self.wait(2)\n        \n        # Integrate both sides\n        gen_sol_after = MathTex(r\"y(x) = \\frac{e^{-3x}}{3}\\int xe^{3x}\\,dx + Ce^{-3x}\")\n        self.play(ReplacementTransform(modified_eq, gen_sol_after))\n        self.wait(1)\n        \n        # Final general solution\n        final_gen_sol = MathTex(r\"y = \\frac{1}{3}x - \\frac{1}{9} + Ce^{-3x}\")\n        self.play(Write(final_gen_sol))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Solution to the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(int_factor, conclusion))\n        self.wait(2)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_gen_sol))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CircularMotionExample(Scene):\n    def construct(self):\n        # Write the equation of the motion\n        equation = MathTex(r\"m \\vec{a} = m \\vec{g} + \\vec{T}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the terms in the equation\n        terms_explanation = Text(\"Where m is mass, a is acceleration,\\ng is gravity, and T is tension\", font_size=24).to_edge(UP)\n        self.play(FadeIn(terms_explanation, shift=UP))\n        self.wait(2)\n\n        # Transforming equation into circular motion specific form\n        circular_eq = MathTex(r\"m \\frac{v^2}{r} = m g \\cos(\\theta) + T\")\n        self.play(ReplacementTransform(equation.copy(), circular_eq))\n        self.wait(1)\n\n        # Explain circular motion equation\n        explanation1 = Text(\"Equation for circular motion in a vertical plane\", font_size=24).to_edge(UP)\n        self.play(Transform(terms_explanation, explanation1))\n        self.wait(2)\n\n        # Derive the expression for tension T\n        tension_eq = MathTex(r\"T = \\frac{m v^2}{r} - m g \\cos(\\theta)\")\n        self.play(ReplacementTransform(circular_eq.copy(), tension_eq))\n        self.wait(1)\n\n        # A visual representation of circular motion\n        circle = Circle(radius=1.5, color=BLUE)\n        dot = Dot(radius=0.1, color=RED)\n        dot.move_to(circle.get_start())\n        path = TracedPath(dot.get_center, stroke_width=2, stroke_color=RED)\n        self.add(circle, dot, path)\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.wait()\n\n        # Explain the tension in terms of circular motion\n        explanation2 = Text(\"Tension throughout the motion\", font_size=24).to_edge(UP)\n        self.play(Transform(terms_explanation, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion_text = Text(\"This is the conclusion of circular motion example.\", font_size=24)\n        self.play(FadeIn(conclusion_text, shift=UP))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CosineGraphScene(Scene):\n    def construct(self):\n        # Create a cosine graph\n        axes = Axes(\n            x_range=[-4, 4],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.get_graph(lambda x: np.cos(x), color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='\\\\cos(x)')\n\n        # Display the graph\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Derivative of cosine\n        derivative = axes.get_graph(lambda x: -np.sin(x), color=GREEN)\n        derivative_label = axes.get_graph_label(derivative, label=\"\\\\text{Derivative of } \\\\cos(x)\")\n\n        # Show the derivative\n        self.play(Create(derivative), Write(derivative_label))\n        self.wait(2)\n\n        # Antiderivative of cosine\n        antiderivative = axes.get_graph(lambda x: np.sin(x), color=PINK)\n        antiderivative_label = axes.get_graph_label(antiderivative, label=\"\\\\text{Antiderivative of } \\\\cos(x)\")\n\n        # Show the antiderivative\n        self.play(Transform(graph, antiderivative), Transform(graph_label, antiderivative_label))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Ending message\n        end_text = Text(\"This is the graph of cosine and its derivatives\", font_size=24)\n        self.play(Write(end_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the integral to solve\n        integral_formula = MathTex(r\"\\int_0^1 x^2 \\, dx\")\n        self.play(Write(integral_formula))\n        self.wait(1)\n\n        # Explanation for choosing the method of integration\n        explanation1 = Text(\"Use the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of the antiderivative\n        antiderivative_step = MathTex(r\"\\int x^2 \\, dx\", \"=\", r\"\\frac{x^3}{3}\")\n        self.play(Transform(integral_formula, antiderivative_step))\n        self.wait(1)\n\n        # Show limits of integration\n        limits = MathTex(r\"\\Big|_0^1\")\n        self.play(Write(limits.next_to(antiderivative_step, RIGHT)))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate at the bounds of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\", r\"\\frac{1}{3} - 0\", r\"=\", r\"\\frac{1}{3}\")\n        self.play(ReplacementTransform(antiderivative_step, final_solution))\n        self.wait(1)\n\n        # Showing the area under the curve graphically\n        axes = Axes(\n            x_range=[0, 1.2],\n            y_range=[0, 1],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0,1), color=GREEN, opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label=\"y = x^2\")\n\n        # Remove the previous solution and show graph with shaded area\n        self.play(FadeOut(final_solution), FadeOut(explanation1))\n        self.play(Write(axes), Write(graph), Write(graph_label))\n        self.play(FadeIn(area))\n        self.wait(1)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(area))\n        self.wait(1)\n\n        # Show the final answer by itself\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ \\frac{1}{2} r^2 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{2} \\\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final numerical solution\n        numerical_solution = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(final_solution, numerical_solution))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area inside a semicircle of radius 1\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        self.play(FadeOut(problem), FadeOut(explanation1), FadeOut(numerical_solution), FadeOut(conclusion))"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE of harmonic oscillator\n        ode = MathTex(r\"m \\frac{d^2 x}{dt^2} + b \\frac{dx}{dt} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for the physical system\n        explanation1 = Text(\"Represents a damped harmonic oscillator\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Converting the second-order ODE to a system of first-order equations\n        explanation2 = Text(\"Convert to a system of first order ODEs\", font_size=24)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # System of equations\n        system_eqs = MathTex(r\"\\begin{cases}\"\n                             r\"\\frac{dv}{dt} &= -\\frac{b}{m}v -\\frac{k}{m}x\\\\\"\n                             r\"\\frac{dx}{dt} &= v\"\n                             r\"\\end{cases}\")\n        self.play(Transform(ode, system_eqs))\n        self.wait(2)\n\n        # Initial conditions\n        init_cond = Text(\"Assume initial conditions: x(0) = x_0, v(0) = v_0\", font_size=24)\n        self.play(FadeIn(init_cond), *[\n            obj.animate.to_edge(UP) for obj in (ode, explanation1)\n        ])\n        self.wait(2)\n\n        # Show the damping ratio\n        damping_ratio = MathTex(r\"\\zeta = \\frac{b}{2\\sqrt{mk}}\")\n        self.play(Write(damping_ratio), FadeOut(explanation1, target_position=UP))\n        self.wait(2)\n\n        # Show the solution for under-damped system\n        solution_text = Text(\"Solution for under-damped:\", font_size=24)\n        solution = MathTex(r\"x(t) = e^{-\\zeta\\sqrt{k/m}t}(A\\cos(\\omega_d t) + B\\sin(\\omega_d t))\",\n                           r\",\\ \\omega_d = \\sqrt{\\frac{k}{m} - \\zeta^2}\")\n        self.play(\n            FadeIn(solution_text, target_position=DOWN),\n            ReplacementTransform(init_cond, solution)\n        )\n        self.wait(2)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the general solution\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HeatEquationSolution(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Description of the PDE\n        description = Text(\"This represents the Heat Equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n        \n        # Steady-state solution explanation\n        steady_state_explanation = Text(\"For the steady state, \\\\(\\frac{\\partial u}{\\partial t} = 0\\\\)\", font_size=24).next_to(description, UP)\n        self.play(Write(steady_state_explanation))\n        self.wait(2)\n\n        # Steady-state solution\n        steady_state = MathTex(r\"\\alpha^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Transform(pde, steady_state))\n        self.wait(2)\n\n        # General solution for steady state\n        general_solution = MathTex(r\"u(x) = C_1 x + C_2\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Boundary conditions explanation\n        boundary_conditions = Text(\"Boundary conditions can give specific values to \\\\(C_1\\\\) and \\\\(C_2\\\\).\", font_size=24)\n        self.play(Transform(description, boundary_conditions))\n        self.wait(2)\n\n        # Clear the scene before concluding\n        self.play(FadeOut(pde), FadeOut(general_solution), FadeOut(steady_state_explanation))\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Solving the Heat Equation depends on the specific scenario and constraints.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        motion_eq = MathTex(r\"m \\frac{d^2 x}{dt^2} + k x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explanation for solving the ODE\n        explanation1 = Text(\"Harmonic Oscillator Equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Reformulated equation\n        reformulated_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\frac{k}{m} x = 0\")\n        self.play(Transform(motion_eq, reformulated_eq))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation2 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\frac{k}{m} = 0\")\n        self.play(ReplacementTransform(reformulated_eq, char_eq))\n        self.wait(1)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution of motion\n        general_solution = MathTex(r\"x(t) = A \\cos\\left(\\sqrt{\\frac{k}{m}} t\\right) + B \\sin\\left(\\sqrt{\\frac{k}{m}} t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation3 = Text(\"General solution for x(t)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The harmonic oscillator's motion is sinusoidal.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for integrating over the interval\n        explanation1 = Text(\"Integrate sine over the interval from 0 to pi\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show conclusion\n        conclusion = Text(\"The integral of sine from 0 to pi is 2\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CalculusTheoremScene(Scene):\n    def construct(self):\n        # Displaying the theorem\n        theorem = MathTex(r\"\\frac{d}{dx}\\left(\\int_a^x f(t)dt\\right) = f(x)\")\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Explanation for the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Fundamental Theorem of Calculus, Part 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing differentiation step\n        differentiate_step = MathTex(r\"f(x) = \\frac{d}{dx}F(x)\")\n        self.play(ReplacementTransform(theorem, differentiate_step))\n        self.wait(1)\n\n        # Explanation for continuous function\n        explanation2 = Text(\"f(x) must be continuous on [a, b]\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final note\n        final_note = MathTex(r\"\\text{where } F(x) \\text{ is an antiderivative of } f(x)\")\n        self.play(Write(final_note.next_to(differentiate_step, DOWN)))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude by rewriting the theorem for emphasis\n        self.play(Write(theorem))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[-1]))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: x**2\n        area = self.get_area_under_curve(func, x_min=0, x_max=2)\n\n        # Display the function's graph\n        graph = self.get_graph(func, color=WHITE)\n        graph_label = self.get_graph_label(graph, label='x^2')\n\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Fill the area under the graph\n        self.play(Write(area))\n        self.wait(1)\n\n        # Calculation of the integral value\n        integral_value = MathTex(r\"\\int_0^2 x^2 \\,dx = \", r\"\\frac{2^3}{3}\", \"- \\frac{0^3}{3} = \", r\"\\frac{8}{3}\").next_to(area, DOWN)\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        # Show the final result\n        result = MathTex(r\"The area under x^2 from 0 to 2 is \", r\"\\frac{8}{3}\").next_to(integral_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(*[FadeOut(mob)for mob in self.mobjects])\n        self.wait(1)\n\n    def get_area_under_curve(self, func, x_min, x_max):\n        return self.get_riemann_rectangles(func, x_min=x_min, x_max=x_max, dx=0.1, input_sample_type='center', stroke_width=0.3)\n\n    def get_graph(self, function, **kwargs):\n        return FunctionGraph(function, **kwargs)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Presenting the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Explanation of the nature of the equation\n        explanation1 = Text(\"This is the classical wave equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Explanation for general solution form\n        explanation2 = Text(\"One solution is of the form f(x - ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Writing the solution to the wave equation\n        solution_wave_eq = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, solution_wave_eq))\n        self.wait(3)\n\n        # Explanation of the arbitrary functions f and g\n        explanation3 = Text(\"Where f and g are arbitrary functions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clearing the scene\n        self.remove(wave_eq, explanation1)\n        self.wait(1)\n\n        # Concluding with the solution\n        self.play(Write(solution_wave_eq))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ParametricCurveExample(Scene):\n    def construct(self):\n        # Parametric curve definition\n        parametric_func = ParametricFunction(\n            lambda t: np.array([\n                1.5 * np.sin(t),\n                1.5 * np.cos(t),\n                0\n            ]), t_range = np.array([0, 2*PI]), color = RED\n        )\n\n        # Display the curve\n        self.play(Create(parametric_func))\n        self.wait(2)\n\n        # Add derivative vector\n        derivative = Arrow(\n            start = ORIGIN, \n            end = np.array([1.5, 0, 0]), \n            buff = 0,\n            color = YELLOW\n        )\n        derivative_label = MathTex(r\"\\vec{s}'(t)\", color=YELLOW).next_to(derivative, UP)\n\n        self.play(GrowArrow(derivative), Write(derivative_label))\n        self.wait(2)\n\n        # Display tangent line at a point on the curve\n        tangent_line = Line(\n            start = np.array([1.5, 0, 0]),\n            end = np.array([-1.5, 0, 0]),\n            color = GREEN\n        )\n\n        self.play(Create(tangent_line))\n        self.wait(1)\n\n        # Show the point of tangency\n        dot = Dot(\n            point = np.array([1.5, 0, 0]),\n            color = BLUE\n        )\n\n        self.play(FadeIn(dot))\n        self.wait(1)\n\n        # Label the point of tangency\n        point_label = MathTex(r\"(1.5, 0)\", color=BLUE).next_to(dot, DOWN)\n\n        self.play(Write(point_label))\n        self.wait(2)\n\n        # Clean the scene\n        self.clear()\n        self.play(FadeIn(parametric_func), FadeIn(dot), FadeIn(point_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and its graph\n        f = lambda x: 0.1 * x**2\n        graph = FunctionGraph(f, x_range=[-3, 3], color=BLUE)\n\n        # Display the graph\n        graph_label = MathTex(\"y = 0.1 x^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = area = Integral(f, (x, -2, 2), fill_opacity=0.3, fill_color=GREEN)\n        self.play(Create(area))\n        self.wait(1)\n\n        # Show the definite integral notation\n        integral_notation = MathTex(r\"\\int_{-2}^{2} 0.1 x^2 \\,dx\").to_edge(UP)\n        self.play(Write(integral_notation))\n        self.wait(1)\n\n        # Calculating the area under the curve\n        calculation_steps = MathTex(r\"= [ \\frac{0.1 x^3}{3} ]_{-2}^{2}\")\n        self.play(ReplacementTransform(integral_notation.copy(), calculation_steps))\n        self.wait(2)\n\n        # Showing the final area\n        solution = MathTex(r\"= \\frac{0.1 (2)^3}{3} - \\frac{0.1 (-2)^3}{3}\", r\"= \\frac{4}{30} + \\frac{4}{30}\", r\"= \\frac{8}{30} = \\frac{4}{15}\")\n        solution.scale(0.75).next_to(calculation_steps, DOWN)\n        self.play(Write(solution))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show just the solution at the end\n        self.play(Write(solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r \\, dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Display the solution\n        solution = MathTex(r\"= \\frac{1}{2} \\pi\")\n        self.play(Write(solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}x^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude with the final solution displayed\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the first order ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for moving y term\n        move_y_explanation = Text(\"Rearrange terms\", font_size=24).to_edge(UP)\n        self.play(Write(move_y_explanation))\n        self.wait(2)\n\n        # Rearranged ODE step\n        rearranged_ode = MathTex(r\"y' = 3y\")\n        self.play(ReplacementTransform(ode, rearranged_ode))\n        self.wait(1)\n\n        # Explanation for integrating factor\n        integrating_factor_explanation = Text(\"Use an integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, integrating_factor_explanation))\n        self.wait(2)\n\n        # Integrating factor and transformed ODE\n        integrating_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        transformed_ode = MathTex(r\"\\frac{d}{dx}( ye^{3x} ) = 0\")\n        self.play(\n            ReplacementTransform(rearranged_ode, transformed_ode),\n            Write(integrating_factor)\n        )\n        self.wait(1)\n\n        # Explanation for general solution\n        general_solution_explanation = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, general_solution_explanation))\n        self.wait(2)\n\n        # Writing the general solution\n        general_solution = MathTex(r\"y = C e^{-3x}\")\n        self.play(Transform(transformed_ode, general_solution))\n        self.wait(1)\n        \n        # Conclusion statement\n        conclusion = Text(\"The function y(x) solves the ODE\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final general solution only\n        self.play(Write(general_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BouncingBall(Scene):\n    def construct(self):\n        # Create a circle to represent the ball\n        ball = Circle(radius=0.5, fill_color=BLUE, fill_opacity=0.5)\n        ball.set_stroke(BLUE)\n\n        # Define the ground line\n        ground = Line(LEFT*5, RIGHT*5)\n\n        # Initial position of the ball\n        ball.move_to(UP*2)\n\n        # Animation of the ball bouncing\n        self.play(FadeIn(ball))\n        self.play(FadeIn(ground))\n        self.wait(1)\n\n        # Bouncing motion\n        bounce_path = PathArc(arc_angle=-PI/2)\n        for _ in range(5):\n            self.play(MoveAlongPath(ball, bounce_path), rate_func=there_and_back, run_time=0.5)\n            bounce_path = bounce_path.copy().scale(0.5)\n\n        # Finish the scene\n        self.play(FadeOut(ball), FadeOut(ground))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using substitution\n        explanation1 = Text(\"Use trigonometric substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        subst_step = MathTex(r\"x = \\sin(\\theta)\")\n        self.play(FadeIn(subst_step, shift=UP))\n        self.wait(1)\n\n        # Substituted integral\n        substituted_integral = MathTex(r\"\\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplify using Pythagorean identity\n        explanation2 = Text(\"Simplify using Pythagorean identity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplified integral\n        simplified_integral = MathTex(r\"\\int \\cos^2(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(substituted_integral, simplified_integral))\n        self.wait(1)\n\n        # Integrate\n        explanation3 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(simplified_integral, final_solution))\n        self.wait(1)\n\n        # Resubstitute x back into the solution\n        explanation4 = Text(\"Resubstitute to get x back\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution with x\n        final_solution_x = MathTex(r\"= \\frac{1}{2}\\arcsin(x) + \\frac{x\\sqrt{1-x^2}}{4} + C\")\n        self.play(ReplacementTransform(final_solution, final_solution_x))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution_x))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CalculateSeriesLimit(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S_n = \\sum_{k=1}^{n} \\frac{1}{k}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for approaching infinity\n        explanation1 = Text(\"Consider the limit as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the limit\n        limit_expression = MathTex(r\"S = \\lim_{n \\to \\infty} S_n\")\n        self.play(ReplacementTransform(series.copy(), limit_expression))\n        self.wait(1)\n\n        # Explanation for harmonic series divergence\n        explanation2 = Text(\"This is the harmonic series, which diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Divergence result\n        divergence_result = MathTex(r\"\\lim_{n \\to \\infty} S_n = \\infty\")\n        self.play(ReplacementTransform(limit_expression, divergence_result))\n        self.wait(1)\n\n        # Clear the scene and show divergence\n        self.clear()\n        self.wait(1)\n        self.play(Write(divergence_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the motion equation\n        motion_eq = MathTex(r\"m\\frac{d^2x}{dt^2} = -kx\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explanation for the differential equation\n        explanation1 = Text(\"Differential equation for SHM\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Dividing both sides by m\n        reduced_eq = MathTex(r\"\\frac{d^2x}{dt^2} = -\\frac{k}{m}x\")\n        self.play(ReplacementTransform(motion_eq, reduced_eq))\n        self.wait(1)\n\n        # Explanation for angular frequency\n        explanation2 = Text(\"Introduce angular frequency\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Angular frequency equation\n        omega_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(Write(omega_eq))\n        self.wait(1)\n\n        # Final form equation of motion\n        final_eq = MathTex(r\"\\frac{d^2x}{dt^2} = -\\omega^2 x\")\n        self.play(ReplacementTransform(reduced_eq, final_eq))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation3 = Text(\"Solution for x(t)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solution of the equation\n        solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(Write(solution))\n        self.wait(1)\n\n        # Concluding text\n        conclusion = Text(\"Simple Harmonic Motion Equation\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(solution), FadeOut(conclusion), FadeOut(explanation1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDerivative(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^3 + 3x^2 + 2x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explanation for the derivative rule\n        explanation1 = Text(\"Applying the power rule of differentiation:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\frac{d}{dx} x^n = n x^{n-1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the differentiation step\n        derivative1 = MathTex(r\"= 3 x^{3-1} + 2 \\cdot 3 x^{2-1} + 2\")\n        self.play(ReplacementTransform(function.copy(), derivative1))\n        self.wait(1)\n\n        # Explanation for simplifying the expression\n        explanation2 = Text(\"Simplify the expression\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final derivative\n        final_derivative = MathTex(r\"= 3x^2 + 6x + 2\")\n        self.play(ReplacementTransform(derivative1, final_derivative))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final derivative\n        self.play(Write(final_derivative))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Display the series to be tested\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation of the convergence test\n        explanation1 = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display the p-test condition\n        p_test = MathTex(r\"p > 1\")\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Showing that p=2 satisfies the p-test (since our series has n^2)\n        satisfaction = MathTex(r\"2 > 1\")\n        self.play(Write(satisfaction))\n        self.wait(1)\n\n        # Explanation for the convergence conclusion\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Conclusion that the series converges\n        conclusion = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\", r\"\\text{ converges}\")\n        self.play(ReplacementTransform(series, conclusion[0]), Write(conclusion[1]))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define a curve function to integrate\n        curve = lambda x: x**2\n\n        # Represent the curve with a graph\n        graph = Axes(\n            x_range=[0, 2, 0.5],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        ).plot(curve, color=GREEN)\n\n        # Add label to the graph\n        graph_label = graph.get_graph_label(label=MathTex(\"x^2\"), x_val=1, direction=UP)\n        \n        # Make the area to fill under the curve\n        area = graph.get_area(graph, [0, 2])\n\n        # Display the graph\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Fill the area under the curve\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Display the integral representing the area\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Calculate the area using the antiderivative\n        integral_solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_text, integral_solution))\n        self.wait(1)\n\n        solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_solution, solution))\n        self.wait(1)\n        \n        # Clear the scene and display the solution\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of using a trigonometric identity\n        explanation1 = Text(\"Use the identity: sin(2x) = 2sin(x)cos(x)\",\n                            font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_applied))\n        self.wait(1)\n\n        # Integration of sin(2x)\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and area we're integrating over\n        func_graph = FunctionGraph(lambda x: 0.1*x**2, x_range=[-3, 3])\n        area = Integral(func_graph, x_range=[-3, 0], color=YELLOW)\n        self.play(Create(func_graph))\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the integral formula\n        integral = MathTex(r\"\\int_{-3}^{0} 0.1x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Explanation of the antiderivative\n        explanation1 = Text(\"Find the antiderivative\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the antiderivative\n        antiderivative = MathTex(r\"F(x) = \\frac{0.1}{3}x^3\")\n        self.play(Transform(integral, antiderivative))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Evaluating the integral\n        integral_value = MathTex(r\"F(0) - F(-3)\")\n        self.play(ReplacementTransform(antiderivative, integral_value))\n        self.wait(1)\n\n        # Calculate the actual area\n        area_solution = MathTex(r\"= 0 - \\left(-\\frac{0.1}{3}(-3)^3\\right)\")\n        self.play(ReplacementTransform(integral_value, area_solution))\n        self.wait(2)\n\n        # Simplify the solution\n        simplified_solution = MathTex(r\"= 0.9\")\n        self.play(Transform(area_solution, simplified_solution))\n        self.wait(2)\n\n        # Clear the scene and show the simplified solution\n        self.clear()\n        self.play(Write(simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy\\frac{1}{2}y^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}x\\frac{1}{6}y^3]_{0}^{1}\", r\"= \\frac{1}{24}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Defining the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Displaying the concept of angular frequency\n        angular_freq = Text(\"Angular Frequency: \" r\"\\(\\omega^2 = \\frac{k}{m}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq))\n        self.wait(2)\n\n        # Relating to the differential equation\n        ang_freq_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(ReplacementTransform(diff_eq.copy(), ang_freq_eq))\n        self.wait(1)\n\n        # Displaying solution approach\n        solution_approach = Text(\"Assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, solution_approach))\n        self.wait(2)\n\n        # Assumed solution\n        assumed_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(ReplacementTransform(ang_freq_eq, assumed_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation_solution = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, explanation_solution))\n        self.wait(2)\n\n        # Clear the scene and display only the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(assumed_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: x**2, x_range=[-2, 2], color=BLUE)\n        area = area = Integral(curve, (x, -2, 2), fill_opacity=0.3, fill_color=BLUE)\n        equation = MathTex(r\"A = \\int_{-2}^{2} x^2 dx\")\n\n        # Draw the curve and the equation\n        self.play(DrawBorderThenFill(curve), Write(equation))\n        self.wait(1)\n\n        # Shift equation to the top\n        self.play(ApplyMethod(equation.to_edge, UP))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(Write(area))\n        self.wait(2)\n\n        # Compute the integral with intermediate step\n        intermediate_step = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{-2}^{2}\")\n        self.play(ReplacementTransform(equation, intermediate_step))\n        self.wait(2)\n\n        # Show the final solution\n        final_solution = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(-2)^3\", r\"= \\frac{8}{3} - \\left(-\\frac{8}{3}\\right)\", r\"= \\frac{16}{3}\")\n        self.play(ReplacementTransform(intermediate_step, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SineCurveUnitCircle(Scene):\n    def construct(self):\n        # Create a unit circle and sine curve\n        circle = Circle(radius=1)\n        sine_curve = ParametricFunction(\n            lambda t : np.array([t, np.sin(t), 0]),\n            t_range = np.array([-PI, PI]),\n            color = BLUE\n        )\n\n        # Display the circle and sine curve\n        self.play(Create(circle))\n        self.play(Create(sine_curve))\n        self.wait(1)\n\n        # Create a dot that will move around the circle\n        dot = Dot(radius=0.08)\n        self.play(FadeIn(dot))\n\n        # This updater will move the dot along the unit circle\n        def update_dot(mob, dt):\n            rate = dt * 0.5  # speed of the dot\n            mob.move_to(circle.point_at_angle(rate + mob.get_center()[0]))\n\n        dot.add_updater(update_dot)\n\n        # Create a vertical line that will be used to trace the sine curve\n        vertical_line = always_redraw(\n            lambda: DashedLine(\n                start=sine_curve.get_start(),\n                end=[dot.get_center()[0], dot.get_center()[1], 0],\n                stroke_width=2,\n                dashed_ratio=0.6\n            ).set_color(RED)\n        )\n\n        # Display the vertical line and let it trace the sine curve with the dot\n        self.add(vertical_line)\n        self.wait(PI / 0.5)  # Wait until the dot makes half a revolution\n\n        # Remove the tracer line and the dot updater\n        dot.clear_updaters()\n        vertical_line.clear_updaters()\n\n        # Draw label for the sine curve\n        sine_label = Tex(\"Sine Curve\").next_to(sine_curve, DOWN)\n        self.play(Write(sine_label))\n\n        # Wait and clear the scene\n        self.wait(2)\n        self.clear()\n\n        # Show a static image of the sine curve\n        self.play(Create(sine_curve), FadeIn(sine_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: x**2\n        area = Area(\n            axes=Axes(x_range=[0, 3], y_range=[0, 9]),\n            graph=ParametricFunction(func, t_range=[0, 3]),\n            x_range=[0, 2],\n            color=BLUE,\n            opacity=0.5\n        )\n\n        # Displaying the function and the area under the curve\n        self.play(Write(area.axes), Write(area.graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Displaying the integral notation\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral_text.next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"This shaded area represents the definite integral\", font_size=24)\n        explanation.to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Solving the integral\n        solution = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\", r\"= \\frac{1}{3}(2^3) - \\frac{1}{3}(0^3)\", r\"= \\frac{8}{3}\")\n        solution.next_to(integral_text, DOWN)\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The value of the definite integral is 8/3.\", font_size=24)\n        conclusion.to_edge(DOWN + RIGHT)\n        self.play(Transform(explanation, conclusion))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r - 3 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = 3\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Show particular solution\n        particular_solution = MathTex(r\"y = e^{3x}\")\n        self.play(Write(particular_solution))\n        self.wait(1)\n\n        # Explanation for particular solution\n        explanation4 = Text(\"A particular solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(particular_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separated equation\n        sep_eq = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(diff_eq.copy(), sep_eq))\n        self.wait(1)\n\n        # Integrating both sides\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrated equation\n        integrated_eq = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integrated_eq))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(final_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clean up the scene\n        self.play(FadeOut(integrated_eq), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Define series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(2)\n\n        # Explanation for series convergence test\n        convergence_test = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_test))\n        self.wait(2)\n\n        # Showing that p > 1\n        p_value = MathTex(r\"p = 2 > 1\")\n        self.play(Write(p_value))\n        self.wait(2)\n\n        # Explanation for result\n        result_explanation = Text(\"The series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_test, result_explanation))\n        self.wait(2)\n\n        # Write the final conclusion\n        final_conclusion = MathTex(r\"\\text{The series is convergent}\")\n        self.play(ReplacementTransform(series_problem, final_conclusion))\n        self.wait(3)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy(2^2 - 0^2)]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} 2x \\,dx\", r\"= [x^2]_{0}^{1}\", r\"= 1\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem for definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{2+1} \\Bigg|_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Calculation of the definite integral\n        solution2 = MathTex(r\"= \\left. \\frac{x^3}{3} \\right|_2^3\")\n        self.play(Transform(solution1, solution2))\n        self.wait(2)\n\n        # Explanation for calculating the definite integral\n        explanation2 = Text(\"Evaluate from the bounds 2 to 3:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution for the definite integral\n        final_solution = MathTex(r\"= \\frac{3^3}{3} - \\frac{2^3}{3}\")\n        self.play(ReplacementTransform(solution2, final_solution))\n        self.wait(1)\n\n        # Simplifying the final result\n        simplified_solution = MathTex(r\"= 9 - \\frac{8}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= \\frac{19}{3}\")\n        self.play(ReplacementTransform(simplified_solution, final_result))\n        self.wait(2)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass QuadraticFormula(Scene):\n    def construct(self):\n        equation = MathTex(r\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        explanation = Text(\"Solve using the quadratic formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        formula = MathTex(r\"x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\")\n        self.play(Write(formula))\n        self.wait(2)\n\n        self.play(FadeOut(equation), ReplacementTransform(explanation, formula))\n        self.wait(1)\n\n        solutions = MathTex(r\"x_1 = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}, \\quad x_2 = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\")\n        self.play(ReplacementTransform(formula, solutions))\n        self.wait(3)\n\n        self.play(FadeOut(solutions))\n        conclude = Text(\"The solutions can be found using these values.\", font_size=24)\n        self.play(Write(conclude))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(solutions))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass InfiniteSeriesExample(Scene):\n    def construct(self):\n        # Displaying the series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for testing for convergence\n        explanation1 = Text(\"Test for convergence using integral test\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral test setup\n        integral_test = MathTex(r\"\\int_1^\\infty \\frac{1}{x^2} \\,dx\")\n        self.play(ReplacementTransform(series_problem, integral_test))\n        self.wait(1)\n\n        # Showing that the integral is convergent\n        convergent_statement = Text(\"Since the integral is convergent,\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, convergent_statement))\n        self.wait(2)\n\n        # Conclusion that the series is convergent\n        series_conclusion = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\", r\"\\ \\text{converges}\")\n        self.play(ReplacementTransform(integral_test, series_conclusion))\n        self.wait(1)\n\n        # Explanation on known result\n        explanation2 = Text(\"This is a known convergent series: Basel problem\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(series_conclusion, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Thus, the infinite series equals \")), Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BouncingBallScene(Scene):\n    def construct(self):\n        floor = Line(LEFT * 5, RIGHT * 5).shift(DOWN * 3)\n        ball = Circle(radius=0.5, fill_color=BLUE, fill_opacity=0.7).shift(UP * 2)\n\n        self.play(Write(floor))\n        self.play(DrawBorderThenFill(ball))\n        self.wait(1)\n\n        bounce_path = [ball.get_center(), DOWN * 2 + RIGHT * 0.5, UP * 1 + RIGHT * 1, DOWN * 2 + RIGHT * 1.5, UP * 0.5 + RIGHT * 2]\n        for k in range(len(bounce_path) - 1):\n            anim = AnimationGroup(\n                ApplyMethod(ball.move_to, bounce_path[k + 1], path_arc=-np.pi / 4),\n                rate_func=linear,\n                lag_ratio=0.5\n            )\n            self.play(anim)\n            self.wait(0.5)\n\n        self.play(FadeOut(ball), FadeOut(floor))"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[ \\frac{x^{n+1}}{n+1} \\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Showing the substitution step\n        substitution = MathTex(r\"= \\left[ \\frac{x^{3+1}}{4} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), substitution))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution before simplification\n        before_simplification = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(substitution, before_simplification))\n        self.wait(1)\n\n        # Final solution after simplification\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(before_simplification, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using u substitution\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # U substitution step\n        u_sub_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"du = 2 \\,dx\", r\"\\quad\", r\"\\frac{du}{2} = dx\")\n        self.play(Write(u_sub_step))\n        self.wait(2)\n\n        # Adjust the problem after substitution\n        problem_after_sub = MathTex(r\"\\int \\frac{1}{2} e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), problem_after_sub))\n        self.play(FadeOut(u_sub_step))\n        self.wait(2)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem_after_sub, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaParametricSurfaceExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(\n            r\"\\iint_D \\sqrt{1 + \\left(\\frac{\\partial z}{\\partial x}\\right)^2 + \\left(\\frac{\\partial z}{\\partial y}\\right)^2}\\,dA\"\n        )\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametric representation\n        explanation1 = Text(\"Parametrize the surface with u and v\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametric surface\n        parametric_surface = MathTex(\n            r\"x = f(u, v), \\quad y = g(u, v), \\quad z = h(u, v)\"\n        )\n        self.play(ReplacementTransform(problem, parametric_surface))\n        self.wait(1)\n\n        # Explanation for cross product\n        explanation2 = Text(\"Cross the partial derivatives of the position vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Cross product notation\n        cross_product = MathTex(\n            r\"\\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\"\n        )\n        self.play(ReplacementTransform(parametric_surface, cross_product))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation3 = Text(\"Set up the surface integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Setup integral\n        setup_integral = MathTex(\n            r\"\\iint_S \\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\\,dA\"\n        )\n        self.play(ReplacementTransform(cross_product, setup_integral))\n        self.wait(1)\n\n        # Explanation for the final step\n        explanation4 = Text(\"Compute the integral over the domain D\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(\n            r\"\\iint_D \\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\\,dA\"\n        )\n        self.play(ReplacementTransform(setup_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint\\limits_S\", r\" \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"First, parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parametrization = MathTex(r\"\\vec{r}(u, v) = u\\vec{i} + v\\vec{j} + f(u,v)\\vec{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrization))\n        self.wait(2)\n\n        # Explanation for the dot product with the normal vector\n        explanation2 = Text(\"Compute the dot product of F and the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Dot product step\n        dot_product = MathTex(r\"\\vec{F} \\cdot (r_u \\times r_v)\")\n        self.play(ReplacementTransform(parametrization, dot_product))\n        self.wait(2)\n\n        # Explanation for integral calculation\n        explanation3 = Text(\"Evaluate the double integral over the region D\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integral calculation\n        integral_calculation = MathTex(r\"\\iint\\limits_D\", r\" \\vec{F} \\cdot (r_u \\times r_v) \\,du \\,dv\")\n        self.play(ReplacementTransform(dot_product, integral_calculation))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"\\text{Flux} = \\int\\int_D ... \\,du \\,dv\")\n        self.play(ReplacementTransform(integral_calculation, final_answer))\n        self.wait(1)\n\n        # Conclusion of the scene\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration method\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        subst_step = MathTex(r\"\\frac{1}{2} \\int e^u \\,du\", r\", \\text{ where } u = 2x\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n        \n        # Explanation for the integration result\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n\n        # Show final result on a clean scene\n        final_result = MathTex(r\"\\int e^{2x} \\,dx = \\frac{1}{2}e^{2x} + C\")\n        self.play(Write(final_result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}yz]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Lastly, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(Transform(problem, char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solving for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i \\omega\")\n        self.play(Transform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = A \\cos(\\omega x) + B \\sin(\\omega x)\")\n        self.play(FadeIn(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion with the general solution\n        self.play(FadeOut(explanation1), FadeOut(roots))\n        self.wait(1)\n        conclusion = Text(\"Simple harmonic motion equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion), FadeOut(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CosineSquaredIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Using a trigonometric identity for cosine squared\n        explanation1 = Text(\"Use power-reduction formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power-reduction identity step\n        trig_step = MathTex(r\"\\int \\frac{1 + \\cos(2x)}{2} \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), trig_step))\n        self.wait(1)\n\n        # Explanation for integral of sum\n        explanation2 = Text(\"Integrate term-by-term\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after integration\n        final_solution = MathTex(r\"= \\frac{x}{2} + \\frac{1}{4}\\sin(2x) + C\")\n        self.play(ReplacementTransform(trig_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and display the final solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Introduce the characteristic equation\n        char_eq_intro = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(char_eq_intro))\n        self.wait(2)\n\n        # Display the characteristic polynomial\n        char_poly = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(ReplacementTransform(diff_eq, char_poly))\n        self.wait(2)\n\n        # Show how to solve the characteristic polynomial\n        solve_char_eq = Text(\"Solve the cubic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_intro, solve_char_eq))\n        self.wait(2)\n\n        # Solve the polynomial\n        polynomial_roots = MathTex(r\"r = 1\")\n        self.play(ReplacementTransform(char_poly, polynomial_roots))\n        self.wait(2)\n\n        # Display the general solution to the differential equation\n        general_solution = MathTex(r\"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Explain the general solution\n        general_solution_explanation = Text(\"General solution to the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_intro, general_solution_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate the general solution at the end\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration\n        explanation1 = Text(\"Calculate the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4}\\Bigg|_{0}^{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution evaluation\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Showing the integral problem\n        integral_problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        inner_explanation = Text(\"Inner integral with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(inner_explanation))\n        self.wait(2)\n\n        # Inner integral solution\n        inner_solution = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(integral_problem, inner_solution))\n        self.wait(1)\n\n        # Replace explanation for outer integral\n        outer_explanation = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(inner_explanation, outer_explanation))\n        self.wait(2)\n\n        # Outer integral solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_solution, final_solution))\n        self.wait(1)\n\n        # Conclusion text\n        conclusion_text = Text(\"The area is \\(\\frac{2\\pi}{3}\\).\", font_size=24).to_edge(UP)\n        self.play(Transform(inner_explanation, conclusion_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExponentIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(ReplacementTransform(problem.copy(), parts_formula))\n        self.wait(1)\n\n        # Define u and dv\n        u_and_dv = MathTex(r\"u=x^2\", r\", \\quad dv=e^x\\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Define du and v\n        du_and_v = MathTex(r\"du=2x \\,dx\", r\", \\quad v=e^x\")\n        self.play(Transform(u_and_dv, du_and_v))\n        self.wait(2)\n\n        # Apply the formula\n        substitute_parts = MathTex(r\"x^2 e^x - \\int 2x e^x \\,dx\")\n        self.play(ReplacementTransform(parts_formula, substitute_parts))\n        self.wait(2)\n\n        # Solve the remaining integral\n        final_integration = MathTex(r\"x^2 e^x - \\left( 2xe^x - 2\\int e^x \\,dx \\right)\")\n        self.play(Transform(substitute_parts, final_integration))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x^2 e^x - 2xe^x + 2e^x + C\")\n        self.play(ReplacementTransform(final_integration, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode_text = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n        \n        # Explain the concept of angular frequency\n        explanation1 = Text(\"Angular frequency\", font_size=24).to_edge(UP)\n        angular_freq = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(Write(explanation1))\n        self.wait(1)\n        self.play(FadeIn(angular_freq, shift=DOWN))\n        self.wait(2)\n\n        # Rewrite the ODE using angular frequency\n        rewritten_ode = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Transform(ode_text, rewritten_ode))\n        self.wait(1)\n        \n        # Solution of the ODE\n        explanation2 = Text(\"Solution of the ODE\", font_size=24).to_edge(UP)\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Visual Representation\n        explanation3 = Text(\"Harmonic motion visualization\", font_size=24).to_edge(UP)\n        oscillator = Circle(radius=1).set_stroke(color=WHITE, opacity=0.5)\n        dot = Dot(oscillator.get_right(), color=RED)\n        path = TracedPath(dot.get_center, stroke_color=RED, stroke_opacity=0.6)\n        self.play(Transform(explanation1, explanation3))\n        self.play(FadeIn(oscillator), FadeIn(dot))\n        self.add_foreground_mobject(dot)\n        self.remove(angular_freq, rewritten_ode, general_solution)\n        self.play(MoveAlongPath(dot, oscillator), run_time=2, rate_func=linear)\n        self.add(path)\n        self.wait(2)\n\n        # Conclusion and clearing the scene\n        self.play(FadeOut(oscillator), FadeOut(dot), FadeOut(path), FadeOut(explanation1))\n        self.wait(1)\n        final_text = Text(\"Harmonic oscillator dynamics\", font_size=24)\n        self.play(Write(final_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2\\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3\\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the antiderivative at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Highlighting the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        area = area = self.get_area(curve, 0, 2)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show antiderivative formation\n        antiderivative = MathTex(r\"= \\frac{1}{3}x^3 \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), antiderivative))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(antiderivative, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Describe the wave equation\n        desc1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(desc1))\n        self.wait(2)\n\n        # Explanation of wave speed\n        explain_speed = Text(\"Here, c represents the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Transform(desc1, explain_speed))\n        self.wait(2)\n\n        # Displaying the one-dimensional solution\n        one_dim_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, one_dim_solution))\n        self.wait(2)\n\n        # Explanation for the one-dimensional solution\n        explain_one_dim = Text(\"General solution for the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Transform(desc1, explain_one_dim))\n        self.wait(2)\n\n        # Clear the scene and conclude with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(one_dim_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for applying the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Using the Fundamental Theorem of Calculus:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the integration\n        integration = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(integration))\n        self.wait(2)\n\n        # Performing the integration step with limits\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluation of the definite integral\n        evaluated_integral = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2\")\n        self.play(ReplacementTransform(solution1, evaluated_integral))\n        self.wait(1)\n\n        # Simplifying the expression\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(evaluated_integral, final_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separation of variables step\n        sep_eq = MathTex(r\"\\frac{1}{y} dy = 3 dx\")\n        self.play(ReplacementTransform(problem.copy(), sep_eq))\n        self.wait(1)\n\n        # Explanation for integrating\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrating both sides\n        integration = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integration))\n        self.wait(1)\n\n        # Explanation for solving for y\n        explanation3 = Text(\"Solve for y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solve for y to find the general solution\n        general_solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(integration, general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation4 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Drawing the curve\n        curve_graph = FunctionGraph(lambda x: x**2, x_range=[-3, 3])\n        self.play(Create(curve_graph))\n        self.wait(2)\n\n        # Indicating the area under the curve\n        area_label = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Shading the area\n        area = area = self.get_area(curve_graph, (1, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Integral representation\n        integral = MathTex(r\"\\int_{1}^{2} x^2 \\,dx\")\n        self.play(Transform(area_label, integral))\n        self.wait(2)\n\n        # Calculation\n        calculated_area = MathTex(r\"=\\frac{1}{3}\\left[2^3 - 1^3\\right]\").to_edge(DOWN)\n        self.play(Write(calculated_area))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{1}{3}(8 - 1) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(calculated_area, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Compute the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration steps\n        integral_steps = MathTex(\n            r\"\\int 2x \\,dx\",\n            r\"= x^2 + C\\bigg|_1^3\",\n            r\"= 3^2 - 1^2\",\n            r\"= 9 - 1\",\n            r\"= 8\",\n        )\n\n        # Align and animate the steps\n        integral_steps.arrange(DOWN, center=False, aligned_edge=LEFT)\n        for step in integral_steps:\n            self.play(Write(step))\n            self.wait(2)\n        \n        # Clear the screen\n        self.clear()\n        self.wait(1)\n\n        # Display final result\n        final_result = MathTex(r\"\\int_{1}^{3} 2x \\,dx = 8\")\n        self.play(FadeIn(final_result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExampleIntegrationByParts(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Step for setting u and dv\n        set_uv = MathTex(r\"u = x, \\ dv = e^x \\,dx\")\n        self.play(Write(set_uv))\n        self.wait(2)\n\n        # Explanation for integration by parts\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(FadeIn(parts_formula))\n        self.wait(2)\n\n        # Steps for computing the integration by parts\n        integration_steps = MathTex(r\"= x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integration_steps))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(integration_steps, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(parts_formula), FadeOut(set_uv))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricFunctionScene(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"\\sin(x) + \\cos(x) = 1\")\n        self.play(FadeIn(function))\n        self.wait(1)\n\n        # Display properties\n        properties = Text(\"This is not an identity!\", font_size=24).to_edge(UP)\n        self.play(Write(properties))\n        self.wait(2)\n\n        # Correcting the function\n        correct_function = MathTex(r\"\\sin^2(x) + \\cos^2(x) = 1\")\n        self.play(Transform(function, correct_function))\n        self.wait(1)\n\n        # Identity property explanation\n        identity_explanation = Text(\"This is the Pythagorean trigonometric identity.\", font_size=24).to_edge(UP)\n        self.play(Transform(properties, identity_explanation))\n        self.wait(2)\n\n        # Graphical representation\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1.5, 1.5, 1])\n        sin_curve = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_curve = axes.plot(lambda x: np.cos(x), color=RED)\n        sin_label = axes.get_graph_label(sin_curve, label='\\\\sin(x)')\n        cos_label = axes.get_graph_label(cos_curve, label='\\\\cos(x)')\n\n        graph_group = VGroup(axes, sin_curve, cos_curve, sin_label, cos_label).scale(0.6).to_edge(DOWN)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(correct_function), FadeIn(identity_explanation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Display the differential equation\n        deqn = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(deqn))\n        self.wait(2)\n\n        # Introduce the characteristic equation\n        char_eq_label = Text(\"Characteristic equation:\", font_size=24).to_edge(UP)\n        self.play(Write(char_eq_label))\n        self.wait(1)\n\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(ReplacementTransform(deqn.copy(), char_eq))\n        self.wait(2)\n\n        # Solve the characteristic equation\n        solution_label = Text(\"Solution for r:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_label, solution_label))\n        self.wait(1)\n\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(2)\n\n        # General form of the solution\n        gen_sol_label = Text(\"General solution:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_label, gen_sol_label))\n        self.wait(1)\n\n        gen_sol = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(gen_sol))\n        self.wait(3)\n\n        # Clear the scene and emphasize the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(gen_sol_label))\n        self.play(Write(gen_sol))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Describing the system\n        system_description = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        system_description.to_edge(UP)\n        self.play(Write(system_description))\n        self.wait(2)\n\n        # Explaining terms\n        terms_explanation = Text(\"Where m is mass, k is the spring constant.\", font_size=24)\n        terms_explanation.to_edge(UP)\n        self.play(Transform(system_description, terms_explanation))\n        self.wait(2)\n\n        # Displaying the solution\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n\n        # Explaining the solution\n        solution_explanation = Text(\"A is amplitude, \u03c9 is angular frequency, and \u03d5 is phase.\", font_size=24)\n        solution_explanation.to_edge(UP)\n        self.play(Transform(system_description, solution_explanation))\n        self.wait(2)\n\n        # Conclusion statement\n        conclusion = Text(\"Simple harmonic motion is periodic and sinusoidal.\", font_size=24)\n        conclusion.to_edge(UP)\n        self.play(Transform(system_description, conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        conclusion.set_opacity(0)  # Hide conclusion without removal animation\n        self.play(FadeIn(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        function_label = MathTex(\"f(x)\", \"=\", \"x^2\").to_edge(UP)\n        function = FunctionGraph(lambda x: x**2, x_range=[-2, 2], color=BLUE)\n        \n        # Display the function\n        self.play(Write(function_label))\n        self.play(Create(function))\n        self.wait(1)\n\n        # Shade the area under the curve\n        area = area = self.get_area(graph=function, x_range=[-1, 1])\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Display the area problem\n        problem = MathTex(r\"A = \\int_{-1}^{1} x^2 \\,dx\").next_to(function_label, DOWN)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integration\n        solution = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{-1}^{1}\").next_to(problem, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Final area value\n        final_value = MathTex(r\"A = \\frac{2}{3}\").next_to(solution, DOWN)\n        self.play(Transform(problem, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        final_message = Text(\"Area calculated!\", font_size=36)\n        self.play(Write(final_message))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define an axis system\n        axes = Axes(\n            x_range=[-1, 5],\n            y_range=[-1, 5],\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Define the curve and the area under the curve\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0,2), color=GREY)\n\n        # Displaying the curve\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n\n        # Showing the area under the curve between 0 and 2\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").shift(UP*3)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Animating the area\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Evaluate the integral\n        integral_value = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_value))\n        self.wait(1)\n\n        # Calculate the specific values\n        final_value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_value, final_value))\n        self.wait(2)\n\n        # Clear the scene and show the final area value\n        self.play(FadeOut(area), FadeOut(curve), FadeOut(axes))\n        self.play(Transform(final_value, MathTex(r\"\\frac{8}{3}\").move_to(ORIGIN)))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\int e^{2x} \\,dx = \\frac{1}{2}e^{2x}\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Explanation for the constant of integration\n        explanation2 = Text(\"Don't forget the constant of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"\\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: 0.1 * x**2\n        area = area = self.get_area(func, 0, 4)\n\n        # Plot the function\n        graph = self.get_graph(func, color=WHITE)\n        graph_label = self.get_graph_label(graph, label='y = 0.1x^2')\n\n        self.play(ShowCreation(graph), Write(graph_label))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Annotate the area\n        area_label = MathTex(r\"\\int_0^4 0.1x^2 \\,dx\", color=WHITE)\n        area_label.next_to(area, DOWN)\n\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Calculate the definite integral on screen\n        definite_integral = MathTex(r\"= [ \\frac{0.1x^3}{3} ]_0^4\")\n        self.play(ReplacementTransform(area_label, definite_integral))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"= \\frac{0.1 \\cdot 4^3}{3} - \\frac{0.1 \\cdot 0^3}{3}\", r\"= \\frac{6.4}{3}\", r\"= \\frac{64}{30}\")\n        self.play(ReplacementTransform(definite_integral, final_result))\n        self.wait(2)\n\n        # Display the final answer as a decimal\n        decimal_result = MathTex(r\"\\approx 2.13\")\n        self.play(Transform(final_result, decimal_result))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.play(ShowCreation(graph), Write(graph_label), FadeIn(area, scale=0.5), Write(decimal_result))\n        self.wait(2)\n\n    def get_area(self, func, t_min, t_max):\n        area = Integral(func, (t_min, t_max))\n        return area\n\n    def get_graph(self, func, **kwargs):\n        graph = FunctionGraph(func, **kwargs)\n        return graph"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\", r\" \\Bigg|_0^2\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\" \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds\n        integral_bound = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(solution1, integral_bound))\n        self.wait(1)\n\n        # Evaluating the bounds\n        solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integral_bound, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - 0\", \"=\", \"4\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)\n"
  },
  {
    "text": "from manim import *\n\nclass ParabolaTangentExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"y = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Drawing the parabola graph\n        graph = FunctionGraph(lambda x : x**2, color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n        \n        # Explanation for tangent line at x = 1\n        explanation1 = Text(\"Tangent at x = 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Tangent line at x = 1\n        tangent_eq = MathTex(r\"y = 2x - 1\").next_to(explanation1, DOWN)\n        self.play(Write(tangent_eq))\n        \n        tangent_line = FunctionGraph(lambda x : 2*x - 1, color=YELLOW)\n        self.play(Create(tangent_line))\n        self.wait(2)\n\n        # Explanation for slope of the tangent\n        explanation2 = Text(\"Slope of the tangent is 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        tangent_slope = MathTex(r\"\\frac{dy}{dx} = 2\").next_to(tangent_eq, DOWN)\n        self.play(Write(tangent_slope))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        conclusion_text = Text(\"Tangents to parabolas\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        self.play(Create(graph), Write(tangent_line))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C, \", r\"(n \\neq -1)\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating limits\n        explanation2 = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the definite integral\n        evaluated_solution = MathTex(r\"= \\frac{3^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4}\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Use the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integral_step = MathTex(r\"\\int_0^2 x^2 \\,dx = \\frac{x^3}{3} \\Bigg|_0^2\")\n        self.play(Transform(problem, integral_step))\n        self.wait(2)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{2^3}{3} - \\frac{0^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        function = MathTex(r\"f(x) = x^2\")\n        area_question = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=YELLOW)\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area_question))\n        self.wait(1)\n\n        # Drawing the graph\n        graph = FunctionGraph(lambda x: x**2, x_range=[0, 2], color=WHITE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Filling the area under the graph\n        area = graph.get_riemann_rectangles(x_range=[0, 2], dx=0.1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Explanation of Area Computation\n        explanation1 = Text(\"The area under curve is the integral result\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Computing the area\n        area_computation = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(Write(area_computation))\n        self.wait(2)\n\n        # Showing the final result\n        final_result = MathTex(r\"= \\left[\\frac{2^3}{3}\\right] - \\left[\\frac{0^3}{3}\\right]\")\n        self.play(Transform(area_computation, final_result))\n        self.wait(1)\n\n        # Simplifying the result\n        simplified_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(area_computation, simplified_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(function), FadeOut(area_question), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(simplified_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}x^2yz]_{-1}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}yz]_{-1}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x y z^2]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2} x^2 y]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{3}{2} y^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The triple integral evaluates to 3/2\", font_size=24)\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\sum_{n=1}^{\\infty}\\frac{1}{n^2}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Convergence test using p-series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Test setup\n        test_setup = MathTex(r\"p=2\", r\"\\ \\text{is larger than 1, so the series converges}\")\n        self.play(Write(test_setup))\n        self.wait(1)\n\n        # Show convergence explanation\n        explanation2 = Text(\"Since p > 1, the p-series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Partial sum explanation\n        partial_sum_explanation = Text(\n            \"Consider the partial sum S_m\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, partial_sum_explanation))\n        self.wait(2)\n\n        # Displaying partial sum\n        partial_sum = MathTex(r\"S_m = \\sum_{n=1}^{m} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(problem.copy(), partial_sum))\n        self.wait(1)\n\n        # Explanation for limiting behavior\n        explanation3 = Text(\n            \"Evaluate the limit of partial sums as m approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limit of partial sums\n        limit_of_sums = MathTex(r\"\\lim_{m \\to \\infty}\", r\"S_m\")\n        self.play(ReplacementTransform(partial_sum, limit_of_sums))\n        self.wait(1)\n\n        # Result\n        result = MathTex(\n            r\"= \\frac{\\pi^2}{6}\", r\"\\ \\text{(Basel problem solution)}\")\n        self.play(FadeIn(result, shift=DOWN))\n        self.wait(1)\n\n        # Clear the scene and show only result\n        self.clear()\n        self.play(Write(result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesApproximation(Scene):\n    def construct(self):\n        # Display the function to be approximated\n        function_tex = MathTex(r\"f(x) = e^x\").to_edge(UP)\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Show the Taylor series approximation text\n        approx_text = Tex(\n            \"Taylor series approximation of \", r\"$f(x)$\", r\" up to nth term:\",\n            font_size=24\n        ).next_to(function_tex, DOWN)\n        self.play(Write(approx_text))\n        self.wait(2)\n\n        # Taylor series up to 4 terms\n        taylor = MathTex(\n            r\"f(x) \\approx 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\"\n        )\n        self.play(Write(taylor))\n        self.wait(2)\n\n        # Show the Taylor polynomial of degree 4\n        taylor_polynomial = MathTex(\n            r\"P_4(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\"\n        ).next_to(taylor, DOWN)\n        self.play(Transform(taylor, taylor_polynomial))\n        self.wait(2)\n\n        # Graph f(x) and P_4(x)\n        graph_group = VGroup()\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        ).to_edge(DOWN)\n\n        exp_function = axes.plot(lambda x: np.exp(x), color=GREEN)\n        taylor_graph = axes.plot(lambda x: 1 + x + x**2/2 + x**3/6 + x**4/24, color=YELLOW)\n\n        original_graph_label = axes.get_graph_label(exp_function, label='f(x)=e^x')\n        taylor_graph_label = axes.get_graph_label(taylor_graph, label='P_4(x)', x_val=2, direction=UP)\n\n        graph_group.add(axes, exp_function, taylor_graph, original_graph_label, taylor_graph_label)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Clear the scene and present only the graphs\n        self.play(FadeOut(taylor_polynomial), FadeOut(approx_text), FadeOut(function_tex))\n        self.wait(3)\n\n        # Highlight the difference in a certain interval\n        interval_highlight = axes.get_riemann_rectangles(exp_function, x_range=[-1, 1], dx=0.1)\n        self.play(ShowCreation(interval_highlight))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass CalculateEulerNumber(Scene):\n    def construct(self):\n        # Describe the problem\n        problem_text = MathTex(r\"e = \\lim_{{n \\to \\infty}} \\left(1 + \\frac{1}{n}\\right)^n\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Introduce the approximation concept\n        approximation_explanation = Text(\n            \"Approximate with a large value of n\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(approximation_explanation))\n        self.wait(2)\n\n        # Show the approximation with a tangible n\n        approximation = MathTex(r\"\\approx \\left(1 + \\frac{1}{100}\\right)^{100}\")\n        self.play(ReplacementTransform(problem_text.copy(), approximation))\n        self.wait(1)\n\n        # Calculate the numerical approximation\n        numerical_result_text = Text(\"Numerical result\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_explanation, numerical_result_text))\n        self.wait(2)\n\n        # Show numerical result\n        numerical_result = MathTex(fr\"\\approx {round((1 + 1/100)**100, 8)}\")\n        self.play(ReplacementTransform(approximation, numerical_result))\n        self.wait(1)\n\n        # Clear the scene and show the calculated value of e\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(f\"Calculated value of e: {round((1 + 1/100)**100, 8)}\", font_size=24)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Finally, integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step and evaluation\n        final_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{2} d\\theta\")\n        integral_value = MathTex(r\"= \\frac{1}{2} [ \\theta ]_{0}^{2\\pi}\")\n        final_solution = MathTex(r\"= \\pi\")\n\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n        self.play(ReplacementTransform(final_integral, integral_value))\n        self.wait(1)\n        self.play(ReplacementTransform(integral_value, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using a trigonometric identity\n        identity_explanation = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(identity_explanation))\n        self.wait(2)\n\n        # Applying the identity\n        identity_application = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Write(identity_application))\n        self.wait(2)\n\n        # Integrating using the identity\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Clear the scene and highlight the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the definite integration\n        explanation1 = Text(\"Using the power rule and evaluating limits:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{2+1}\\Big|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the limits\n        explanation2 = Text(\"Evaluate from 0 to 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after evaluating limits\n        final_solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Set up the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Show the integral bounds\n        bounds = MathTex(r\"x=0 \\quad \\text{and} \\quad x=2\")\n        self.play(Write(bounds))\n        self.wait(2)\n        \n        # Explain the fundamental theorem of calculus\n        explanation1 = Text(\"Using the Fundamental Theorem of Calculus\", font_size=24)\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Integrate the function\n        integral = MathTex(r\"\\int x^3 \\,dx = \\frac{x^{4}}{4}\")\n        self.play(Write(integral))\n        self.wait(2)\n        \n        # Apply the bounds\n        solution_step = MathTex(r\"\\left. \\frac{x^{4}}{4} \\right|_0^2\")\n        self.play(ReplacementTransform(integral.copy(), solution_step))\n        self.wait(1)\n        \n        # Explanation for evaluating the bounds\n        explanation2 = Text(\"Evaluate at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Final result\n        final_result = MathTex(r\"=\\frac{2^{4}}{4} - \\frac{0^{4}}{4}\")\n        self.play(ReplacementTransform(solution_step, final_result))\n        self.wait(1)\n        \n        # Simplify the final result\n        simplified_result = MathTex(r\"=4\")\n        self.play(ReplacementTransform(final_result, simplified_result))\n        self.wait(1)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        \n        # Conclude with the simplified solution\n        final_solution = MathTex(r\"\\int_0^2 x^3 \\,dx = 4\")\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"\\int_1^3 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Graphing the function\n        axes = Axes(x_range=[0, 4], y_range=[0, 10], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(1,3), color=[BLUE, GREEN], opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait(2)\n\n        # Showing the calculation\n        calculation = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_1^3\")\n        self.play(Transform(area_problem, calculation))\n        self.wait(1)\n\n        # Showing the evaluation at bounds\n        evaluation = MathTex(r\"= \\frac{1}{3}\\left(3^3\\right) - \\frac{1}{3}\\left(1^3\\right)\", r\"= \\frac{1}{3}(27 - 1)\", r\"= \\frac{1}{3}(26)\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(calculation, evaluation))\n        self.wait(2)\n\n        # Clear the scene and highlight the result\n        self.clear()\n        result = MathTex(r\"\\text{Area} = \\frac{26}{3}\")\n        self.play(Write(result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write down the function and the area to compute\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        area_text = MathTex(r\"\\int_{-2}^{2} e^{-x^2} dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Transform(function, area_text))\n        self.wait(2)\n\n        # Plot the function\n        graph = FunctionGraph(lambda x: np.exp(-x**2), x_range=[-2, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=[-2, 2], color=BLUE, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Show the area value (assuming it was calculated before)\n        area_value = MathTex(r\"Area \\approx 1.764\")\n        area_value.to_edge(DOWN)\n        self.play(Write(area_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(area_text), FadeOut(area_value))\n        self.wait(1)\n        \n        # Final message\n        message = Text(\"The shaded region represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_1^3\", r\"x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral setup\n        explanation1 = Text(\"Find the area under x squared from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Illustrate integration process\n        integration_step = MathTex(r\"= \\left[ \\frac{1}{3} x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(problem[1].copy(), integration_step, run_time=2))\n        self.wait(1)\n\n        # Changing the explanation\n        explanation2 = Text(\"Apply the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Present the final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Cleaning the scene and putting the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExampleSinCosScene(Scene):\n    def construct(self):\n        # Problem statement\n        problem = MathTex(r\"\\int \\sin^2(x) - \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show a trigonometric identity\n        identity = Text(\"Apply trig identity\", font_size=24).to_edge(UP)\n        self.play(Write(identity))\n        self.wait(2)\n\n        # Transformation using trig identity\n        identity_step = MathTex(r\"\\int \\cos(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_step))\n        self.wait(1)\n\n        # Explanation for the integral solution\n        explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(identity, explanation))\n        self.wait(2)\n\n        # Solution to the integral\n        solution = MathTex(r\"= \\frac{1}{2}\\sin(2x) + C\")\n        self.play(ReplacementTransform(identity_step, solution))\n        self.wait(1)\n\n        # Clearing everything off the screen\n        self.play(FadeOut(identity), FadeOut(solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Display the problem of definite integral\n        problem = MathTex(r\"\\int_0^1 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration process\n        explanation1 = Text(\"Evaluate using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the power rule of integration\n        integral_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Calculating the integral\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\Bigg|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for the definite integral evaluation\n        explanation2 = Text(\"Evaluate at the bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds evaluated\n        final_solution = MathTex(r\"= \\frac{1}{4} - 0\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{1}{4}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified final solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dx\\,dz\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [ \\frac{1}{2}x^2yz ]_{0}^{2} \\,dz\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [2yz]_{-1}^{1} \\,dy\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} 4y \\,dy\", r\"= [2y^2]_{0}^{1}\", r\"= 2\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the speed of wave propagation\n        speed_of_wave = Text(\"Here, \\(c\\) represents the speed of wave propagation.\", font_size=24)\n        self.play(Transform(explanation1, speed_of_wave))\n        self.wait(2)\n\n        # D'Alembert's Solution to the wave equation\n        dalembert_solution = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Conclusion text\n        conclusion = Text(\"D'Alembert's solution uses two arbitrary functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate D'Alembert's Solution\n        self.play(Write(dalembert_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Display the statement of the theorem\n        theorem = MathTex(\"a^2 + b^2 = c^2\")\n        self.play(Write(theorem))\n        self.wait(2)\n\n        # Show a right-angled triangle\n        triangle = Triangle().scale(2)\n        triangle.to_edge(DOWN)\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Annotate the sides of the triangle\n        a_label = MathTex(\"a\").next_to(triangle, LEFT, buff=0.1)\n        b_label = MathTex(\"b\").next_to(triangle, RIGHT, buff=0.1)\n        c_label = MathTex(\"c\").next_to(triangle, UP, buff=0.2)\n        \n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.wait(1)\n\n        # Show squares of each side\n        square_a = Square().scale(0.5).next_to(triangle, LEFT, buff=0).align_to(triangle, DOWN)\n        square_b = Square().scale(0.5).next_to(triangle, RIGHT, buff=0).align_to(triangle, DOWN)\n        square_c = Square().scale(0.5).move_to(triangle.get_top())\n\n        self.play(Create(square_a), Create(square_b), Create(square_c))\n        self.wait(2)\n\n        # Show that the area of the square on the hypotenuse equals the area of the other two squares combined\n        area_equation = MathTex(\"c^2\", \"=\", \"a^2\", \"+\", \"b^2\").to_edge(UP)\n        self.play(Transform(c_label.copy(), area_equation[0]),\n                  Transform(a_label.copy(), area_equation[2]),\n                  Transform(b_label.copy(), area_equation[4]))\n        self.wait(1)\n\n        # Highlight the areas\n        self.play(c_label.animate.set_color(YELLOW), \n                  a_label.animate.set_color(RED),\n                  b_label.animate.set_color(GREEN))\n        self.wait(1)\n\n        self.play(Indicate(square_c), Indicate(square_a), Indicate(square_b))\n        self.wait(1)\n\n        # Conclude by restating the theorem\n        conclusion = Text(\"Pythagorean theorem demonstrated\", font_size=36).to_edge(UP)\n        self.play(Transform(area_equation, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveScene(Scene):\n    def construct(self):\n        # Display the problem: Area under the curve y=x^2 from x=0 to x=2\n        problem_text = MathTex(r\"y = x^2, \\quad [0, 2]\")\n        problem_title = Text(\"Area Under the Curve\").next_to(problem_text, UP)\n        self.play(Write(problem_title), Write(problem_text))\n        self.wait(1)\n\n        # Draw the graph\n        axes = Axes(x_range=[0, 3], y_range=[0, 4],\n                    axis_config={\"include_ticks\": False})\n        graph = axes.plot(lambda x: x**2, color=BLUE, x_range=[0, 2])\n        area = axes.get_area(graph, x_range=[0, 2], color=BLUE, opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.play(Write(graph_label))\n        self.wait(1)\n\n        # Show the integration formula\n        integration_formula = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integration_formula))\n        self.wait(1)\n\n        # Show the calculation of the area\n        integration_result = MathTex(r\"= \\left[ \\frac{x^3}{3} \\right]_0^2\")\n        integration_final = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\")\n        integration_simplified = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_formula, integration_result))\n        self.wait(1)\n        self.play(ReplacementTransform(integration_result, integration_final))\n        self.wait(1)\n        self.play(ReplacementTransform(integration_final, integration_simplified))\n        self.wait(1)\n\n        # Show conclusion text\n        conclusion_text = Text(\"Area is 8/3 square units\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_simplified))\n        self.wait(1)\n        self.play(Write(conclusion_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{-1}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-1}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{-1}^{1} [\\frac{1}{2}xy^2z^2]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}x^2y^2z^2]_{-1}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the function to be expanded\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the Taylor expansion\n        taylor_expansion = MathTex(r\"f(x) \\approx 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots\")\n        self.play(Write(taylor_expansion))\n        self.wait(2)\n\n        # Explanation of approximation\n        explanation1 = Text(\n            \"This is the Taylor series expansion of \", font_size=24\n        ).next_to(function, DOWN)\n        explanation2 = Text(\n            \"around x=0\", font_size=24\n        )\n        explanation = VGroup(explanation1, explanation2).arrange(RIGHT)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the polynomial terms\n        polynomial = MathTex(r\"1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!}\")\n        self.play(ReplacementTransform(taylor_expansion.copy(), polynomial))\n        self.wait(1)\n\n        # Explanation that the series is infinite\n        infinite_series_exp = Text(\"Using more terms increases accuracy\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, infinite_series_exp))\n        self.wait(2)\n\n        # Show the actual function graph\n        axes = Axes(\n            x_range=[-6, 6],\n            y_range=[-1, 8],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Plot the polynomial approximation\n        polynomial_graph = axes.plot(\n            lambda x: 1 + x + x**2 / math.factorial(2) + x**3 / math.factorial(3),\n            color=RED\n        )\n        polynomial_label = axes.get_graph_label(polynomial_graph, label='Polynomial approximation', x_val=-3, direction=UP)\n\n        self.play(Write(polynomial_label))\n        self.play(Create(polynomial_graph))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"This is the Taylor series approximation of e^x\", font_size=24)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration result\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(2)\n\n        # Clear the screen and show conclusion\n        self.clear()\n        self.play(Write(Text(\"The integral of an exponential\", font_size=24)))\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the partial differential equation\n        pde = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation for what kind of PDE it is\n        explanation1 = Text(\"This is the wave equation, a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution format\n        explanation2 = Text(\"The general solution depends on initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution form\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(pde, general_solution))\n        self.wait(1)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"For the 1D wave equation, this is known as d'Alembert's Formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with d'Alembert's formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define the problem of calculating a definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the method to evaluate the definite integral\n        explanation1 = Text(\"Evaluate the integral using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the indefinite integral using the power rule\n        indefinite_integral = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(Write(indefinite_integral))\n        self.wait(2)\n\n        # Evaluating at the bounds\n        evaluation = MathTex(r\"\\bigg[ \\frac{x^{3}}{3} \\bigg]_2^3\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(1)\n\n        # Explanation for the evaluation step\n        explanation2 = Text(\"Substitute the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Performing the subtraction\n        subtraction = MathTex(r\"\\bigg( \\frac{3^{3}}{3} \\bigg) - \\bigg( \\frac{2^{3}}{3} \\bigg)\")\n        self.play(ReplacementTransform(evaluation, subtraction))\n        self.wait(2)\n\n        # Final calculation\n        final_calculation = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(Transform(subtraction, final_calculation))\n        self.wait(1)\n\n        solution = MathTex(r\"= 19 / 3\")\n        self.play(Transform(final_calculation, solution))\n        self.wait(1)\n\n        # Clear scene and display the solution\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(solution))\n        self.wait(1)\n"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_eq))\n        self.wait(1)\n\n        # Display title\n        title = Text(\"Fourier Series\", font_size=36)\n        self.play(Write(title))\n        title.to_edge(UP)\n        self.wait(1)\n\n        # Explanation of periodic functions\n        periodic_explanation = Text(\"Fourier series represent periodic functions.\", font_size=24)\n        self.play(Write(periodic_explanation))\n        self.wait(2)\n\n        # Transition to coefficients explanation\n        coefficients_explanation = Text(\"Coefficients are calculated based on the function's periodicity.\", font_size=24)\n        self.play(Transform(periodic_explanation, coefficients_explanation))\n        self.wait(2)\n\n        # Display an example of calculating coefficients\n        coefficients_calculation = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) \\, dx\", font_size=24)\n        coefficients_calculation.to_edge(DOWN)\n        self.play(Write(coefficients_calculation))\n        self.wait(2)\n\n        # Show a square wave approximation\n        square_wave = Text(\"Square wave approximation with 3 terms\", font_size=24).to_edge(UP)\n        self.play(Transform(periodic_explanation, square_wave))\n        square_wave_eq = MathTex(r\"f(x) \\approx a_0 + a_1 \\cos(x) + b_1 \\sin(x) + a_2 \\cos(2x) + b_2 \\sin(2x) + a_3 \\cos(3x) + b_3 \\sin(3x)\")\n        self.play(Transform(fourier_eq, square_wave_eq))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(square_wave), FadeOut(fourier_eq), FadeOut(coefficients_calculation))\n        conclusion = Text(\"Fourier series are a powerful tool in signal processing and analysis.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta) r \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ F(r,\\theta) \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ G(\\theta) \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer reveal\n        answer_explanation = Text(\"This gives us the final answer\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, answer_explanation))\n        self.wait(1)\n\n        answer = MathTex(r\"= G(2\\pi) - G(0)\")\n        self.play(Write(answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^\\infty \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right)\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"A Fourier series decomposes periodic functions\", font_size=24)\n        explanation2 = Text(\"into a sum of sines and cosines.\", font_size=24)\n        explanation = VGroup(explanation1, explanation2).arrange(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Application example\n        explanation3 = Text(\"Used in signal processing, physics, and more.\", font_size=24)\n        self.play(Transform(explanation, explanation3))\n        self.wait(2)\n\n        # Displaying partial sum approximation\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right)\")\n        self.play(ReplacementTransform(fourier_series, partial_sum))\n        self.wait(1)\n\n        # Conclusion with both explanation and formula\n        conclusion_text = Text(\"We can approximate functions using N terms.\", font_size=24)\n        conclusion = VGroup(partial_sum, conclusion_text).arrange(DOWN)\n        self.play(Transform(explanation, conclusion_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Write the final thought\n        final_thought = Text(\"Fourier series is a cornerstone in harmonic analysis.\", font_size=24)\n        self.play(Write(final_thought))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r - 1 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = 1\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\iint_V \\frac{1}{2}x^2yz \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_V \\frac{1}{2}x^2\\frac{1}{2}y^2z \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}x^2y^2\\frac{1}{2}z^2\\Big|_V\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\nabla^2 u = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the equation\n        explanation1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the speed of waves\n        explanation2 = Text(\"Here, c represents the speed of waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution format\n        solution_format = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(equation, solution_format))\n        self.wait(2)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"Solutions can be described by d'Alembert's formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Displaying specific example\n        specific_example = MathTex(r\"u(x, t) = A \\sin(k(x - ct))\")\n        self.play(Transform(equation, specific_example))\n        self.wait(2)\n\n        # Explanation for the specific solution\n        explanation4 = Text(\"This represents a sinusoidal traveling wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_example))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        heat_eq = MathTex(r\"\\frac{\\partial u}{\\partial t} - \\alpha \\nabla^2 u = 0\")\n        self.play(FadeIn(heat_eq))\n        self.wait(1)\n\n        # Introducing the equation\n        intro_text = Text(\"The heat equation is a second-order PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(intro_text))\n        self.wait(2)\n\n        # Discussing the physical meaning\n        physical_meaning = Text(\"It describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(intro_text, physical_meaning))\n        self.wait(2)\n\n        # Displaying the steady-state solution\n        steady_state = MathTex(r\"\\nabla^2 u = 0\")\n        self.play(ReplacementTransform(heat_eq, steady_state))\n        self.wait(1)\n\n        # Steady-state explanation\n        steady_state_explanation = Text(\"A steady-state solution does not change with time.\", font_size=24).to_edge(UP)\n        self.play(Transform(intro_text, steady_state_explanation))\n        self.wait(2)\n\n        # Cleaning the scene\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(steady_state))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the method of rectangles\n        explanation1 = Text(\"Approximate area using rectangles\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 2.5, 0.5],\n            y_range=[0, 4.5, 1],\n            x_length=5,\n            y_length=4,\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Display rectangles\n        rects = axes.get_riemann_rectangles(graph, x_range=[0, 2], dx=0.25)\n        self.play(Create(rects))\n        self.wait(2)\n\n        # Explanation for the actual integration\n        explanation2 = Text(\"Calculate the exact area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(rects, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi\\, d\\rho\\,d\\theta\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} [\\frac{1}{3}\\rho^3 \\sin \\phi]_{0}^{1} d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified after inner integral\n        simplified_inner = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\sin \\phi \\, d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} [2\\pi \\sin \\phi]_{0}^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(simplified_inner, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution step\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} \\int_{0}^{\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Explain final integral solution\n        explanation4 = Text(\"Evaluate the sine integral over phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3} [-\\cos \\phi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        \n        # Resolve to actual number\n        resolved_final_answer = MathTex(r\"= \\frac{4\\pi}{3}\")\n        self.play(ReplacementTransform(final_answer, resolved_final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing area under the curve\n        integral_equation = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_equation))\n        self.wait(1)\n\n        # Give an explanation for the area under the curve\n        explanation1 = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(1)\n\n        # Calculating the antiderivative\n        antiderivative = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(integral_equation.copy(), antiderivative))\n        self.wait(1)\n\n        # Substituting the limits\n        substituting_limits = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\")\n        self.play(ReplacementTransform(antiderivative, substituting_limits))\n        self.wait(1)\n\n        # Final solution showing the area\n        solution = MathTex(r\"= \\frac{1}{3}(8 - 0)\")\n        self.play(ReplacementTransform(substituting_limits, solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(solution, final_answer))\n        self.wait(1)\n\n        # Clearing the scene\n        self.play(FadeOut(explanation1), FadeOut(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Integrate with respect to \\(\\\\theta\\) now\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} \\int_{0}^{2\\pi} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Computing the final integral\n        computed_solution = MathTex(r\"= \\frac{1}{2} [ \\theta ]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(final_solution, computed_solution))\n        self.wait(1)\n        \n        # Displaying the final answer\n        answer = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(computed_solution, answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2\\nabla^2 u\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Define c as the speed of light\n        speed_of_light = MathTex(r\"c\", r\" = 3 \\times 10^8 \\, \\text{m/s}\")\n        self.play(Write(speed_of_light))\n        self.wait(1)\n\n        # Move wave equation up and speed of light below it\n        self.play(wave_eq.animate.to_edge(UP))\n        speed_of_light.next_to(wave_eq, DOWN)\n        self.play(Write(speed_of_light))\n        self.wait(1)\n\n        # Display the general form of the solution\n        general_solution = Text(\"The general solution involves sine and cosine functions or exponentials with imaginary argument.\", font_size=24)\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Presenting an example solution\n        example_solution = MathTex(r\"u(x, t) = A\\cos(kx - \\omega t) + B\\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eq, example_solution))\n        self.wait(1)\n\n        # Explanation propagation direction\n        propagation_direction = Text(\"The solution represents traveling waves in the x direction.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(general_solution, propagation_direction))\n        self.wait(1)\n\n        # Clear the scene and fade out\n        self.play(FadeOut(wave_eq), FadeOut(speed_of_light), FadeOut(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Applying the definite integral limits\n        limits = MathTex(r\"\\Big |_2^3\")\n        self.play(Write(limits.next_to(power_rule, RIGHT)))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\"\\Big |_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for applying the Fundamental Theorem of Calculus\n        explanation2 = Text(\"Evaluate using the limits 2 and 3:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after applying limits\n        final_solution = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(2)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= \\frac{65}{4}\")\n        self.play(Transform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x \\,dx = \\frac{x^{2}}{2} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= 2 \\cdot \\frac{x^{2}}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the limits\n        evaluated_at_limits = MathTex(r\"= x^{2} \\Big|_1^3\")\n        self.play(ReplacementTransform(solution1, evaluated_at_limits))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 3^{2} - 1^{2}\")\n        self.play(ReplacementTransform(evaluated_at_limits, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9 - 1\")\n        self.play(Write(final_value))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(final_value, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 4],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Define and draw the curve y = x^2\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        curve_label = axes.get_graph_label(curve, label='y = x^2')\n        self.play(Create(axes), Create(curve), Write(curve_label))\n        self.wait(1)\n\n        # Shade the area under the curve y = x^2 between x = 1 and x = 3\n        shaded_area = axes.get_riemann_rectangles(curve, x_range=[1, 3], dx=0.05, color=BLUE, fill_opacity=0.5)\n        self.play(Create(shaded_area))\n        self.wait(2)\n\n        # Display the area value\n        area_text = MathTex(r\"A = \\int_1^3 x^2 dx = \\left.\\frac{x^3}{3}\\right|_1^3 = \\frac{26}{3}\")\n        area_text.next_to(shaded_area, DOWN)\n        self.play(Write(area_text))\n        self.wait(2)\n\n        # Clear the scene and show only the final area value\n        self.play(FadeOut(axes), FadeOut(curve), FadeOut(curve_label), FadeOut(shaded_area))\n        self.play(area_text.animate.move_to(ORIGIN))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CalculateAreaUnderCurve(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_1^3\", r\"x^2\\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Set up the integral calculation\n        setup = Text(\"Calculating the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(setup))\n        self.wait(2)\n\n        # Show integration steps\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral.copy(), integration_steps))\n        self.wait(2)\n\n        # Evaluation part\n        evaluation = Text(\"Substitute the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(setup, evaluation))\n        self.wait(2)\n        \n        # Showing final calculation\n        final_calculation = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{27}{3} - \\frac{1}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, final_calculation))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_calculation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{x} e^{y^2} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [e^{y^2}]_{0}^{x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [e^{x^2}]_{0}^{1}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer\n        answer = MathTex(r\"= e - 1\")\n        self.play(Write(answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Evaluate the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration step (indefinite integral)\n        indefinite = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(ReplacementTransform(problem.copy(), indefinite))\n        self.wait(2)\n\n        # Applying the bounds of the integral\n        bounds = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{0}^{2}\")\n        self.play(ReplacementTransform(indefinite, bounds))\n        self.wait(2)\n\n        # Evaluating at bounds\n        evaluation = MathTex(r\"= \\frac{2^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(Write(evaluation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the evaluated definite integral\n        conclusion = Text(\"The evaluated integral is \\\\( \\\\frac{8}{3} \\\\)\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass IntegrationByPartsExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula step\n        formula_step = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(Write(formula_step))\n        self.wait(2)\n\n        # Choosing u and dv\n        u_and_dv = MathTex(r\"u = x, \\quad dv = e^x \\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Calculating du and v\n        du_and_v = MathTex(r\"du = dx, \\quad v = e^x\")\n        self.play(Write(du_and_v))\n        self.wait(2)\n\n        # Applying the integration by parts\n        integration_step = MathTex(r\"x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the simple integral\n        explanation2 = Text(\"Integrate e^x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(2)\n\n        # Conclude the problem\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        axes = Axes(x_range=[0, 5], y_range=[0, 4], axis_config={\"color\": BLUE})\n        func_graph = axes.plot(lambda x: 0.1 * x ** 2, color=GREEN)\n        area = axes.get_area(func_graph, x_range=[0.3, 4.5], color=(RED, GREEN), opacity=0.5)\n        self.play(Create(axes), Create(func_graph), FadeIn(area))\n        self.wait(2)\n\n        # Annotating the boundaries of the integral\n        x_labels = [\n            axes.get_x_axis_label(MathTex(f\"{x_label}\")).rotate(90 * DEGREES)\n            for x_label in (0.3, 4.5)\n        ]\n        self.play(*[Write(label) for label in x_labels])\n        self.wait(1)\n\n        # Display the integral representation\n        integral_text = MathTex(r\"\\int_{0.3}^{4.5}\", r\"0.1x^2\", r\"dx\").next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Calculate and show the exact value of the integral\n        exact_value = MathTex(\"= \\\\left. \\\\frac{0.1}{3} x^3 \\\\right|_{0.3}^{4.5}\")\n        self.play(Transform(integral_text, exact_value))\n        self.wait(2)\n\n        # Show the result of the definite integral\n        result = MathTex(\"= \\\\frac{0.1}{3} (4.5^3 - 0.3^3)\").next_to(exact_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene and show the definite area\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(integral_text))\n        self.play(FadeIn(area), Write(result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(FadeIn(function))\n        self.wait(1)\n        \n        # Display the Taylor Series approximation\n        taylor = MathTex(r\"P_n(x) = \\sum_{{i=0}}^n \\frac{f^{(i)}(0)}{i!} x^i\")\n        self.play(Transform(function, taylor))\n        self.wait(2)\n        \n        # Explaining the zeroth approximation\n        zeroth_approx = MathTex(r\"P_0(x) = 1\")\n        self.play(Write(zeroth_approx))\n        self.wait(1)\n        \n        # Show the first approximation\n        first_approx = MathTex(r\"P_1(x) = 1 + x\")\n        self.play(ReplacementTransform(zeroth_approx, first_approx))\n        self.wait(1)\n        \n        # Show the second approximation\n        second_approx = MathTex(r\"P_2(x) = 1 + x + \\frac{x^2}{2!}\")\n        self.play(ReplacementTransform(first_approx, second_approx))\n        self.wait(1)\n        \n        # Converging explanation\n        explanation = Text(\"As n approaches infinity, \\nP_n(x) converges to f(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n        \n        # Show the function again\n        final_function = MathTex(r\"f(x) = e^x\")\n        self.play(ReplacementTransform(second_approx, final_function), FadeOut(explanation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explaining the equation\n        explanation1 = Text(\"This is the wave equation, where c is the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Discussing the solution\n        explanation2 = Text(\"Solutions can be sinusoidal or composed of superposed waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Presenting a sinusoidal solution\n        sinusoidal_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, sinusoidal_solution))\n        self.wait(1)\n\n        # Discussing the components of sinusoidal solutions\n        explanation3 = Text(\"Here, A is amplitude, k is wave number, \u03c9 is angular frequency, and \u03c6 is phase shift.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Demonstrating superposition principle\n        explanation4 = Text(\"By the superposition principle, we can add solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Displaying the superposition of two waves\n        superposed_waves = MathTex(r\"u(x, t) = u_1(x, t) + u_2(x, t)\")\n        self.play(Transform(sinusoidal_solution, superposed_waves))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(explanation4))\n        self.wait(1)\n        self.play(FadeIn(sinusoidal_solution, shift=DOWN))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Display the limits of integration\n        limits = Text(\"Integration bounds: from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule, add 1 to the exponent and divide by the new exponent:\", font_size=24).next_to(limits, DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"=\\frac{x^{3+1}}{4}\\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for inserting the limits\n        explanation2 = Text(\"Evaluate at the upper and lower bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculate the definite integral\n        evaluated_solution = MathTex(r\"=\\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        explanation3 = Text(\"Simplify to find the area under the curve between the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        result_text = Text(\"The area under the curve from 0 to 2 is 4\", font_size=24).to_edge(UP)\n        self.play(Write(result_text))\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[0, 10, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        curve = axes.plot(lambda x: 0.1 * x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0, 4), color=YELLOW, opacity=0.5)\n\n        problem = MathTex(r\"A=\\int_{0}^{4} 0.1x^2 \\,dx\", color=WHITE)\n        problem.to_corner(UL)\n\n        self.play(Write(problem))\n        self.wait(1)\n\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        solution = MathTex(r\"A=\\dfrac{1}{3}0.1\\cdot 4^3\", color=WHITE)\n        solution.next_to(problem, DOWN)\n\n        self.play(ReplacementTransform(area, solution))\n        self.wait(1)\n\n        self.play(FadeOut(axes), FadeOut(curve), FadeOut(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Evaluate by using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Applying definite integral bounds\n        definite_bounds = MathTex(r\"\\Big|_2^3\")\n        self.play(Write(definite_bounds.next_to(power_rule, RIGHT)))\n        self.wait(2)\n\n        # Showing the next step for evaluation\n        step1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), step1.shift(DOWN)))\n        self.wait(1)\n\n        # Showing simplification process\n        explanation2 = Text(\"Simplify the result\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(step1, final_solution))\n        self.wait(1)\n\n        # Calculate the final numeric result\n        numeric_result = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, numeric_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the numeric result\n        self.play(Write(numeric_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function_text = MathTex(r\"f(x) = x^2\", font_size=36)\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for Fourier series decomposition\n        explanation1 = Text(\"Decompose using Fourier series:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier series formula\n        fourier_series = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^\\infty \\left( a_n\\cos(2\\pi nx) + b_n\\sin(2\\pi nx) \\right)\")\n        self.play(Transform(function_text, fourier_series))\n        self.wait(3)\n\n        # Explanation for calculating coefficients\n        explanation2 = Text(\"Calculate coefficients a_n and b_n\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Coefficients for a specific n\n        coefficients = MathTex(r\"a_n = ???\", r\"\\quad\", r\"b_n = ???\", font_size=36)\n        self.play(Write(coefficients))\n        self.wait(3)\n\n        # First few terms of the series\n        first_terms = MathTex(r\"f(x) \\sim a_0 + a_1\\cos(2\\pi x) + b_1\\sin(2\\pi x) + \\ldots\", font_size=36)\n        self.play(ReplacementTransform(fourier_series, first_terms))\n        self.wait(2)\n\n        # Explanation for approximation\n        explanation3 = Text(\"This is an approximation for the Fourier series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and display a graph\n        self.clear()\n        self.wait(1)\n\n        # Graph of the function\n        graph_axes = Axes(x_range=[-3, 3], y_range=[-1, 9])\n        graph = graph_axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = graph_axes.get_graph_label(graph, label='x^2')\n\n        # Display the graph\n        self.play(Create(graph_axes), Create(graph), Write(graph_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Displaying the integral problem\n        integral = MathTex(r\"\\int_{0}^{2} (x^2) \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Graph function\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Calculate the area\n        solution = MathTex(r\"=\\frac{{(2)^3}}{3} - \\frac{{(0)^3}}{3}\")\n        solution.to_edge(DOWN)\n        self.play(ReplacementTransform(integral.copy(), solution))\n        self.wait(2)\n\n        # Simplify the solution\n        final_solution = MathTex(r\"=\\frac{8}{3}\")\n        final_solution.next_to(solution, DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{d}{dx} (x^2 + 3x + 2)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using power rule\n        explanation1 = Text(\"Use the power rule for derivatives\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"2x + 3\")\n        self.play(ReplacementTransform(problem.copy(), derivative_step))\n        self.wait(1)\n\n        # Explanation for final form\n        explanation2 = Text(\"The derivative is a linear function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution shown\n        final_solution = MathTex(r\"f'(x) = 2x + 3\")\n        self.play(ReplacementTransform(derivative_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(Text(\"That's the derivative!\", font_size=24).to_edge(UP)))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area to find\n        function = MathTex(r\"f(x) = 3x^2 + 2\")\n        area_problem = MathTex(r\"\\text{Find the area under } f(x) \\text{ from } x=1 \\text{ to } x=2\")\n        self.play(Write(function), Write(area_problem))\n        self.wait(1)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 3],\n            y_range=[0, 20],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.get_graph(lambda x: 3 * x**2 + 2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n        \n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(1, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Apply definite integral to find the area\n        integral = MathTex(r\"A = \\int_{1}^{2} (3x^2 + 2) \\,dx\")\n        self.play(ReplacementTransform(area_problem, integral))\n        self.wait(2)\n\n        # Showing the antiderivative\n        antiderivative = MathTex(r\"A = \\left. x^3 + 2x \\right|_{1}^{2}\")\n        self.play(Write(antiderivative))\n        self.wait(1)\n\n        # Calculate the area value\n        area_value = MathTex(r\"A = (2^3 + 2 \\cdot 2) - (1^3 + 2 \\cdot 1) = 8+4-1-2\")\n        area_solution = MathTex(r\"A = 9\")\n        self.play(ReplacementTransform(antiderivative, area_value), run_time=2)\n        self.wait(1)\n        self.play(Transform(area_value, area_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin\\theta dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin\\theta]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral evaluation\n        middle_evaluation = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin\\theta d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_evaluation))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3}\\cos\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_evaluation, final_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= -\\frac{1}{3}(\\cos\\pi - \\cos0)\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Result of the final integral\n        result = MathTex(r\"= \\frac{2}{3}\")\n        self.play(Transform(final_solution, result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation for Fourier series\n        explanation1 = Text(\"This is a Fourier series expansion for a periodic function.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Coefficients explanation\n        explanation2 = Text(\"The coefficients a_n and b_n are calculated from the function.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the coefficient formulas\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) \\, dx\", r\"\\\\\", \n                               r\"b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) \\, dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Each cosine and sine term corresponds to a harmonic of the base frequency.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation2, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(coefficients), FadeOut(explanation3))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^{2}}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[ \\frac{1}{3}x^3 \\right]_{0}^{\\sqrt{1-y^{2}}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(\\sqrt{1-y^{2}})^3 dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the final integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[\\text{Solution Expression Here}\\right]_{0}^{1}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Display final solution value (example value shown, replace with actual solution)\n        final_value = Text(\"Solution: \\(\\frac{1}{6}\\pi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_value))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-1, 5],\n            y_range=[-1, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label='x', y_label='f(x)')\n\n        # The graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        area = axes.get_area(graph, x_range=(0,2), color=GREY, opacity=0.5)\n\n        # Displaying everything\n        self.play(Create(axes), Write(labels))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Show the area under the graph\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the integral representation\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Solve the integral on screen\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        solution.next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(labels), FadeOut(graph_label), FadeOut(area), FadeOut(integral), FadeOut(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Writing the function and the area to find\n        function_tex = MathTex(r\"f(x) = x^2\")\n        area_tex = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        problem_group = VGroup(function_tex, area_tex).arrange(DOWN)\n        self.play(Write(problem_group))\n        self.wait(1)\n\n        # Explain which area we want to find\n        explanation_text = Text(\"Finding area under curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Draw graph\n        axes = Axes(x_range=[0, 3], y_range=[0, 5], axis_config={\"include_tip\": True})\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        area = axes.get_area(graph, x_range=(0,2), color=BLUE, opacity=0.3)\n        graph_group = VGroup(axes, graph, area)\n        self.play(Create(graph_group))\n        self.wait(1)\n\n        # Do the calculation\n        calculation = MathTex(r\"= \\frac{1}{3} x^3 \\Bigg|_0^2\")\n        self.play(ReplacementTransform(area_tex.copy(), calculation))\n        self.wait(1)\n\n        # Final answer after calculation\n        final_answer = MathTex(r\"= \\frac{1}{3} (2)^3 - \\frac{1}{3} (0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(calculation, final_answer))\n        self.wait(1)\n\n        # Highlight final answer\n        box = SurroundingRectangle(final_answer, color=RED)\n        self.play(Create(box))\n        self.wait(2)\n\n        # Clear and show final answer only\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        func_graph = self.get_graph(lambda x: x**2, color=WHITE)\n        area = self.get_area(func_graph, x_min=0, x_max=2)\n        \n        # Display the area text\n        area_text = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        \n        # Show the function and area\n        self.play(Create(func_graph), FadeIn(area), Write(area_text))\n        self.wait(2)\n\n        # Show the area calculation\n        calculation = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\").to_edge(UP)\n        self.play(Write(calculation))\n        self.wait(1)\n\n        # Show calculated result\n        result = MathTex(r\"=\\frac{8}{3}\").next_to(calculation, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear scene\n        self.play(FadeOut(func_graph), FadeOut(area), FadeOut(area_text), FadeOut(calculation), FadeOut(result))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color)\n\n    def get_area(self, graph, x_min, x_max):\n        return graph.get_area(x_min=x_min, x_max=x_max)"
  },
  {
    "text": "from manim import *\n\nclass EulersFormulaScene(Scene):\n    def construct(self):\n        # Display Euler's formula\n        eulers_formula = MathTex(\"e^{i\\\\theta} = \\\\cos(\\\\theta) + i\\\\sin(\\\\theta)\")\n        self.play(Write(eulers_formula))\n        self.wait(2)\n\n        # Explanation for Euler's formula\n        explanation = Text(\"Euler's formula relates complex exponentials and trigonometry\", font_size=24)\n        self.play(FadeIn(explanation, shift=UP))\n        self.wait(2)\n\n        # Transform theta into pi\n        pi_transform = MathTex(\"e^{i\\\\pi} = \\\\cos(\\\\pi) + i\\\\sin(\\\\pi)\")\n        self.play(TransformMatchingTex(eulers_formula, pi_transform))\n        self.wait(2)\n\n        # Simplify the expression\n        simplified_expression = MathTex(\"e^{i\\\\pi} = -1 + 0 \\\\cdot i\")\n        self.play(ReplacementTransform(pi_transform, simplified_expression))\n        self.wait(2)\n\n        # Show the famous identity\n        identity = MathTex(\"e^{i\\\\pi} + 1 = 0\")\n        self.play(ReplacementTransform(simplified_expression, identity))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"This is one of the most beautiful equations in mathematics\")\n        self.play(Transform(explanation, conclusion))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(eulers_formula), FadeOut(explanation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Display the double integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1-x} e^{-(x+y)} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [-e^{-(x+y)}]_{0}^{1-x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{1} (e^{-x} - e^{-1}) dx\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"= [ -e^{-x} - x e^{-1} ]_{0}^{1}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (1 - \\frac{1}{e}) - (0 - 0) = 1 - \\frac{1}{e}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The triple integral value is 1/8\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identity\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            r\"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral\n        rewritten_integral = MathTex(r\"\\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, rewritten_integral))\n        self.wait(2)\n\n        # Performing the integral\n        integral_result = MathTex(r\"= - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(Write(integral_result))\n        self.wait(1)\n\n        # Explanation for the integration result\n        explanation2 = Text(\"Integrate using the power reduction formula\", \n                            font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after integration\n        final_solution = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion and clearing the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\iiint_V xyz \\,dx\\,dy\\,dz\", font_size=48)\n        self.play(Write(problem))\n        self.wait(1)\n\n        limits = Text(\"where V is the region bounded by the planes x=0, y=0, z=0, x+y=1\", font_size=24).to_edge(UP)\n        self.play(Write(limits))\n        self.wait(2)\n\n        first_integral = MathTex(r\"= \\int_0^1 \\int_0^{1-x} \\int_0^{1-x-y} xyz \\,dz\\,dy\\,dx\")\n        self.play(ReplacementTransform(problem, first_integral))\n        self.wait(3)\n\n        second_integral = MathTex(r\"= \\int_0^1 \\int_0^{1-x} [\\frac{1}{2} xy z^2 ]_{0}^{1-x-y} \\,dy\\,dx\")\n        self.play(ReplacementTransform(first_integral, second_integral))\n        self.wait(3)\n\n        third_integral = MathTex(r\"= \\int_0^1 [\\frac{1}{2} xy (\\frac{1}{2} - x - y) ]_{0}^{1-x} \\,dx\")\n        self.play(ReplacementTransform(second_integral, third_integral))\n        self.wait(3)\n\n        solution = MathTex(r\"= [\\frac{1}{24} - \\frac{1}{4} x^2 + \\frac{1}{3} x^3]_0^1\", r\"=\", r\"\\frac{1}{24}\")\n        self.play(ReplacementTransform(third_integral, solution))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_series_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series_eq))\n        self.wait(2)\n\n        # Adding the explanation for Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Further explanation\n        explanation2 = Text(\"into the frequencies composing the original function.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Example of a function\n        function_example = MathTex(r\"f(x) = \\cos(x) + \\frac{1}{2}\\cos(2x)\")\n        self.play(ReplacementTransform(fourier_series_eq, function_example))\n        self.wait(1)\n        \n        # Updating the explanation for this example\n        explanation3 = Text(\"This is a simple example with only two terms\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(1)\n        self.remove(explanation2)\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(function_example), FadeOut(explanation1))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        def func(x):\n            return 0.1 * x ** 2\n\n        graph = axes.plot(func, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 4), color=[BLUE, GREEN], opacity=0.3)\n\n        equation = MathTex(r\"\\int_0^4 0.1x^2 \\,dx\").to_edge(UP)\n        self.play(Write(equation))\n        self.wait(1)\n        self.play(FadeIn(axes), Write(graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        solution = MathTex(r\"= \\left[\\frac{1}{30} x^3 \\right]_0^4\").to_edge(UP)\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= \\frac{1}{30} (4)^3 - \\frac{1}{30} (0)^3\", r\"= \\frac{64}{30}\", r\"= \\frac{32}{15}\")\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), ReplacementTransform(solution, final_answer))\n        self.wait(2)\n\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain usage of trigonometric identity\n        identity_explanation = Text(\"Use the trigonometric identity: \"\n                                    \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(identity_explanation))\n        self.wait(2)\n\n        # Display the trigonometric identity\n        trig_identity = MathTex(r\"\\int \\frac{1}{2} \\sin(2x) \\, dx\")\n        self.play(ReplacementTransform(problem, trig_identity))\n        self.wait(2)\n\n        # Explain the integration process\n        integration_explanation = Text(\"Integrate the function\", font_size=24).to_edge(UP)\n        self.play(Transform(identity_explanation, integration_explanation))\n        self.wait(2)\n\n        # Perform the integration\n        integral_result = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(trig_identity, integral_result))\n        self.wait(2)\n\n        # Conclude the integration process\n        self.play(FadeOut(identity_explanation), FadeOut(integral_result))\n        self.wait(1)\n        self.play(Write(MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx = -\\frac{1}{4} \\cos(2x) + C\")))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the sum notation\n        sum_notation = MathTex(r\"S_n = \\sum_{k=0}^{n} ar^k\")\n        self.play(Write(sum_notation))\n        self.wait(1)\n\n        # Explanation for geometric series\n        explanation1 = Text(\"Solve for the sum of a geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the formula\n        series_formula = MathTex(r\"S_n = \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(sum_notation.copy(), series_formula))\n        self.wait(2)\n\n        # Explanation for convergence\n        explanation2 = Text(\"For |r| < 1, the series converges as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Adding the limit\n        series_limit = MathTex(r\"S = \\lim_{n \\to \\infty} S_n = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(series_formula, series_limit))\n        self.wait(2)\n\n        # Final result for infinite series\n        final_result = MathTex(r\"S = \\frac{a}{1-r}\", \",\", r\"\\text{ for } |r| < 1\")\n        self.play(ReplacementTransform(series_limit, final_result))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration step\n        explanation = Text(\"Integrate by reversing the power rule of differentiation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DampedOscillationScene(Scene):\n    def construct(self):\n        title = Text(\"Damped Oscillation\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Displaying the second order ODE\n        second_order_ode = MathTex(r\"y'' + 2\\beta y' + \\omega^2 y = 0\", font_size=28)\n        self.play(FadeIn(second_order_ode, shift=DOWN))\n        self.wait(2)\n\n        # Explaining beta represents damping\n        damping_explanation = Text(r\"Damping Factor $\\beta$\", font_size=24).to_edge(UP)\n        self.play(Transform(title, damping_explanation))\n        self.wait(2)\n\n        # Displaying the characteristic polynomial\n        characteristic_polynomial = MathTex(r\"r^2 + 2\\beta r + \\omega^2 = 0\", font_size=28)\n        self.play(ReplacementTransform(second_order_ode, characteristic_polynomial))\n        self.wait(2)\n\n        # Describe Nature of Roots\n        root_nature = Text(\"Nature of roots depends on discriminant\", font_size=24).to_edge(UP)\n        self.play(Transform(title, root_nature))\n        self.wait(2)\n\n        # Showing the discriminant\n        discriminant = MathTex(r\"\\Delta = 4\\beta^2 - 4\\omega^2\", font_size=28)\n        self.play(Write(discriminant))\n        self.wait(2)\n\n        # Displaying the types of damping based on discriminant\n        damping_types = VGroup(\n            Text(\"Overdamped: \", font_size=24),\n            MathTex(r\"\\beta > \\omega\").scale(0.8),\n            Text(\"Critically Damped: \", font_size=24).next_to(2*DOWN),\n            MathTex(r\"\\beta = \\omega\").scale(0.8).next_to(2*DOWN),\n            Text(\"Underdamped: \", font_size=24).next_to(4*DOWN),\n            MathTex(r\"\\beta < \\omega\").scale(0.8).next_to(4*DOWN)\n        ).arrange(DOWN, center=False, align_edge=LEFT)\n\n        self.play(FadeOut(discriminant))\n        self.play(Write(damping_types))\n        self.wait(3)\n\n        # Clear the scene to conclude\n        self.play(FadeOut(title), FadeOut(damping_types), FadeOut(characteristic_polynomial))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\left[\\frac{1}{2}x^2yz\\right]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}yz\\right]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}z^2\\right]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Original function f(x) = x^2\n        original_function = axes.plot(lambda x: x**2, color=GREEN)\n        original_function_label = axes.get_graph_label(original_function, label='x^2')\n\n        # Area under the curve f(x) = x^2 from x=1 to x=3\n        area = axes.get_area(original_function, x_range=(1, 3), color=[BLUE, PURPLE, RED], opacity=0.5)\n\n        self.play(Create(axes), Write(labels))\n        self.play(Create(original_function), Write(original_function_label))\n        self.wait(1)\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        # Display the integral representation\n        integral = MathTex(r\"\\int_{1}^{3} x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Calculate the area (analytical solution)\n        solution = MathTex(r\"=\\left.\\frac{x^3}{3}\\right|_1^3 = \\frac{27}{3} - \\frac{1}{3} = 8\")\n        solution.next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Clear the scene and display the solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Presenting the integral\n        integral = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait()\n\n        # Adding graph\n        axes = Axes(x_range=[0, 1], y_range=[0, 1], x_length=5, y_length=4)\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        area = axes.get_area(graph, x_range=[0, 1], color=BLUE, opacity=0.3)\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(2)\n\n        # Integral solution\n        solution = MathTex(r\"= \\frac{1}{3}\").next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Comparing with the shaded area\n        comparison = Text(\"Area under the curve\", font_size=24).next_to(axes, UP)\n        self.play(Write(comparison))\n        self.wait()\n\n        # Clean up the scene\n        self.play(FadeOut(integral), FadeOut(solution), FadeOut(comparison), FadeOut(axes), FadeOut(graph), FadeOut(area))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} \\frac{1}{2}xyz^2\\Big|_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}xy^2\\Big|_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}x^2\\Big|_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderGraph(Scene):\n    def construct(self):\n        # Plotting the graph of the function\n        axes = Axes(x_range=[0, 5], y_range=[0, 10], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Area under graph (Illustration of the integral)\n        area = axes.get_area(graph, x_range=(0, 2), color=BLUE, opacity=0.3)\n\n        # Displaying Area under Graph problem\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n\n        # Set up the scene\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation = Text(\"Find the area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_problem, integration_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(explanation))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying Fourier Series definition\n        fourier_series_def = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Explanation for Fourier Series\n        explanation1 = Text(\"A periodic function can be represented as a sum of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Example of Fourier Series for a square wave\n        explanation2 = Text(\"Example: Fourier Series of a square wave\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying Fourier Series for a square wave\n        square_wave = MathTex(r\"f(x) = \\frac{4}{\\pi} \\sum_{n=1,3,5}^{\\infty} \\frac{\\sin(nx)}{n}\")\n        self.play(Transform(fourier_series_def, square_wave))\n        self.wait(2)\n\n        # Explanation for coefficients\n        explanation3 = Text(\"Coefficients are determined by the function's periodicity and shape.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude with a graphic\n        self.clear()\n        self.wait(1)\n        square_wave_graphic = Text(\"Here would be a graphic of the square wave.\", font_size=24)\n        self.play(FadeIn(square_wave_graphic))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_min=-1, x_max=10,\n            y_min=-1, y_max=8,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n        \n        # Creating the graph\n        graph = axes.plot(lambda x: 0.1 * (x-2)**2, color=WHITE)\n        area = axes.get_area(graph, x_min=2, x_max=8, color=BLUE, opacity=0.3)\n\n        # Problem statement\n        problem = MathTex(r\"A = \\int_{2}^{8} 0.1(x-2)^2 \\, dx\").to_edge(UP)\n\n        # Writing the problem\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Drawing the axes, graph, and shaded area\n        self.play(Write(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), FadeIn(area, run_time=3))\n        self.wait(2)\n\n        # Explanation for computation\n        explanation = Text(\"Calculate the area under the curve\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and present final answer\n        self.clear()\n        final_answer = MathTex(r\"A = \\frac{1}{0.3} [ \\frac{(x-2)^3}{3} ]_{2}^{8}\").move_to(problem)\n        self.play(Write(final_answer))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaSphericalExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi \\, d\\rho \\, d\\theta \\, d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\left[\\frac{\\rho^3}{3}\\right]_{0}^{1} \\sin \\phi \\, d\\theta \\, d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[\\frac{\\theta \\rho^3}{3}\\right]_{0}^{2\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[\\frac{2\\pi \\rho^3}{3}\\left(-\\cos \\phi\\right)\\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} (1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of the integral calculation\n        conclusion = Text(\"Surface area of a unit sphere is 4*pi\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta)r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[\\int_{0}^{1} f(r, \\theta)r\\,dr\\right] d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Then integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{2\\pi} F(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final result\n        explanation3 = Text(\"Finally, evaluate the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= F_{\\text{evaluated}}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Plotting the graph of the function\n        graph = FunctionGraph(\n            lambda x: x**2,\n            x_range=[-3, 3],\n        )\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Highlighting the area under the curve from x=0 to x=2\n        area = area = Integral(graph, (0, 2), color=BLUE)\n        area_label = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=BLUE).next_to(area, UP+RIGHT)\n        \n        self.play(FadeIn(area, area_label))\n        self.wait(2)\n\n        # Calculating the area\n        calculation = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_0^2\")\n        calculation.to_edge(RIGHT, buff=1)\n        self.play(Write(calculation))\n        self.wait(1)\n\n        # Showing the value of the definite integral\n        value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\")\n        self.play(Transform(calculation, value))\n        self.wait(1)\n\n        result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(calculation, result))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\").shift(UP)\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution_step = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^3\")\n        self.play(ReplacementTransform(problem.copy(), solution_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate at the bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the integral\n        evaluated_integral = MathTex(r\"= \\frac{3^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution_step, evaluated_integral))\n        self.wait(1)\n\n        # Simplifying the evaluated integral\n        simplified_solution = MathTex(r\"= \\frac{81}{4}\")\n        self.play(ReplacementTransform(evaluated_integral, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Explanation of the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Specific form in one dimension\n        explanation2 = Text(\"In one dimension, it simplifies to:\", font_size=24).next_to(explanation1, DOWN)\n        self.play(GrowFromCenter(explanation2))\n        one_d_wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Transform(wave_eq, one_d_wave_eq))\n        self.wait(2)\n\n        # Displaying a possible solution\n        solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        explanation3 = Text(\"Solutions can be represented as a sum of two functions.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Transform(explanation2, explanation3))\n        self.play(Transform(wave_eq, solution))\n        self.wait(2)\n\n        # Concluding the solutions are waves\n        explanation4 = Text(\"These represent waves moving in opposite directions.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Transform(explanation2, explanation4))\n        self.wait(2)\n\n        # Clear scene\n        self.play(FadeOut(wave_eq), FadeOut(explanation1), FadeOut(explanation2))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Discussing the solution form\n        solution_form = Text(\"Solutions take the form u(x, t) = f(x \\pm ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_form))\n        self.wait(2)\n        \n        # Displaying the solution to the equation\n        solution = MathTex(r\"u(x, t) = f(x \\pm ct)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n        \n        # Discussing the influence of initial conditions\n        initial_conditions = Text(\"The form of f is determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, initial_conditions))\n        self.wait(2)\n        \n        # Conclusion with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series definition\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier Series expands functions in terms of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation for coefficients\n        explanation2 = Text(\"Coefficients are found using integrals of the function times the sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Display the formula for coefficients\n        coefficients = MathTex(r\"a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\cos(nx)dx\", r\",\\ \\ b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\sin(nx)dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(1)\n\n        # Explaining convergence\n        explanation3 = Text(\"Fourier Series converge to the function under certain conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show a graph\n        self.clear()\n        func_graph = self.get_graph(lambda x: np.sin(x))\n        self.play(ShowCreation(func_graph))\n        self.wait(1)\n\n        # Wrap up the scene\n        self.play(FadeOut(func_graph))\n        self.wait(1)\n\n    def get_graph(self, function):\n        return FunctionGraph(function, color=WHITE, x_range=[-PI, PI])"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation\", font_size=34).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(2)\n\n        # Write down the context of the equation\n        context = Text(\n            \"This equation describes the propagation of waves, at a speed c, through a medium.\", \n            font_size=24\n        ).next_to(wave_eq, DOWN)\n        self.play(Write(context))\n        self.wait(3)\n\n        # Show the one-dimensional example\n        one_d_example = MathTex(r\"u(x,t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(Transform(wave_eq, one_d_example))\n        self.wait(2)\n\n        explanation = Text(\n            \"This is an example of a sinusoidal wave solution for the one-dimensional wave equation.\",\n            font_size=24\n        ).next_to(one_d_example, DOWN)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Introduce the concept of superposition\n        superposition_expl = Text(\n            \"By the principle of superposition, solutions can be combined to form new solutions.\",\n            font_size=24\n        )\n        self.play(Transform(explanation, superposition_expl))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(title), FadeOut(one_d_example), FadeOut(explanation))\n        self.wait(1)\n\n        # Display the superposition of two waves\n        superposition_eq = MathTex(r\"u(x,t) = A \\sin(kx - \\omega t) + B \\sin(k'x - \\omega' t)\")\n        self.play(FadeIn(superposition_eq))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x, thus du = 2dx\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Changing the integral\n        substitute_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), substitute_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate using the antiderivative of e^u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(substitute_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParametricCurveExample(Scene):\n    def construct(self):\n        # Title for the scene\n        title = Text(\"Parametric Curve Representation\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Moving the title to the top of the frame\n        self.play(ApplyMethod(title.to_edge, UP))\n        self.wait(1)\n\n        # Parametric Curve equation\n        curve_eq = MathTex(r\"\\vec{r}(t) = \\begin{bmatrix} \\cos(t) \\\\ \\sin(t) \\\\ t \\end{bmatrix}\", font_size=36)\n        self.play(Write(curve_eq))\n        self.wait(2)\n\n        # Explanation for parametric curves\n        explanation = Text(\"This represents a 3D helix\", font_size=24).next_to(curve_eq, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Plot the parametric curve\n        curve = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), t]),\n            t_range = np.array([0, 2*PI]),\n            color = BLUE\n        )\n        self.play(Create(curve))\n        self.wait(2)\n\n        # Axes for the curve\n        axes = ThreeDAxes()\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Transform the 2D curve Eq to 3D\n        self.play(Transform(curve_eq, curve_eq.copy().set_z(1)))\n        self.wait(1)\n\n        # Rotate to show 3D\n        self.move_camera(phi=65 * DEGREES, theta=-45 * DEGREES)\n        self.wait(2)\n\n        # Clear the scene and show only the 3D plot\n        self.clear()\n        self.play(Create(axes), Create(curve))\n        self.wait(2)\n\n        # Conclude the animation\n        self.play(FadeOut(curve), FadeOut(axes))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\left[\\frac{1}{2}x^2yz\\right]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}yz\\right]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}z^2\\right]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParametricFunctionExample(Scene):\n    def construct(self):\n        # Display the parametric function\n        param_func_text = MathTex(r'\\vec{r}(t) = \\langle \\cos(t), \\sin(t) \\rangle')\n        self.play(Write(param_func_text))\n        self.wait(1)\n\n        # Explain the parametric curve representation\n        explanation1 = Text(\"This parametric function represents a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The parametric curve\n        circle = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), 0]),\n            t_range=[0, TAU]\n        )\n        self.play(ShowCreation(circle))\n        self.wait(2)\n\n        # Label point moving along the curve\n        dot = Dot(radius=0.08)\n        dot.move_to(circle.get_start())\n        dot_label = MathTex(r'\\vec{r}(t)', color=BLUE).next_to(dot, RIGHT)\n        self.play(FadeIn(dot), FadeIn(dot_label))\n        self.wait(1)\n\n        # Animate the point moving along the curve\n        self.play(MoveAlongPath(dot, circle), rate_func=linear, run_time=5)\n        self.wait(1)\n\n        # Explanation for the parametric curve evolution\n        explanation2 = Text(\"As t varies from 0 to 2\u03c0, the point traces the circle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        final_message = Text(\"Parametric curves can represent complex shapes\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CircleAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"A = \\pi r^2\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area of a circle\n        explanation1 = Text(\"Area of a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the variable for radius\n        radius_step = MathTex(r\"r = 2\")\n        self.play(FadeIn(radius_step, shift=DOWN))\n        self.wait(1)\n\n        # Explanation for substitution\n        explanation2 = Text(\"Substitute the value of r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Perform the substitution\n        substitution = MathTex(r\"A = \\pi (2)^2\")\n        self.play(ReplacementTransform(problem.copy(), substitution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\\pi\")\n        self.play(ReplacementTransform(substitution, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The area is 4\u03c0 units.\", font_size=36)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ \\frac{1}{2} r^2 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate inner integral\n        evaluated_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{2} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{2} \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner, final_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Presenting the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # First integral explanation\n        explanation1 = Text(\"Integrating with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Second integral explanation\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"= [\\frac{1}{3}r^3 (-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(1 - (-1)) = \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_integral, final_answer))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area inside a unit semicircle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\text{Area under } f(x) \\text{ from } x = 1 \\text{ to } x = 2\")\n        area_problem.next_to(function_tex, DOWN)\n        self.play(Write(area_problem))\n        self.wait(2)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x ** 2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Fill the area under the curve\n        area = axes.get_area(graph, x_range=(1, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the definite integral\n        integral = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        integral_result = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^2\")\n        integral_solution = MathTex(r\"= \\left.\\frac{1}{3}x^3\\right|_1^2\")\n        integral_value = MathTex(r\"= \\frac{1}{3}(2^3) - \\frac{1}{3}(1^3)\")\n        final_answer = MathTex(r\"= \\frac{7}{3}\")\n\n        integral.to_edge(UP)\n        integral_result.next_to(integral, DOWN)\n        integral_solution.next_to(integral_result, DOWN)\n        integral_value.next_to(integral_solution, DOWN)\n        final_answer.next_to(integral_value, DOWN)\n\n        self.play(Write(integral))\n        self.wait(2)\n\n        self.play(Write(integral_result))\n        self.wait(2)\n\n        self.play(Write(integral_solution))\n        self.wait(2)\n\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Presenting the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Integration technique\n        explanation1 = Text(\"Apply the anti-derivative of exponential\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral process\n        integral_step = MathTex(r\"\\frac{1}{2} \\int e^{2x} \\cdot 2 \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Further explanation for integration\n        explanation2 = Text(\"Integrate by recognizing the pattern\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # The final answer\n        final_answer = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integral_step, final_answer))\n        self.wait(1)\n\n        # Clean the scene and display the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass LinearAlgebraScene(Scene):\n    def construct(self):\n        # Display the matrix\n        matrix = MathTex(r\"\\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n\n        # Display the determinant calculation\n        det_text = Text(\"Determinant of the matrix\", font_size=24).to_edge(UP)\n        self.play(FadeIn(det_text))\n        self.wait(1)\n\n        # Show the determinant formula\n        det_formula = MathTex(r\"\\det(A) = ad - bc\")\n        self.play(Transform(matrix.copy(), det_formula))\n        self.wait(2)\n\n        # Calculate the determinant\n        det_value = MathTex(r\"\\det(A) = 1 \\cdot 4 - 2 \\cdot 3 = -2\")\n        self.play(ReplacementTransform(det_formula, det_value))\n        self.wait(2)\n\n        # Explain the inverse of a matrix\n        inverse_text = Text(\"Inverse of the matrix\", font_size=24).to_edge(UP)\n        self.play(Transform(det_text, inverse_text))\n        self.wait(2)\n\n        # Inverse of the matrix\n        inverse_matrix = MathTex(r\"A^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix}\")\n        self.play(ReplacementTransform(det_value, inverse_matrix))\n        self.wait(3)\n\n        # Clear the scene and conclude with a final message\n        self.clear()\n        final_message = Text(\"That's how you compute a determinant and an inverse!\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= \\pi\")\n        self.play(Write(final_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{3}\\Big|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the limits\n        explanation2 = Text(\"Evaluate at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing evaluation at the limits\n        evaluated_solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Simplify to get the final result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        series_formula = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(Write(series_formula))\n        self.wait(2)\n\n        # Explanation for Fourier series\n        explanation1 = Text(\"This is the formula for a Fourier series.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier series representation\n        representation = Text(\"It represents periodic functions as infinite sums of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, representation))\n        self.wait(2)\n\n        # Displaying partial sum notation\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^{N} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(ReplacementTransform(series_formula, partial_sum))\n        self.wait(2)\n\n        # Explanation for partial sums\n        partial_explanation = Text(\"Here, \\(S_N(x)\\) is the N-th partial sum of the series.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, partial_explanation))\n        self.wait(2)\n\n        # Clear the scene and finish\n        self.clear()\n        self.wait(1)\n        self.play(Write(partial_sum))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Display the sum of geometric series\n        sum_of_series = MathTex(r\"S = a + ar + ar^2 + ar^3 + \\cdots\")\n        self.play(Write(sum_of_series))\n        self.wait(1)\n\n        # Explanation for the formula of a finite geometric series\n        explanation1 = Text(\"Formula of a finite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Finite geometric series formula\n        finite_formula = MathTex(r\"S_n = \\frac{a(1-r^n)}{1-r}\")\n        self.play(ReplacementTransform(sum_of_series.copy(), finite_formula))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation2 = Text(\"For |r| < 1, the sum of an infinite series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Infinite geometric series formula\n        infinite_formula = MathTex(r\"S_\\infty = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(finite_formula, infinite_formula))\n        self.wait(1)\n\n        # Evaluate an example of an infinite geometric series\n        example_evaluation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}}\")\n        self.play(ReplacementTransform(infinite_formula, example_evaluation))\n        self.wait(1)\n\n        # Solution to the example\n        solution_to_example = MathTex(r\"S = 2\")\n        self.play(ReplacementTransform(example_evaluation, solution_to_example))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_to_example))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"f(x) = e^x\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Taylor series expansion\n        explanation1 = Text(\"Let's expand using Taylor series around x=0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Taylor series expansion\n        taylor_expansion = MathTex(r\"e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots\")\n        self.play(Write(taylor_expansion))\n        self.wait(2)\n\n        # Display a finite number of terms\n        finite_terms = MathTex(r\"e^x \\approx 1 + x + \\frac{x^2}{2} + \\frac{x^3}{6}\")\n        self.play(ReplacementTransform(taylor_expansion.copy(), finite_terms))\n        self.wait(1)\n\n        # Explanation for truncating the series\n        explanation2 = Text(\"This is a 3rd-degree polynomial approximation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and show only the approximation\n        self.clear()\n        self.wait(1)\n        self.play(Write(finite_terms))\n        self.wait(1)\n        self.play(FadeOut(finite_terms))\n        self.wait(1)\n\n        # Show the radius of convergence\n        radius_explanation = Text(\"The radius of convergence for the Taylor series of e^x is \\(\\infty\\).\", font_size=24)\n        self.play(Write(radius_explanation))\n        self.wait(1)\n        self.play(FadeOut(radius_explanation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillatorODE(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\omega\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C_1 \\cos(\\omega x) + C_2 \\sin(\\omega x)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the demonstration\", font_size=24)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the type of equation\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The general solution can be written as u(x, t) = f(x - ct) + g(x + ct)\", font_size=24).move_to(explanation1)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(problem, DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the d'Alembert's formula\n        explanation3 = Text(\"This is known as d'Alembert's formula.\", font_size=24).move_to(explanation1)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Showing d'Alembert's formula\n        dalemberts_formula = MathTex(r\"u(x, t) = \\frac{1}{2}[f(x - ct) + f(x + ct)] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} g(s) ds\")\n        dalemberts_formula.next_to(general_solution, DOWN)\n        self.play(Write(dalemberts_formula))\n        self.wait(1)\n\n        # Clear the scene and show final formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(dalemberts_formula))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integration limits\n        limits = MathTex(r\"[0, 2]\")\n        self.play(FadeIn(limits.next_to(problem, DOWN)))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Use the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(1)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(1)\n\n        # Performing the integration\n        solution_step1 = MathTex(r\"= \\frac{x^{3}}{3} \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution_step1))\n        self.wait(1)\n\n        # Explanation for evaluation at limits\n        explanation2 = Text(\"Evaluate at limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Evaluating the solution\n        solution_step2 = MathTex(r\"= \\frac{2^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution_step1, solution_step2))\n        self.wait(1)\n\n        # Final calculation\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(solution_step2, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for getting started\n        explanation1 = Text(\"Let's solve this first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transform the ODE to separate variables\n        separated_variables = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(problem.copy(), separated_variables))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation2 = Text(\"We separate the variables\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrating both sides\n        integral_form = MathTex(r\"\\int{\\frac{1}{y}dy} = \\int{3dx}\")\n        self.play(Transform(separated_variables, integral_form))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation3 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # The solution after integration\n        ln_solution = MathTex(r\"\\ln{|y|} = 3x + C\")\n        self.play(ReplacementTransform(integral_form, ln_solution))\n        self.wait(1)\n\n        # Explanation for exponential form\n        explanation4 = Text(\"Convert to exponential form\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # General solution in exponential form\n        general_solution = MathTex(r\"y = Ae^{3x}\")\n        self.play(ReplacementTransform(ln_solution, general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation5 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation5))\n        self.wait(2)\n\n        # Clear the scene and conclude with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\, dr \\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral (r)\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral (theta)\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function f(x)\n        function_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Show the area we want to find\n        area_description = Text(\"Find area under curve from x=0 to x=1\", font_size=24).to_edge(UP)\n        self.play(Write(area_description))\n        self.wait(2)\n\n        # Set up the curve and area\n        graph = FunctionGraph(lambda x: x**2, x_range=[0, 1], color=BLUE)\n        area = graph.get_riemann_rectangles(x_range=[0, 1], dx=0.1,\n                                            stroke_width=0.1, stroke_color=ORANGE,\n                                            fill_opacity=0.75)\n        self.play(Create(graph))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Display the definite integral\n        integral = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(ReplacementTransform(area_description, integral))\n        self.wait(2)\n\n        # Calculate the solution\n        solution = MathTex(r\"=\\frac{1}{3}x^3 \\bigg|_0^1\", \"=\", r\"\\frac{1}{3}\")\n        self.play(Write(solution))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the area problem\n        area_problem = MathTex(r\"\\text{Area under } f(x) = e^{-x} \\text{ from } x = 0 \\text{ to } x = 1\")\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Explaining the definite integral representation\n        explanation1 = Text(\"Represent as a definite integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Definite integral setup\n        integral_setup = MathTex(r\"\\int_0^1 e^{-x} \\,dx\")\n        self.play(ReplacementTransform(area_problem, integral_setup))\n        self.wait(1)\n\n        # Showing antiderivative\n        antiderivative_step = MathTex(r\"= [-e^{-x}]_0^1\")\n        self.play(ReplacementTransform(integral_setup, antiderivative_step))\n        self.wait(1)\n\n        # Explaining the evaluation of the antiderivative at the bounds\n        explanation2 = Text(\"Evaluate from 0 to 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution calculation\n        final_solution = MathTex(r\"= -(e^{-1} - e^{0}) = 1 - \\frac{1}{e}\")\n        self.play(ReplacementTransform(antiderivative_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sqrt{1 - x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric substitution\n        explanation1 = Text(\n            \"Use trigonometric substitution: \",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Choosing substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), \\quad dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Rewriting the integral\n        rewritten_integral = MathTex(r\"= \\int \\sqrt{1 - \\sin^2(\\theta)} \\cos(\\theta) d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), rewritten_integral))\n        self.wait(1)\n\n        # Simplifying the integral\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta) d\\theta\")\n        self.play(ReplacementTransform(rewritten_integral, simplified_integral))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        explanation2 = Text(\n            \"Solve the integral using a trigonometric identity\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Using the identity for cos^2(theta)\n        identity_substitution = MathTex(r\"= \\frac{1}{2} \\int (1 + \\cos(2\\theta)) d\\theta\")\n        self.play(ReplacementTransform(simplified_integral, identity_substitution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(identity_substitution, final_solution))\n        self.wait(1)\n\n        # Rewriting theta in terms of x\n        back_substitution = MathTex(r\"x = \\sin(\\theta) \\Rightarrow \\theta = \\arcsin(x)\")\n        final_solution_with_x = MathTex(r\"= \\frac{\\arcsin(x)}{2} + \\frac{\\sin(2\\arcsin(x))}{4} + C\")\n        self.play(Write(back_substitution))\n        self.wait(1)\n        self.play(ReplacementTransform(final_solution, final_solution_with_x))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution_with_x))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DefiniteIntegral(Scene):\n    def construct(self):\n        # Introduce the definite integral problem\n        problem = MathTex(r\"\\int_{a}^{b} x dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integral boundaries\n        boundaries_explanation = Text(\"Evaluating from 'a' to 'b':\", font_size=24).to_edge(UP)\n        self.play(Write(boundaries_explanation))\n        self.wait(2)\n\n        # Show fundamental theorem of calculus\n        theorem = MathTex(r\"F(b) - F(a)\", \"=\", r\"\\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(theorem))\n        self.wait(2)\n\n        # Perform the definite integral calculation\n        solution = MathTex(r\"=\", r\"\\frac{b^2}{2}\", \"-\", r\"\\frac{a^2}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Highlight the result\n        highlight_box = SurroundingRectangle(solution[-2:], buff=.1)\n        self.play(Create(highlight_box))\n        self.wait(2)\n\n        # Clear everything\n        self.clear()\n        self.wait(1)\n\n        # Present the final result of the integral\n        final_result = MathTex(r\"\\int_{a}^{b} x dx\", \"=\", r\"\\frac{b^2}{2} - \\frac{a^2}{2}\")\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 2, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"y\")\n\n        # Function graph\n        graph = ax.plot(lambda x: 0.25 * x ** 2, color=GREEN)\n        graph_label = ax.get_graph_label(graph, label='y = 0.25x^2')\n\n        # Display the graph\n        self.play(Create(ax), Write(labels), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Create area under graph\n        area = ax.get_area(graph, x_range=(0, 2), color=YELLOW, opacity=0.5)\n        area_label = Tex(\"Area under curve\").next_to(area, DOWN)\n\n        # Show area and label\n        self.play(FadeIn(area), Write(area_label))\n        self.wait(2)\n\n        # Show the integral form\n        integral = MathTex(r\"\\int_0^2 0.25x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Transform(area_label, integral))\n        self.wait(1)\n\n        # Calculate the area with the integral value\n        integral_value = MathTex(\"= \\\\frac{1}{3}x^3\\Big|_0^2 =\", \" \\\\frac{8}{3}\")\n        integral_value.next_to(integral, DOWN)\n\n        # Show the calculation result\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final area value\n        self.play(Write(integral_value[1]))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Display final answer\n        answer = MathTex(r\"= \\frac{\\pi}{4}\")\n        self.play(Transform(final_solution, answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the curve and the area under the curve\n        curve = FunctionGraph(lambda x: 0.1 * (x - 3) ** 2 + 1, x_range=[0, 5])\n        area = area = Integral(curve, (x, 0, 5), fill_opacity=0.5)\n\n        # Displaying the problem\n        problem = MathTex(r\"Find \\, \\int_{0}^{5} 0.1 (x - 3)^2 + 1 \\, dx\")\n        problem.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Draw curve and area\n        self.play(DrawBorderThenFill(curve))\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"The shaded region represents the area\", font_size=24)\n        explanation.next_to(area, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Computing the area\n        computation_step1 = MathTex(r\"= \\frac{0.1}{3} (x - 3)^3 \\Big|_0^5 + 5\")\n        computation_step1.next_to(problem, DOWN)\n        self.play(Write(computation_step1))\n        self.wait(2)\n\n        computation_step2 = MathTex(r\"= \\frac{0.1}{3} ((5-3)^3-(0-3)^3) + 5\")\n        computation_step2.next_to(computation_step1, DOWN)\n        self.play(Write(computation_step2))\n        self.wait(2)\n\n        computation_step3 = MathTex(r\"= \\frac{0.1}{3} (8 - (-27)) + 5\")\n        computation_step3.next_to(computation_step2, DOWN)\n        self.play(Write(computation_step3))\n        self.wait(2)\n\n        computation_step4 = MathTex(r\"= \\frac{0.1}{3} (35) + 5 = \\frac{35}{30} + 5\")\n        computation_step4.next_to(computation_step3, DOWN)\n        self.play(Write(computation_step4))\n        self.wait(2)\n\n        final_area = MathTex(r\"= \\frac{7}{6} + 5\")\n        final_area.next_to(computation_step4, DOWN)\n        self.play(Transform(computation_step4, final_area))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicIntegralExample(Scene):\n    def construct(self):\n        # Introduce the function to be integrated\n        equation = MathTex(r\"f(x) = e^{x}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Display the integral problem\n        integral_problem = MathTex(r\"\\int e^{x} \\,dx\")\n        self.play(Transform(equation, integral_problem))\n        self.wait(2)\n\n        # Explain the integral rule for e^x\n        integration_rule_text = Text(\"The integral of e^x is e^x + C\", font_size=24).to_edge(UP)\n        self.play(Write(integration_rule_text))\n        self.wait(2)\n\n        # Show the solution using the rule\n        integral_solution = MathTex(r\"= e^{x} + C\")\n        self.play(ReplacementTransform(integral_problem, integral_solution))\n        self.wait(2)\n\n        # Highlight the constant of integration\n        constant_of_integration = MathTex(r\"+ C\").set_color(YELLOW)\n        self.play(Transform(integral_solution[-2:], constant_of_integration))\n        self.wait(1)\n\n        # Clean up the scene to show just the final result\n        self.play(FadeOut(integration_rule_text))\n        self.wait(1)\n\n        # Show the final conclusive solution\n        final_solution = MathTex(r\"\\int e^{x} \\,dx = e^{x} + C\").move_to(UP)\n        self.play(Transform(integral_solution, final_solution))\n        self.wait(2)\n        \n        # End the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Introduction of the Pythagorean Theorem\n        theorem_text = MathTex(\"a^2 + b^2 = c^2\").scale(2)\n        self.play(Write(theorem_text))\n        self.wait(2)\n\n        # Display a right angle triangle\n        triangle = Polygon(np.array([-1, -1, 0]), np.array([-1, 1, 0]), np.array([1, -1, 0]))\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Label the sides of the triangle\n        side_a = MathTex(\"a\").next_to(triangle, LEFT)\n        side_b = MathTex(\"b\").next_to(triangle, DOWN)\n        side_c = MathTex(\"c\").next_to(triangle.get_center(), RIGHT)\n        self.play(Write(side_a), Write(side_b), Write(side_c))\n        self.wait(1)\n\n        # Show the squares of side a and side b\n        square_a = Square(side_length=2).move_to(triangle.get_vertices()[0] + np.array([-1, 0, 0]))\n        square_b = Square(side_length=2).move_to(triangle.get_vertices()[2] + np.array([0, -1, 0]))\n        self.play(Create(square_a), Create(square_b))\n        self.wait(1)\n\n        # Show the square of side c\n        square_c = Square(side_length=2 * np.sqrt(2)).rotate(np.arctan2(1, 1)).move_to(triangle.get_center())\n        self.play(Create(square_c))\n        self.wait(1)\n\n        # Show that the area of c^2 is the sum of a^2 and b^2\n        equation = MathTex(\"a^2\", \"+\", \"b^2\", \"=\", \"c^2\").scale(2)\n        self.play(\n            Transform(side_a.copy(), equation[0]),\n            Transform(side_b.copy(), equation[2]),\n            Transform(side_c.copy(), equation[4]),\n        )\n        self.wait(1)\n\n        # Show conclusion of the theorem\n        conclusion = Text(\"This illustrates the Pythagorean Theorem.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear scene and display only the theorem\n        self.clear()\n        self.play(Write(theorem_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-2}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-2}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2z^2]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}x^3y^2z^2]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integral limits explanation\n        limits_explanation = Text(\"We evaluate from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(limits_explanation))\n        self.wait(2)\n\n        # Explain the integration rule\n        rule_explanation = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\Bigg|_a^b\")\n        self.play(Write(rule_explanation))\n        self.wait(2)\n\n        # Applying the integration rule to the problem\n        integral_step = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Showing the simplification\n        simplification = Text(\"Simplify the power expression\", font_size=24).to_edge(UP)\n        self.play(Transform(limits_explanation, simplification))\n        self.wait(2)\n\n        # Simplified expression\n        simplified_expr = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(integral_step, simplified_expr))\n        self.wait(1)\n\n        # Evaluating the definite integral at the boundaries\n        evaluation = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(limits_explanation, evaluation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2\")\n        final_solution_next = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        final_solution_final = MathTex(r\"= \\frac{16}{4} - 0\")\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(simplified_expr, final_solution))\n        self.wait(1)\n        self.play(Transform(final_solution, final_solution_next))\n        self.wait(1)\n        self.play(Transform(final_solution, final_solution_final))\n        self.wait(1)\n        self.play(Transform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        final_answer_static = final_answer.copy().to_edge(UP)\n        self.play(Write(final_answer_static))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Use the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integral_step = MathTex(r\"\\int x^2 dx = \\frac{1}{3} x^3 + C\")\n        self.play(ReplacementTransform(problem, integral_step))\n        self.wait(2)\n\n        # Show area under parabola\n        graph = FunctionGraph(lambda x: x**2, x_range=[-3,3], color=BLUE)\n        area = graph.get_area(x_range=[0,2], color=GREEN, opacity=0.5)\n        self.play(ShowCreation(graph), FadeIn(area, rate_func=smooth, run_time=3))\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(1)\n\n        # Clear the scene and show final solution\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(explanation1))\n        self.wait(1)\n        final_solution = MathTex(r\"\\frac{1}{3} x^3 + C\")\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Display the differential equation\n        ode = MathTex(r\"m\\ddot{x} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(2)\n\n        # Display the explanation for the angular frequency\n        angular_freq_explanation = Text(\"Angular frequency:\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq_explanation))\n        self.wait(1)\n\n        # Display the angular frequency formula\n        omega = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(ode.copy(), omega))\n        self.wait(2)\n\n        # Explaining the solution type\n        solution_type_explanation = Text(\"The solution is harmonic\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq_explanation, solution_type_explanation))\n        self.wait(2)\n\n        # Display the general solution of the harmonic oscillator\n        solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(omega, solution))\n        self.wait(2)\n\n        # Exhibit the amplitude and phase\n        amplitude_phase_explanation = Text(\"A is amplitude, and \u03c6 is phase\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq_explanation, amplitude_phase_explanation))\n        self.wait(2)\n\n        # Clear the scene and conclude with the final solution\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Complete harmonic motion equation\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion))\n        self.play(Write(solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_S \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Detail the vector field F\n        vector_field = MathTex(r\"\\vec{F} = x\\hat{i} + y\\hat{j} + z\\hat{k}\").next_to(problem, DOWN)\n        self.play(Write(vector_field))\n        self.wait(1)\n        \n        # Detail surface S\n        surface_s = MathTex(r\"S: z = x^2 + y^2\").next_to(vector_field, DOWN)\n        self.play(Write(surface_s))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize Surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization of S\n        parameterization = MathTex(r\"\\vec{r}(u,v) = u\\hat{i} + v\\hat{j} + (u^2+v^2)\\hat{k}\", r\",\\quad S: u^2+v^2 \\leq 1\")\n        self.play(Write(parameterization))\n        self.wait(2)\n\n        # Compute dS\n        explanation2 = Text(\"Compute dS using cross product of partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Computation of dS\n        compute_ds = MathTex(r\"d\\vec{S} = \\left|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\right| du\\, dv \\hat{k}\")\n        self.play(Write(compute_ds))\n        self.wait(2)\n\n        # Plug in F and dS\n        explanation3 = Text(\"Substitute F and dS into the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Substituting in the integral\n        substituted_integral = MathTex(r\"\\iint_S (x\\hat{i} + y\\hat{j} + z\\hat{k}) \\cdot d\\vec{S}\")\n        self.play(Transform(problem, substituted_integral))\n        self.wait(1)\n\n        # Final steps\n        explanation4 = Text(\"Evaluate the integral over the parameterized domain\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n        \n        # Final evaluation\n        final_evaluation = MathTex(r\"\\iint_{D} f(u, v) \\ du \\ dv\", r\",\\quad D:\\  u^2+v^2 \\leq 1\")\n        self.play(Transform(problem, final_evaluation))\n        self.wait(1)\n        \n        # Conclude with the solution\n        solution = Text(\"Compute the final integral to get the result.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\Bigg|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate the integral from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplified solution\n        solution2 = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, solution2))\n        self.wait(1)\n\n        # Calculate the final result\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(solution2, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        conclusion = Text(\"The area under the curve is 4\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SineWaveExample(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\sin(x) = y\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        text = Text(\"The graph of a sine function\", font_size=24).to_edge(UP)\n        self.play(Write(text))\n        self.wait(2)\n\n        # Create a sine curve\n        graph = self.get_graph(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n\n        new_text = Text(\"Sine waves have a periodic nature\", font_size=24).to_edge(UP)\n        self.play(Transform(text, new_text))\n        self.wait(2)\n\n        amplitude_text = Text(\"Amplitude: 1, Period: \\(2\\pi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(text, amplitude_text))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(equation))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color, x_range=[-PI, PI])"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Introduce the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Show the wave equation label\n        label = Text(\"This is the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(label))\n        self.wait(2)\n\n        # Describe the wave speed\n        wave_speed = Text(\"Here, \\(c\\) represents the wave speed.\", font_size=24)\n        wave_speed.next_to(label, DOWN)\n        self.play(Write(wave_speed))\n        self.wait(2)\n\n        # Transform to a 3D wave equation\n        equation_3d = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)\")\n        self.play(Transform(equation, equation_3d))\n        self.wait(2)\n\n        # Acknowledge the 3D context\n        context_3d = Text(\"Now it's a 3D wave equation!\", font_size=24)\n        context_3d.next_to(label, DOWN)\n        self.play(Transform(wave_speed, context_3d))\n        self.wait(2)\n\n        # Provide an example solution\n        solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation_3d, solution))\n        self.wait(2)\n\n        # Explain the solution components\n        components = Text(\"Where \\(A\\) is amplitude, \\(k\\) is wave number, and \\(\\omega\\) is angular frequency.\", font_size=24)\n        components.to_edge(DOWN)\n        self.play(Write(components))\n        self.wait(2)\n\n        # Fade out everything to conclude\n        self.play(FadeOut(solution), FadeOut(components), FadeOut(wave_speed), FadeOut(label))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series representation of a function\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n\\cos(nx) + b_n\\sin(nx)\\right)\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Display the coefficients explanation\n        coefficients_explanation = Text(\"Coefficients are calculated from the function.\", font_size=24).to_edge(UP)\n        self.play(Write(coefficients_explanation))\n        self.wait(2)\n\n        # Explaining even and odd functions\n        odd_even_explanation = Text(\"For even functions, b_n = 0. For odd functions, a_n = 0.\", font_size=24).to_edge(UP)\n        self.play(Transform(coefficients_explanation, odd_even_explanation))\n        self.wait(2)\n\n        # Displaying the formula for coefficients\n        coefficients_formula = MathTex(r\"a_n = \\frac{2}{T}\\int_{0}^{T} f(x)\\cos(nx)dx, \\\\ b_n = \\frac{2}{T}\\int_{0}^{T} f(x)\\sin(nx)dx\")\n        self.play(Transform(fourier_series, coefficients_formula))\n        self.wait(2)\n\n        # Comment on real-world applications\n        applications_explaining = Text(\"Fourier series play a crucial role in signal processing and heat transfer.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(coefficients_explanation, applications_explaining))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(fourier_series))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^2}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{3}x^3]_{0}^{\\sqrt{1-y^2}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluation\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution (elaborate as necessary for the math at hand)\n        final_solution = MathTex(r\"= \\frac{1}{3} \\int_{0}^{1} (1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the definite integral problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Calculate the definite integral using limits:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Performing the integration step\n        integral_step = MathTex(r\"= \\left[ \\frac{x^{3+1}}{3+1} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(2)\n\n        # Showing the limits substituted\n        limits_substituted = MathTex(r\"= \\left[ \\frac{x^4}{4} \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(integral_step, limits_substituted))\n        self.wait(2)\n\n        # Evaluating at upper and lower limits\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(limits_substituted, evaluation))\n        self.wait(2)\n\n        # Showing the final answer\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_answer))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(explanation), FadeOut(final_answer))\n        self.wait(1)\n\n        # Final scene showing the result\n        result = Text(\"Integral result is 4.\", font_size=36)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaParametricSurfaceExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S\", r\"\\sqrt{1 + (\\frac{\\partial z}{\\partial x})^2 + (\\frac{\\partial z}{\\partial y})^2}\", r\"\\,dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(x, y) = (x, y, f(x, y))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for partial derivatives\n        explanation2 = Text(\"Compute the partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Computing the partial derivatives\n        partial_derivatives = MathTex(r\"\\frac{\\partial z}{\\partial x} = f_x\", r\"\\quad\\text{and}\\quad\", r\"\\frac{\\partial z}{\\partial y} = f_y\")\n        self.play(ReplacementTransform(parameterization, partial_derivatives))\n        self.wait(1)\n\n        # Explanation for normal vector\n        explanation3 = Text(\"Find the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Normal vector step\n        normal_vector = MathTex(r\"\\mathbf{N} = (-f_x, -f_y, 1)\")\n        self.play(ReplacementTransform(partial_derivatives, normal_vector))\n        self.wait(1)\n\n        # Explanation for the magnitude of the normal vector\n        explanation4 = Text(\"Calculate the magnitude of the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Magnitude step\n        magnitude = MathTex(r\"||\\mathbf{N}|| = \\sqrt{f_x^2 + f_y^2 + 1}\")\n        self.play(ReplacementTransform(normal_vector, magnitude))\n        self.wait(1)\n\n        # Final surface integral step\n        surface_integral = MathTex(r\"\\iint_S\", r\"\\sqrt{f_x^2 + f_y^2 + 1}\", r\"\\,dA\")\n        self.play(ReplacementTransform(magnitude, surface_integral))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation5 = Text(\"Integrate over the region A\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation5))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"\\text{Surface Area} = \\int\\int_A\", r\"\\sqrt{f_x^2 + f_y^2 + 1}\", r\"\\,dA\")\n        self.play(ReplacementTransform(surface_integral, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigFunctionIntegration(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral of sin(x)\n        explanation1 = Text(\"Integral of sine function:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the integral rule for sine\n        integral_rule = MathTex(r\"\\int \\sin(x) \\,dx = -\\cos(x) + C\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Writing down the solution steps\n        solution = MathTex(r\"= -\\cos(x) + C\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Explanation for adding the constant\n        explanation2 = Text(\"Don't forget the integration constant C\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(explanation1), FadeOut(solution))\n        self.wait(1)\n\n        # Final presentation of the solution\n        final_solution = MathTex(r\"-\\cos(x) + C\")\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-1}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^3]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation for simple harmonic motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} = -kx\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain what each term represents\n        terms_explanation = Text(\n            \"Represents mass, spring constant, and position (m, k, x)\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Write(terms_explanation))\n        self.wait(2)\n\n        # Show the form of the solution\n        solution_form = MathTex(r\"x(t) = A \\cos(\\omega t - \\phi)\")\n        self.play(ReplacementTransform(equation, solution_form))\n        self.wait(1)\n\n        # Explain the solution terms\n        solution_explanation = Text(\n            \"Where A is amplitude, omega is angular frequency, and phi is phase shift\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Transform(terms_explanation, solution_explanation))\n        self.wait(2)\n\n        # Oscillation\n        oscillator = Circle(radius=1.0, color=BLUE)\n        oscillator.move_to(4*LEFT)\n        self.play(Create(oscillator))\n        \n        # Create an arrow representing the force\n        arrow = Arrow(\n            oscillator.get_edge_center(RIGHT),\n            oscillator.get_edge_center(RIGHT) + 2*RIGHT,\n            buff=0\n        )\n        self.play(GrowArrow(arrow))\n        self.wait(1)\n\n        # Oscillate the circle to the right\n        self.play(oscillator.animate.move_to(4*RIGHT), run_time=2, rate_func=there_and_back)\n        self.wait(1)\n\n        # Clear the scene and show the solution again\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_form))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Showing the function\n        function_label = MathTex(\"f(x) = x^2\", font_size=24).to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Plotting the graph\n        graph = FunctionGraph(lambda x: x**2, x_range=[0,2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Area under the graph\n        area = area = Integral(graph, (0, 2))\n        area.set_fill(opacity=0.3)\n        self.play(Write(area))\n        self.wait(1)\n\n        # Integral calculus\n        integral_form = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_form))\n        self.wait(1)\n\n        # Calculating the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_form.copy(), integral_solution))\n        self.wait(1)\n\n        # Evaluating at bounds\n        evaluated_solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_solution, evaluated_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(evaluated_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaBetweenCurves(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for the axes\n        x_label = axes.get_x_axis_label(MathTex(\"x\"))\n        y_label = axes.get_y_axis_label(MathTex(\"y\")).shift(LEFT)\n\n        # Functions\n        func_graph1 = axes.plot(lambda x: x**2, color=RED)\n        func_graph2 = axes.plot(lambda x: 0.8*x**2 + 1, color=GREEN)\n\n        # Area between curves\n        area = axes.get_area(func_graph2, [0, 2], bounded_graph=func_graph1, color=ORANGE, opacity=0.5)\n\n        # Display the axes, labels, and functions\n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.play(Create(func_graph1), Create(func_graph2))\n        self.wait(1)\n\n        # Highlight the area\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem setup\n        problem_text = MathTex(r\"\\text{Find area between }\", \"y = x^2\", r\"\\text{ and }\", \"y = 0.8x^2 + 1\")\n        problem_text.to_edge(UP)\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Solving step 1: highlighting the functions\n        self.play(Indicate(func_graph1), Indicate(func_graph2))\n        self.wait(1)\n\n        # Solving step 2: showing the integral\n        integral_text = MathTex(\n            r\"\\int_{0}^{2} \", \"(0.8x^2 + 1)\", \" - \", \"(x^2)\", r\"\\, dx\"\n        ).to_edge(DOWN)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Solving step 3: show the calculated area's value\n        calculated_area = MathTex(r\"= \", \"4/3\").next_to(integral_text, DOWN)\n        self.play(Write(calculated_area))\n        self.wait(1)\n\n        # Conclusion: clear and show the final answer\n        self.clear()\n        final_answer = MathTex(\n            r\"\\text{Area} = \\frac{4}{3}\"\n        ).scale(1.5).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{x} e^{y^2} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[ \\frac{e^{y^2}}{2y} \\right]_{0}^{x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for impossibility of inner integral\n        explanation2 = Text(\"This integral cannot be expressed in elementary functions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Numerical solution prompt\n        numerical_solution_prompt = Text(\"We shall evaluate it numerically\", font_size=24).to_edge(DOWN)\n        self.play(Write(numerical_solution_prompt))\n        self.wait(2)\n\n        # Numerical integral presentation\n        numerical_integral = MathTex(r\"\\approx \\text{numerical value}\")\n        self.play(ReplacementTransform(inner_integral, numerical_integral))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass QuadraticEquationExample(Scene):\n    def construct(self):\n        # Display the quadratic equation\n        equation = MathTex(\"x^2 - 5x + 6 = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for factoring the equation\n        explanation1 = Text(\"Factor the quadratic equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Factoring step\n        factored_form = MathTex(\"(x - 2)(x - 3) = 0\")\n        self.play(ReplacementTransform(equation, factored_form))\n        self.wait(1)\n\n        # Explanation for finding the roots\n        explanation2 = Text(\"Solve for the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Root solution\n        roots = MathTex(\"x = 2 , x = 3\")\n        self.play(ReplacementTransform(factored_form, roots))\n        self.wait(1)\n\n        # Show the roots on the number line\n        number_line = NumberLine(x_range=[0, 5, 1], length=10)\n        dot1 = Dot().move_to(number_line.n2p(2))\n        dot2 = Dot().move_to(number_line.n2p(3))\n\n        self.play(GrowFromCenter(number_line), FadeIn(dot1), FadeIn(dot2))\n        self.wait(1)\n\n        # Clear the scene and focus on the roots\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(roots))\n        self.wait(2)\n\n        # Conclude the example\n        conclusion = Text(\"Roots are x = 2 and x = 3\", font_size=24).to_edge(DOWN)\n        self.play(FadeIn(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of wave equation\n        explanation1 = Text(\"This is the classic wave equation for u(x,t).\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"Its solutions include harmonic waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = A\\cos(kx - \\omega t) + B\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n\n        # Explanation for harmonic solutions\n        explanation3 = Text(\"Here, A and B are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude by showing only the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SurfaceAreaPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} \\sqrt{1+r^2} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"=\\int_{0}^{2\\pi} \\left[\\frac{r}{2}\\sqrt{1+r^2}+\\frac{\\ln|r+\\sqrt{1+r^2}|}{2} \\right]_0^1 d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"=\\left[\\frac{\\theta}{2}\\left(\\sqrt{2}+\\ln(1+\\sqrt{2})\\right)\\right]_0^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\pi\\left(\\sqrt{2}+\\ln(1+\\sqrt{2})\\right)\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"\\int_0^2 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Explanation for the area calculation\n        explanation1 = Text(\"Area under the curve between 0 and 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Numerical approximation setup\n        approximation_setup = MathTex(r\"\\approx \\sum_{i=1}^n f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(area_problem, approximation_setup))\n        self.wait(1)\n\n        # Explanation for Riemann sum approximation\n        explanation2 = Text(\"Using Riemann sum to approximate the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Riemann sum formula with n=4\n        riemann_sum_4 = MathTex(r\"\\approx \\sum_{i=1}^4 f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(approximation_setup, riemann_sum_4))\n        self.wait(1)\n\n        # Explanation for increasing n for better approximation\n        explanation3 = Text(\"Increase n for a better approximation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Riemann sum formula with n=10\n        riemann_sum_10 = MathTex(r\"\\approx \\sum_{i=1}^{10} f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(riemann_sum_4, riemann_sum_10))\n        self.wait(1)\n\n        # Clear the scene and explain the result\n        self.play(FadeOut(explanation1), FadeOut(riemann_sum_10))\n        result_explanation = Text(\"As n increases, the approximation becomes more accurate.\", font_size=24)\n        self.play(Write(result_explanation))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GaussianIntegralExample(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Explanation for transforming the integral\n        transform_explanation = Text(\n            \"Use square to transform the integral\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(transform_explanation))\n        self.wait(2)\n\n        # Transform the integral\n        transformed_integral = MathTex(\n            r\"= \\left( \\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx \\right)^2\"\n        )\n        self.play(ReplacementTransform(integral.copy(), transformed_integral))\n        self.wait(2)\n\n        # Change to polar coordinates\n        polar_explanation = Text(\n            \"Change to polar coordinates\", font_size=24\n        ).to_edge(UP)\n        self.play(Transform(transform_explanation, polar_explanation))\n        self.wait(2)\n\n        # Polar coordinates step\n        polar_step = MathTex(r\"= \\int_0^{2\\pi} \\int_0^{\\infty} e^{-r^2} r \\,dr \\,d\\theta\")\n        self.play(ReplacementTransform(transformed_integral, polar_step))\n        self.wait(2)\n\n        # Explanation for evaluating the integral\n        evaluation_explanation = Text(\n            \"Evaluate the Gaussian integral\", font_size=24\n        ).to_edge(UP)\n        self.play(Transform(transform_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Evaluate the integral\n        evaluated_integral = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(polar_step, evaluated_integral))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\n            \"The Gaussian integral evaluates to sqrt(pi)\", font_size=24\n        )\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Setting up the axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            x_length=5,\n            y_length=3,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Defining the function to plot and its curve\n        func = lambda x: 0.2 * x ** 2\n        curve = axes.plot(\n            func, \n            x_range=[0, 4], \n            color=RED\n        )\n\n        # Area under the curve\n        area = axes.get_area(curve, x_range=(0, 4), color=GREEN, opacity=0.5)\n\n        # Plot and area labels\n        curve_label = axes.get_graph_label(curve, label='y=0.2x^2')\n        area_label = Text(\"Area under curve\", color=WHITE).scale(0.6).next_to(area, DOWN)\n\n        # Animate the display\n        self.play(Create(axes), Write(curve_label))\n        self.play(Create(curve))\n        self.play(FadeIn(area), FadeIn(area_label))\n        self.wait(2)\n\n        # Clear and show final message\n        self.clear()\n        final_message = Text(\"The area under y=0.2x^2 from x=0 to x=4\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the integral problem\n        problem = MathTex(r\"\\int_1^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the use of the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Apply the Fundamental Theorem of Calculus:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the anti-derivative\n        antiderivative = MathTex(r\"F(x) = \\frac{x^{4}}{4}\")\n        self.play(Write(antiderivative))\n        self.wait(2)\n\n        # Showing the evaluation of bounds\n        evaluation = MathTex(r\"F(2) - F(1) = \\frac{2^4}{4} - \\frac{1^4}{4}\")\n        self.play(Transform(problem, evaluation))\n        self.wait(1)\n\n        # Explanation for performing subtraction\n        explanation2 = Text(\"Calculate the difference for definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - \\frac{1}{4} = \\frac{15}{4}\")\n        self.play(ReplacementTransform(problem, final_solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Restating the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesScene(Scene):\n    def construct(self):\n        title = Text(\"Fourier Series\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction of a square wave\n        square_wave_text = Text(\"Consider a square wave signal:\", font_size=24).shift(UP*2)\n        signal_formula = MathTex(r\"f(x) = \\begin{cases} \n        1 & \\text{if } 0 \\leq x < \\frac{1}{2} \\\\\n        -1 & \\text{if } \\frac{1}{2} \\leq x < 1 \n        \\end{cases}\", substrings_to_isolate=\"x\")\n        signal_formula.next_to(square_wave_text, DOWN)\n\n        self.play(FadeIn(square_wave_text))\n        self.play(Write(signal_formula))\n        self.wait(2)\n\n        # Introduction of the Fourier series formula\n        fouriers_series_text = Text(\"Its Fourier series expansion is given by:\", font_size=24).shift(UP*2)\n        formula = MathTex(r\"f(x) \\sim \\frac{4}{\\pi}\\sum_{n=1,3,5}^{\\infty}\\frac{1}{n}\\sin(2\\pi nx)\", substrings_to_isolate=\"x\")\n        formula.next_to(fouriers_series_text, DOWN)\n\n        self.play(Transform(square_wave_text, fouriers_series_text))\n        self.play(Transform(signal_formula, formula))\n        self.wait(2)\n\n        # Show partial sum of Fourier series\n        partial_sum_text = Text(\"Partial sum of the series:\", font_size=24).shift(UP*2)\n        partial_sum_formula = MathTex(r\"S_N(x) = \\frac{4}{\\pi}\\sum_{n=1,3,5}^{N}\\frac{1}{n}\\sin(2\\pi nx)\", substrings_to_isolate=\"N\")\n        partial_sum_formula.next_to(partial_sum_text, DOWN)\n\n        self.play(Transform(square_wave_text, partial_sum_text))\n        self.play(Transform(signal_formula, partial_sum_formula))\n        self.wait(2)\n\n        # Clear the scene and finish\n        self.clear()\n        conclusion_text = Text(\"This is an example of Fourier Series approximation.\", font_size=24)\n        self.play(Write(conclusion_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier series definition\n        series_def = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(series_def))\n        self.wait(2)\n\n        # Explanation about periodic function\n        explanation1 = Text(\"Fourier series represents periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Example of a specific Fourier series\n        specific_series = MathTex(r\"f(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} (\\frac{4}{n\\pi} \\sin(n\\pi x))\")\n        self.play(ReplacementTransform(series_def, specific_series))\n        self.wait(2)\n\n        # Display the function graphics\n        axes = Axes(x_range=[0, 2, 0.5], y_range=[-1.5, 1.5, 0.5])\n        graph = axes.plot(lambda x: np.sin(math.pi * x), color=BLUE)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Explanation of applying Fourier series to square wave\n        explanation2 = Text(\"Applying series to square wave\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the graph and explanation\n        self.play(FadeOut(graph), FadeOut(graph_label), FadeOut(axes), FadeOut(explanation1))\n        self.wait(1)\n\n        # Conclude with the specific series\n        self.play(Write(specific_series))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialGraphScene(Scene):\n    def construct(self):\n        # Writing the title of the graph\n        title = Text(\"Exponential Function Graph\").shift(UP*3)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-1, 8],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create the function and its graph\n        exponential_function = lambda x: np.exp(x)\n        graph = axes.plot(exponential_function, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        # Display the axes and the graph\n        self.play(Create(axes), Write(graph_label))\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Introduction to a new function\n        explanation1 = Text(\"Consider function 2^x\", font_size=24).to_edge(UP)\n        self.play(Transform(title, explanation1))\n        self.wait(2)\n\n        # New function and its graph\n        new_function = lambda x: 2**x\n        new_graph = axes.plot(new_function, color=RED)\n        new_label = axes.get_graph_label(new_graph, label='2^x', x_val=1, direction=UP*2)\n\n        # Display the new_function graph\n        self.play(ReplacementTransform(graph, new_graph), ReplacementTransform(graph_label, new_label))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion by showing the comparison\n        self.play(Create(axes), Write(new_label), Create(new_graph))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CubicPolynomialExample(Scene):\n    def construct(self):\n        # Displaying the cubic polynomial\n        polynomial = MathTex(r\"x^3 - 3x^2 + 3x - 1 = 0\")\n        self.play(Write(polynomial))\n        self.wait(1)\n\n        # Explanation for factoring the polynomial\n        explanation1 = Text(\"Factor the polynomial\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Factoring step\n        factored = MathTex(r\"(x - 1)^3 = 0\")\n        self.play(ReplacementTransform(polynomial.copy(), factored))\n        self.wait(1)\n\n        # Explanation for finding roots\n        explanation2 = Text(\"Find the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing the roots\n        roots = MathTex(r\"x = 1\")\n        self.play(ReplacementTransform(factored, roots))\n        self.wait(1)\n\n        # Graphical representation\n        explanation3 = Text(\"Graphical representation\", font_size=24).to_edge(UP)\n        axes = Axes(\n            x_range=[-1, 3],\n            y_range=[-1, 3],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: (x - 1)**3, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='f(x)=(x-1)^3')\n\n        self.play(Transform(explanation1, explanation3))\n        self.play(Create(axes), Write(graph), Write(graph_label))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the demonstration\", font_size=24)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquation(Scene):\n    def construct(self):\n        # Display the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for wave equation\n        explanation1 = Text(\"This is the standard wave equation for a field u.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display speed of propagation\n        speed = MathTex(r\"c\", r\" = \\text{speed of wave propagation}\").next_to(equation, DOWN)\n        self.play(Write(speed))\n        self.wait(2)\n\n        # Explain solution form\n        explanation2 = Text(\"Solutions typically involve sinusoidal functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying a particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(2)\n\n        # Explanation for a particular solution\n        explanation3 = Text(\"Where A is amplitude, k is wavenumber, and \u03c9 is angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of demonstration!\", font_size=24).to_edge(UP)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the area under the curve y=x^2 within the interval [0,3]\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 3], color=YELLOW)\n        area = area = Integral(curve, (x, 0, 3), fill_opacity=0.3, fill_color=BLUE)\n\n        # Display the curve\n        curve_label = MathTex(\"y = x^2\").next_to(curve, UP)\n        self.play(Create(curve), Write(curve_label))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(Create(area))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^3 x^2 \\,dx\")\n        problem.to_edge(UP + LEFT)   # Positioning the problem statement\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of integration\n        explanation1 = Text(\"The area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration result before evaluation\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Evaluate at the bounds\n        explanation2 = Text(\"Evaluate at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_solution = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(0)^3\", r\"= 9\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        conclusion = Text(\"The definite integral represents the area under the curve.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Presenting the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n        \n        # Display the meaning\n        meaning = Text(\"Harmonic Oscillator Equation\", font_size=24).to_edge(UP)\n        self.play(Write(meaning))\n        self.wait(2)\n        \n        # Forming the characteristic equation from the given differential equation\n        char_eq_text = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, char_eq_text))\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(ReplacementTransform(diff_eq.copy(), char_eq))\n        self.wait(1)\n        \n        # Solving the characteristic equation\n        solve_char_eq = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, solve_char_eq))\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n        \n        # General solution for the motion\n        gen_sol_text = Text(\"General Harmonic Motion Solution\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, gen_sol_text))\n        general_solution = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Clear scene and show the final solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass CubicFunctionGraph(Scene):\n    def construct(self):\n        # Display the cubic function\n        cubic_eq = MathTex(r\"f(x) = x^3 - 3x^2 + x\")\n        self.play(Write(cubic_eq))\n        self.wait(1)\n\n        # Draw the graph of the cubic function\n        graph = self.get_graph(lambda x: x**3 - 3*x**2 + x, color=BLUE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Label the graph\n        graph_label = Tex(\"Graph of $f(x)$\").next_to(graph, UP)\n        self.play(Write(graph_label))\n        self.wait(1)\n\n        # Discuss critical points\n        explanation = Text(\"Critical points where $f'(x)=0$\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Derivative of cubic function\n        derivative = MathTex(r\"f'(x) = 3x^2 - 6x + 1\")\n        self.play(Transform(cubic_eq, derivative))\n        self.wait(1)\n\n        # Mark critical points on graph\n        critical_points = VGroup(\n            Dot().move_to(self.coords_to_point(1, -2)),\n            Dot().move_to(self.coords_to_point(2, 2))\n        )\n        self.play(Create(critical_points))\n        self.wait(1)\n\n        # Function for cubic equation's derivative\n        def cubic_derivative(x):\n            return 3*x**2 - 6*x + 1\n\n        # Graph the derivative\n        derivative_graph = self.get_graph(cubic_derivative, x_min=-1, x_max=3, color=RED)\n        self.play(Create(derivative_graph))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        conclusion = Text(\"Visualizing a Cubic Function and its Derivative\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n    # Utility function to get a graph from a function\n    def get_graph(self, function, **kwargs):\n        return FunctionGraph(function, **kwargs)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        func = lambda x: 0.1 * (x - 3)**2 + 1\n        area = [1, 5]\n\n        # Displaying the function graph\n        graph = FunctionGraph(func, x_range=[0, 6])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Displaying the area under the curve\n        shaded_area = area_under_curve = self.get_area(graph, x_range=area)\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n\n        # Showing the bounds of the integral\n        bounds = MathTex(r\"a = 1, b = 5\")\n        self.play(Write(bounds))\n        self.wait(1)\n\n        # Showing the integral expression\n        integral_expr = MathTex(r\"\\int_{a}^{b} f(x) \\,dx\")\n        self.play(Transform(bounds, integral_expr))\n        self.wait(2)\n\n        # Calculate the value\n        result = MathTex(r\"\\approx 10.67\")\n        self.play(ReplacementTransform(integral_expr, result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)\n        \n    # Function to get area under curve between two x values\n    def get_area(self, graph, x_range):\n        return self.camera.background_plane.get_riemann_rectangles(\n            graph, x_range=x_range, dx=0.1, stroke_width=0.1\n        )"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of the wave equation\n        description = Text(\"This equation describes wave propagation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(description, shift=UP))\n        self.wait(2)\n\n        # Introduce a specific solution\n        solution_text = Text(\"A particular solution is the sine wave function\", font_size=24).to_edge(UP)\n        self.play(Transform(description, solution_text))\n        self.wait(2)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Discuss the parameters of the sine wave solution\n        params_text = Text(\"Here, A is the amplitude, k is the wavenumber, \\omega is the frequency, and \\phi is the phase offset.\", font_size=20, line_spacing=1.5).to_edge(UP)\n        self.play(Transform(description, params_text))\n        self.wait(2)\n\n        # Clearing the screen\n        self.play(FadeOut(description), FadeOut(specific_solution))\n        self.wait(1)\n\n        # Conclude by writing a simplified version of the sine wave without a phase offset\n        simple_wave = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Write(simple_wave))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_1^3\", r\"x^3\", r\"\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Use the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule_definite = MathTex(r\"\\int_a^b\", r\"x^n \\,dx\", r\"=\", r\"\\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule_definite))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"=\", r\"\\left[\\frac{x^{3+1}}{3+1}\\right]_1^3\")\n        self.play(ReplacementTransform(problem[1].copy(), solution1[1]))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution step 1\n        final_solution_step1 = MathTex(r\"=\", r\"\\left[\\frac{x^4}{4}\\right]_1^3\")\n        self.play(ReplacementTransform(solution1, final_solution_step1))\n        self.wait(1)\n\n        # Final solution step 2\n        final_solution_step2 = MathTex(r\"=\", r\"\\frac{3^4}{4}\", r\"-\", r\"\\frac{1^4}{4}\")\n        self.play(ReplacementTransform(final_solution_step1, final_solution_step2))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\", r\"\\frac{80}{4}\")\n        self.play(ReplacementTransform(final_solution_step2, final_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= 20\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExampleSurfaceIntegral(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Use the parametrization of the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        surface_param = MathTex(r\"S(r, \\theta) = \\left< r\\cos\\theta, r\\sin\\theta, z(r,\\theta) \\right>\", r\"\\\\ 0 \\leq r \\leq 1\", r\",\\ 0 \\leq \\theta \\leq 2\\pi\")\n        self.play(Write(surface_param))\n        self.wait(2)\n\n        explanation2 = Text(\"Convert to polar coordinates\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        polar_conversion = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS = \\int_0^{2\\pi} \\int_0^1 r^2 \\cdot r \\, dr \\, d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_conversion))\n        self.wait(1)\n\n        explanation3 = Text(\"Evaluate the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        integral_solution = MathTex(r\"= \\int_0^{2\\pi} \\left[ \\frac{r^4}{4} \\right]_{0}^{1} \\, d\\theta = \\frac{1}{4} \\int_0^{2\\pi} d\\theta = \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(polar_conversion, integral_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n\n        final_solution = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS = \\frac{\\pi}{2}\")\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass LinearTransformationSceneExample(Scene):\n    def construct(self):\n        # Define the matrices\n        matrix_A = [[2, 1], [1, 3]]\n        matrix_tex_A = MathTex(r\"\\begin{bmatrix} 2 & 1 \\\\ 1 & 3 \\end{bmatrix}\")\n\n        # Display the matrix A\n        self.play(Write(matrix_tex_A))\n        self.wait(1)\n        \n        # Explain what we will show\n        explanation = Text(\"Visualize a linear transformation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Create a grid and vector\n        grid = NumberPlane()\n        vector = Arrow(start=grid.c2p(0, 0), end=grid.c2p(1, 2), buff=0, color=YELLOW)\n        vector_label = MathTex(\"v\", color=YELLOW).next_to(vector.get_end(), RIGHT)\n        \n        # Display grid and vector\n        self.play(Create(grid), run_time=3)\n        self.play(GrowArrow(vector), Write(vector_label))\n        self.wait(2)\n\n        # Apply linear transformation\n        transformation = grid.apply_matrix(matrix_A)\n        transformed_vector = vector.copy().apply_matrix(matrix_A)\n        transformed_vector_label = MathTex(\"Av\", color=YELLOW).next_to(transformed_vector.get_end(), RIGHT)\n        \n        self.play(transformation, run_time=3)\n        self.play(Transform(vector, transformed_vector), Transform(vector_label, transformed_vector_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with showing the matrix again\n        self.play(Write(matrix_tex_A))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 3, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 2))\n\n        curve_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(curve_label))\n        self.wait(1)\n\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        problem.next_to(area, UP)\n\n        self.play(Write(problem))\n        self.wait(1)\n\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_0^2\")\n        integration_step.next_to(problem, DOWN)\n\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{1}{3} (2^3) - \\frac{1}{3} (0^3)\", r\"= \\frac{8}{3}\")\n        final_solution.next_to(integration_step, DOWN)\n\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        self.play(FadeOut(area), FadeOut(curve_label), FadeOut(axes), FadeOut(graph))\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric integration\n        explanation1 = Text(\"Integrate using trigonometric identities\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 8],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Define the function and get its graph\n        f = lambda x: x**2\n        graph = axes.plot(f, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        # Mark the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        \n        # Display everything\n        self.play(Create(axes), Write(graph_label))\n        self.wait(1)\n        self.play(Create(graph))\n        self.wait(1)\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\left[\\frac{1}{2}xyz^2\\right]_{0}^{3} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{9}{2}xy^2\\right]_{0}^{2} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{9}{2}x^2\\right]_{0}^{1}\", r\"= \\frac{9}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the integration rule\n        explanation1 = Text(\"Apply the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power rule for integration\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\bigg|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Simplifying the integrated function\n        explanation2 = Text(\"Now, simplify and evaluate the limits:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the integral at the bounds\n        evaluated_at_bounds = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integration_step, evaluated_at_bounds))\n        self.wait(1)\n\n        # Calculating the result\n        final_result = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluated_at_bounds, final_result))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Concluding with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define lower and upper bounds\n        a = 1\n        b = 2\n\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{\", str(a), r\"}^{\", str(b), r\"} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration with bounds:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{\", str(a), \"}^{\", str(b), \"}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the expression at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"= \\frac{\", str(b), r\"^3}{3} - \\frac{\", str(a), r\"^3}{3}\")\n        self.play(ReplacementTransform(integration_step, calc_step))\n        self.wait(2)\n\n        # Final solution with numerical values\n        final_solution_numeric = MathTex(r\"= \\frac{8}{3} - \\frac{1}{3}\")\n        self.play(Transform(calc_step, final_solution_numeric))\n        self.wait(1)\n\n        # Reduce to the simplest form\n        final_solution_simple = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(final_solution_numeric, final_solution_simple))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution_simple))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using exponential rule\n        explanation1 = Text(\"Use the exponential rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Conclusion with the final solution\n        self.play(FadeOut(explanation1))\n        final_solution = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(Transform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and show only the final solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass InfiniteGeometricSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation1 = Text(\"Use formula for sum of infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1 - r}\", r\",\\ |r| < 1\")\n        self.play(ReplacementTransform(series, sum_formula))\n        self.wait(1)\n\n        # Explanation for a specific example\n        explanation2 = Text(\"Example with a=1, r=1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific example calculation\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(sum_formula, example_calculation))\n        self.wait(1)\n\n        # Clear screen and conclude with the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(example_calculation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-x^2}} xy\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Inner integral explanation\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}xy^2\\right]_{0}^{\\sqrt{1-x^2}} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Substitute limits for inner integral\n        substitute_limits = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}x(1-x^2) dx\")\n        self.play(ReplacementTransform(inner_integral, substitute_limits))\n        self.wait(1)\n\n        # Outer integral explanation\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{2} \\cdot \\frac{1}{2}x^2 - \\frac{1}{2} \\cdot \\frac{1}{4}x^4 \\right]_{0}^{1}\")\n        self.play(ReplacementTransform(substitute_limits, final_solution))\n        self.wait(1)\n\n        # Final evaluation\n        final_evaluation = MathTex(r\"= \\frac{1}{4} - \\frac{1}{8}\")\n        self.play(ReplacementTransform(final_solution, final_evaluation))\n        self.wait(1)\n\n        # Final result\n        result = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(final_evaluation, result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # The graph\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Area under graph\n        area = axes.get_area(graph, x_range=[0, 2], color=GREEN, opacity=0.5)\n\n        # Display graph and area\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Display the problem\n        problem = MathTex(r\"\\text{Area} = \\int_0^2 x^2 \\,dx\")\n        problem.next_to(area, DOWN)\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2 = \\frac{8}{3}\")\n        solution.next_to(problem, DOWN)\n        self.play(ReplacementTransform(problem, solution))\n        self.wait(2)\n\n        # Cleanup\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the series convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the p-test\n        p_test = MathTex(r\"p=2\", r\"> 1\").next_to(series, DOWN)\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Explanation for the convergence of the series\n        explanation2 = Text(\"Since p > 1, the series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Conclusion about the series convergence\n        conclusion = MathTex(r\"\\text{The series converges}\")\n        self.play(ReplacementTransform(series, conclusion))\n        self.wait(1)\n\n        # Clear the scene and write conclusion text\n        self.clear()\n        self.wait(1)\n        conclusion_text = Text(\"The p-test confirms the series convergence\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion_text))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2} \\rho^3 \\sin\\varphi d\\rho d\\varphi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{\\rho^4}{4}]_{0}^{2} \\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify the inner integral\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} 4\\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [-4\\cos\\varphi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -4(\\cos(\\pi) - \\cos(0))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= -4(-1 - 1)\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(simplified_solution, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve_label = MathTex(r\"f(x) = 3 - \\frac{1}{2}x^2\", font_size=24)\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        curve_graph = FunctionGraph(\n            lambda x: 3 - 0.5 * x**2,\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        self.play(Create(curve_graph))\n        self.wait(1)\n\n        area_label = Text(\"Area from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Transform(curve_label, area_label))\n        self.wait(1)\n\n        shaded_area = area = Integral(curve_graph, (1, 2))\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n\n        area_value = MathTex(r\"Area = \\int_1^2 (3 - \\frac{1}{2}x^2) \\,dx\", font_size=24)\n        self.play(ReplacementTransform(area_label, area_value))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= \\left[ 3x - \\frac{1}{6}x^3 \\right]_1^2 = \\frac{7}{3}\", font_size=24)\n        self.play(ReplacementTransform(area_value, final_answer))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the type of PDE\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The solution is typically a function of both space and time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the d'Alembert Solution\n        dalembert_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Explanation for the nature of solutions\n        explanation3 = Text(\"Solutions consist of two arbitrary functions, representing waves travelling in opposite directions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Conclusion with the graphical representation mention\n        conclusion = Text(\"Graphical representations can show wave propagation.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(Write(dalembert_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(\n            lambda x: 0.1 * x**2 - 1,\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        area = area = Integral(curve, (x, -3, 3))\n\n        equation = MathTex(r\"\\int_{-3}^{3} 0.1x^2 - 1 \\, dx\")\n        equation.to_edge(UP)\n\n        self.play(Write(equation))\n        self.wait(1)\n\n        self.play(ShowCreation(curve))\n        self.wait(1)\n\n        self.play(Write(area))\n        self.wait(2)\n\n        solution = MathTex(r\"= \\left[\\frac{0.1}{3}x^3 - x\\right]_{-3}^{3}\")\n        solution.next_to(equation, DOWN)\n\n        self.play(ReplacementTransform(equation.copy(), solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\left(\\frac{0.1}{3} \\cdot 3^3 - 3 \\right)\")\n        final_answer.add_updater(lambda m: m.next_to(solution, DOWN))\n\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        final_evaluation = MathTex(r\"= 0\")\n        final_evaluation.add_updater(lambda m: m.next_to(final_answer, DOWN))\n\n        self.play(ReplacementTransform(final_answer, final_evaluation))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Defining the function and its graph\n        f = lambda x: x**2\n        function_graph = axes.plot(f, color=GREEN)\n        label = axes.get_graph_label(function_graph, label='x^2')\n\n        # Setting up the area to find the definite integral\n        area = axes.get_area(function_graph, x_range=(0,2), color=GREY, opacity=0.5)\n        \n        # Title for the graph\n        title = Title(\"Area under the curve y = x^2 from 0 to 2\")\n\n        # Animation sequence\n        # Add axes and the function graph\n        self.play(Create(axes), Write(function_graph), Write(label))\n        self.wait(1)\n        \n        # Add title\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Shade the area under the curve to represent the integral\n        self.play(Write(area))\n        self.wait(2)\n        \n        # Add area calculation\n        area_calculation = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(area_calculation.to_corner(UL)))\n        self.wait(1)\n\n        # Show final value after calculating the integral\n        integral_value = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^2\", r\"=\\frac{2^3}{3} - \\frac{0^3}{3}\", r\"=\\frac{8}{3}\")\n        self.play(Write(integral_value.next_to(area_calculation, DOWN)))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integral_value.to_edge(UP)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExampleTransformation(Scene):\n    def construct(self):\n        # Create text objects\n        text1 = Text(\"Euler's Formula:\")\n        text2 = MathTex(\"e^{ix} = \\\\cos(x) + i\\\\sin(x)\")\n\n        # Position second text\n        text2.next_to(text1, DOWN)\n\n        # Display texts\n        self.play(Write(text1))\n        self.play(FadeInFrom(text2, UP))\n        self.wait(2)\n\n        # Add an arrow\n        arrow = Arrow(LEFT, RIGHT)\n        arrow.next_to(text2, DOWN)\n\n        # Add the expanded form of Euler's formula\n        expanded = MathTex(\"\\\\cos(x) = \\\\frac{e^{ix} + e^{-ix}}{2}\")\n        expanded.next_to(arrow, DOWN)\n        \n        # Show the expansion\n        self.play(GrowArrow(arrow))\n        self.play(Write(expanded))\n        self.wait(2)\n\n        # Show the full transformation\n        complete_expansion = VGroup(text1, text2, arrow, expanded)\n        transformation_title = Text(\"Euler's Formula Transformation\", color=YELLOW)\n        transformation_title.to_edge(UP)\n\n        self.play(\n            FadeOut(complete_expansion),\n            Write(transformation_title),\n            run_time=2\n        )\n        self.wait(2)\n\n        # Conclude with Euler's identity\n        identity_title = Text(\"Euler's Identity\", font_size=36)\n        identity = MathTex(\"e^{i\\\\pi} + 1 = 0\")\n\n        self.play(\n            ReplacementTransform(transformation_title, identity_title),\n        )\n        self.wait(1)\n\n        self.play(Write(identity))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and its graph\n        f = lambda x: 0.1 * x ** 2\n        graph = FunctionGraph(f, x_range=[0, 10])\n        area = graph.get_area(x_range=[2, 8], color=BLUE, opacity=0.5)\n\n        # Display function and area under curve\n        self.play(Create(graph), run_time=2)\n        self.play(FadeIn(area, scale=0.3), run_time=2)\n        self.wait(1)\n\n        # Show area calculation\n        problem = MathTex(r\"\\int_2^8 0.1x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"Area between 2 and 8\", font_size=24).next_to(area, UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculate the area\n        integral_calculation = MathTex(r\"= \\left[\\frac{0.1}{3}x^3\\right]_2^8\")\n        self.play(Transform(problem, integral_calculation))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{0.1}{3}(8^3 - 2^3)\", r\"= \\frac{0.1}{3}(512 - 8)\", r\"= \\frac{0.1}{3}(504)\", r\"= 16.8\")\n        self.play(ReplacementTransform(integral_calculation, final_answer))\n        self.wait(1)\n\n        # Conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DifferentiationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{d}{dx}(x^2 + 2x + 1)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the power rule\n        explanation1 = Text(\"Use the power rule for differentiation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Differentiation step\n        diff_step = MathTex(r\"2x + 2\")\n        self.play(ReplacementTransform(problem.copy(), diff_step))\n        self.wait(1)\n\n        # Explanation that the derivative is constant\n        explanation2 = Text(\"The derivative is a linear function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final derivative\n        final_derivative = MathTex(r\"y' = 2x + 2\")\n        self.play(ReplacementTransform(diff_step, final_derivative))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_derivative))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the power rule for definite integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        integral_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integral_step = MathTex(r\"= \\left[\\frac{x^{3+1}}{3+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluating the integral from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution before evaluation\n        before_evaluation = MathTex(r\"= \\left[\\frac{x^4}{4}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_step, before_evaluation))\n        self.wait(1)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(before_evaluation, evaluation))\n        self.wait(2)\n\n        # Simplified final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final evaluated integral\n        final_result = MathTex(r\"\\int_0^2 x^3 \\,dx = 4\")\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and area to find\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        area_problem = MathTex(r\"\\int_{-1}^{2} (3 - x^2) \\,dx\", color=BLUE)\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Explain the graph\n        graph_explanation = Text(\"This represents the area under the curve \\nfrom x = -1 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(graph_explanation))\n        self.wait(2)\n\n        # Show the graph\n        axes = Axes(x_range=[-3, 3], y_range=[-1, 4])\n        graph = axes.plot(lambda x: 3 - x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=[-1, 2], color=BLUE, opacity=0.3)\n        graph_group = VGroup(axes, graph, area)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Perform the integration\n        integral_result = MathTex(r\"=\\left[3x - \\frac{x^3}{3}\\right]_{-1}^{2}\")\n        integral_value = MathTex(r\"= \\left[6 - \\frac{8}{3}\\right] - \\left[-3 + \\frac{1}{3}\\right]\")\n        solution = MathTex(r\"= \\frac{16}{3} - (-\\frac{8}{3})\")\n        final_solution = MathTex(r\"= \\frac{24}{3} = 8\")\n        \n        self.play(Write(integral_result))\n        self.wait(1)\n        self.play(Transform(integral_result, integral_value))\n        self.wait(1)\n        self.play(Transform(integral_result, solution))\n        self.wait(1)\n        self.play(Transform(integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass LinearAlgebraScene(Scene):\n    def construct(self):\n        # Presenting a matrix\n        matrix = MathTex(r\"\\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n\n        # Showing the determinant\n        determinant_text = Text(\"Determinant of the matrix\", font_size=24).to_edge(UP)\n        self.play(Write(determinant_text))\n        self.wait(2)\n\n        # Writing the determinant formula\n        det_formula = MathTex(r\"\\text{det} = 1 \\cdot 4 - 2 \\cdot 3\")\n        self.play(ReplacementTransform(matrix.copy(), det_formula))\n        self.wait(1)\n\n        # Showing the determinant value\n        det_value = MathTex(r\"\\text{det} = -2\")\n        self.play(Transform(det_formula, det_value))\n        self.wait(2)\n\n        # Introducing eigenvalues\n        eigen_text = Text(\"Eigenvalues of the matrix\", font_size=24).to_edge(UP)\n        self.play(Transform(determinant_text, eigen_text))\n        self.wait(2)\n\n        # Showing the characteristic polynomial\n        char_poly = MathTex(r\"\\lambda^2 - (1+4)\\lambda + (1\\cdot4 - 2\\cdot3) = 0\")\n        self.play(Write(char_poly))\n        self.wait(1)\n\n        # Computing eigenvalues\n        eigenvalues = MathTex(r\"\\lambda = 2, \\lambda = 3\")\n        self.play(ReplacementTransform(char_poly, eigenvalues))\n        self.wait(2)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with eigenvalues highlighted\n        conclusion = Text(\"Eigenvalues are 2 and 3\", font_size=36, color=YELLOW)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate the area under the curve from x=1 to x=3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Plugging in the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Drawing the axes\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Creating the curve f(x) = x^2 and the area under the curve\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0, 2), color=[BLUE, PURPLE], opacity=0.5)\n\n        # Displaying the curve formula and the axes\n        curve_label = MathTex(\"f(x) = x^2\").to_edge(UP)\n        self.play(Write(axes), Write(axes_labels))\n        self.play(Write(curve), Write(curve_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Calculation\n        calculation = MathTex(r\"= \\left[ \\frac{x^3}{3} \\right]_0^2\",\n                              r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\",\n                              r\"= \\frac{8}{3}\").to_edge(DOWN)\n\n        self.play(Write(calculation[0]))\n        self.wait(1)\n        self.play(ReplacementTransform(calculation[0], calculation[1]))\n        self.wait(1)\n        self.play(ReplacementTransform(calculation[1], calculation[2]))\n        self.wait(2)\n\n        # Clear and show final result\n        self.clear()\n        self.play(Write(curve_label), Write(calculation[2]))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GraphingExample(Scene):\n    def construct(self):\n        # Define the functions\n        function1 = MathTex(\"y = x^2\")\n        function2 = MathTex(\"y = 2x + 1\")\n        \n        # Display the functions\n        self.play(Write(function1))\n        self.wait(1)\n        self.play(Transform(function1, function2))\n        self.wait(1)\n        \n        # Clear the description\n        self.remove(function1)\n\n        # Setting the axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 8, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        # Create the graphs\n        graph1 = axes.plot(lambda x: x**2, color=GREEN)\n        graph1_label = axes.get_graph_label(graph1, label='x^2')\n\n        graph2 = axes.plot(lambda x: 2*x + 1, color=RED)\n        graph2_label = axes.get_graph_label(graph2, label='2x+1')\n\n        # Display the graphs\n        self.play(Create(axes), Write(graph1), Write(graph1_label))\n        self.wait(1)\n        self.play(ReplacementTransform(graph1, graph2), ReplacementTransform(graph1_label, graph2_label))\n        self.wait(1)\n\n        # Clear the graphs\n        self.play(FadeOut(graph2), FadeOut(graph2_label), FadeOut(axes))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule and evaluate:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrating using the power rule\n        integration = MathTex(r\"= \\left. \\frac{3x^{2+1}}{2+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration))\n        self.wait(2)\n\n        # Showing integration results\n        integrated = MathTex(r\"= \\frac{3 \\cdot 2^3}{3} - \\frac{3 \\cdot 0^3}{3}\")\n        self.play(ReplacementTransform(integration, integrated))\n        self.wait(2)\n\n        # Simplifying the result\n        solution = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(integrated, solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(explanation1), FadeOut(solution))\n        self.wait(1)\n\n        # Conclude with the final answer\n        final_answer = Text(\"The area under the curve from 0 to 2 is 8.\", font_size=24)\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2} xyz^2 \\Big|_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2} x \\frac{1}{2} y^2 \\Big|_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4} \\frac{1}{3} x^3 \\Big|_{0}^{1}\", r\"= \\frac{1}{12}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem_text = r\"m\\frac{d^2 x}{dt^2} + kx = 0\"\n        problem = MathTex(problem_text)\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Oscillation equation description\n        description1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        self.play(Write(description1))\n        self.wait(2)\n        self.play(FadeOut(description1))\n\n        # Explanation for converting to standard form\n        standard_form_expl = Text(\"Let's convert to standard form, where\", font_size=24).to_edge(UP)\n        omega_sq_text = r\"\\omega^2 = \\frac{k}{m}\"\n        omega_sq = MathTex(omega_sq_text)\n        self.play(Write(standard_form_expl))\n        self.play(Write(omega_sq))\n        self.wait(2)\n\n        # Standard form of equation\n        standard_form_text = r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\"\n        standard_form = MathTex(standard_form_text)\n        self.play(ReplacementTransform(problem, standard_form))\n        self.wait(1)\n\n        # Explanation for general solution\n        general_sol_expl = Text(\"Now, let's find the general solution.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(standard_form_expl, general_sol_expl))\n        self.wait(1)\n\n        # General solution of oscillation equation\n        general_solution_text = r\"x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)\"\n        general_solution = MathTex(general_solution_text)\n        self.play(ReplacementTransform(standard_form, general_solution))\n        self.wait(1)\n\n        # Explanation for full solution\n        full_solution_expl = Text(\"A and B are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(general_sol_expl, full_solution_expl))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fourier Series Demo\").shift(UP*3)\n        self.play(Write(title))\n\n        # Original function\n        original_function_tex = MathTex(r\"f(t) = \\begin{cases} 1 & \\text{for } 0 \\leq t < \\pi, \\\\ -1 & \\text{for } -\\pi \\leq t < 0. \\end{cases}\")\n        self.play(Write(original_function_tex))\n        self.wait(2)\n\n        # Fourier series definition\n        fourier_series_definition = MathTex(r\"f(t) \\approx \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} [a_n \\cos(n t) + b_n \\sin(n t)]\")\n        fourier_series_definition.next_to(original_function_tex, DOWN)\n        self.play(Transform(original_function_tex, fourier_series_definition))\n        self.wait(2)\n\n        # Coefficients for Fourier series\n        coefficients = MathTex(r\"a_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(t) \\cos(n t) \\, dt\", \n                               r\"b_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(t) \\sin(n t) \\, dt\")\n        coefficients.next_to(fourier_series_definition, DOWN)\n        self.play(Write(coefficients))\n        self.wait(2)\n\n        # Visual representation of Fourier series\n        visual_rep = Text(\"Visual Representation of Fourier Series on a Graph\", font_size=24).to_edge(DOWN)\n        self.play(Write(visual_rep))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude\n        conclude_text = Text(\"The Fourier series approximates periodic functions.\", font_size=24).to_edge(UP)\n        self.play(Write(conclude_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r\\, dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[\\frac{1}{2}r^2\\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{2} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculate the result\n        result_text = Text(\"The area inside the unit circle is \", font_size=24).to_edge(UP)\n        result = MathTex(r\"= \\frac{1}{2} \\theta \\Big|_{0}^{2\\pi} = \\pi\")\n        self.play(Transform(explanation1, result_text), Write(result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the sum of a geometric series\n        series_problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for the formula of the sum of a geometric series\n        explanation1 = Text(\"Geometric series converges if |r| < 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the formula for convergence\n        convergence_formula = MathTex(r\"S = \\frac{a}{1 - r}, \\text{ if } |r| < 1\")\n        self.play(ReplacementTransform(series_problem.copy(), convergence_formula))\n        self.wait(2)\n\n        # Example with actual numbers\n        specific_example = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        self.play(Write(specific_example))\n        self.wait(1)\n\n        # Showing the convergence value for the example\n        convergence_value = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(specific_example, convergence_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        final_result = Text(\"The sum converges to 2\", font_size=24)\n        self.play(Write(final_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = 3x^2 + 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explaining the concept of derivative\n        explanation = Text(\"Let's compute the derivative of the function with respect to x.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Computing the derivative\n        derivative = MathTex(r\"f'(x) = 6x + 2\")\n        self.play(Transform(function, derivative))\n        self.wait(2)\n\n        # Showing the slope at a point\n        point_explanation = Text(\"The derivative at x=1 is the slope of the tangent line there\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, point_explanation))\n        self.wait(2)\n\n        # Calculating the derivative at x = 1\n        derivative_at_1 = MathTex(r\"f'(1) = 6(1) + 2 = 8\")\n        self.play(Write(derivative_at_1))\n        self.wait(1)\n\n        # Graphing the function and its tangent line\n        graph = self.get_graph(function)\n        tangent_line = self.get_tangent_line(1, graph, length=4, color=YELLOW)\n        self.play(Create(graph), ShowCreation(tangent_line))\n        self.wait(2)\n\n        # Concluding by showing all steps\n        self.clear()\n        self.play(Write(function), Write(derivative), Write(derivative_at_1))\n        self.play(Create(graph), ShowCreation(tangent_line))\n        self.wait(2)\n\n    def get_graph(self, function_tex):\n        # A method for creating a graph from the given function\n        function = lambda x: 3*x**2 + 2*x + 1\n        graph = FunctionGraph(function, color=WHITE, x_range=[-3,3])\n        return graph\n\n    def get_tangent_line(self, x, graph, dx=0.01, **kwargs):\n        # A method for creating a tangent line given a graph at x\n        x0 = x - dx\n        x1 = x + dx\n        y0 = graph.underlying_function(x0)\n        y1 = graph.underlying_function(x1)\n        line = Line([x0, y0, 0], [x1, y1, 0], **kwargs)\n        return line"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transformation to another form\n        explanation2 = Text(\"For a string with fixed ends, solutions can be sinusoidal.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Multiples of the fundamental frequency give harmonics.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clearing the scene to display harmonics\n        self.play(FadeOut(explanation1), FadeOut(particular_solution))\n        self.wait(1)\n\n        # Displaying first harmonic\n        first_harmonic = MathTex(r\"u_1(x, t) = A \\sin(\\frac{\\pi}{L}x - \\omega_1 t)\")\n        self.play(Write(first_harmonic))\n        self.wait(1)\n\n        # Displaying second harmonic\n        second_harmonic = MathTex(r\"u_2(x, t) = A \\sin(\\frac{2\\pi}{L}x - \\omega_2 t)\")\n        self.play(Transform(first_harmonic, second_harmonic))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The shape of the string at any given time is a standing wave.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SpringMassScene(Scene):\n    def construct(self):\n        # Display the differential equation of motion for a spring-mass system\n        spring_mass_eq = MathTex(r\"m\\ddot{x} + c\\dot{x} + kx = 0\")\n        self.play(Write(spring_mass_eq))\n        self.wait(1)\n\n        # Explanation for the physical system\n        system_explanation = Text(\"Spring-mass-damper system\", font_size=24).to_edge(UP)\n        self.play(Write(system_explanation))\n        self.wait(2)\n\n        # Transform the equation to the standard form\n        standard_form_eq = MathTex(r\"\\ddot{x} + 2\\zeta\\omega_n\\dot{x} + \\omega_n^2x = 0\")\n        self.play(ReplacementTransform(spring_mass_eq, standard_form_eq))\n        self.wait(1)\n\n        # Explanation for standard form equation\n        standard_form_explanation = Text(\"Standard form of the equation\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, standard_form_explanation))\n        self.wait(2)\n\n        # Show the characteristic equation\n        characteristic_eq = MathTex(r\"r^2 + 2\\zeta\\omega_n r + \\omega_n^2 = 0\")\n        self.play(ReplacementTransform(standard_form_eq, characteristic_eq))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        char_eq_explanation = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, char_eq_explanation))\n        self.wait(2)\n\n        # Present the solution based on damping ratio\n        underdamped_solution = MathTex(r\"x(t) = e^{-\\zeta\\omega_n t}(A\\cos(\\omega_d t) + B\\sin(\\omega_d t))\")\n        self.play(Write(underdamped_solution))\n        self.wait(1)\n\n        # Explanation for underdamped solution\n        underdamped_explanation = Text(\"Underdamped solution for $\\\\zeta < 1$\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, underdamped_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion and final state of the system\n        final_state = Text(\"Free vibration of a spring-mass-damper system\", font_size=24)\n        self.play(Write(final_state))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series formula\n        formula = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(formula))\n        self.wait(2)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Visualization of the first three terms\n        first_three_terms = MathTex(r\"f(x) \\approx a_0 + a_1 \\cos(x) + b_1 \\sin(x) + a_2 \\cos(2x) + b_2 \\sin(2x) + a_3 \\cos(3x) + b_3 \\sin(3x)\")\n        self.play(Transform(formula, first_three_terms))\n        self.wait(2)\n\n        # Explanation of Convergence\n        explanation2 = Text(\"As more terms are added, the series converges to f(x)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clearing the explanation and showing the plot\n        self.remove(explanation1)\n        self.play(ShowCreation(formula))\n        self.wait(2)\n        \n        # Plot of a periodic function using Fourier series\n        axes = Axes(\n            x_range=[-PI, PI, PI/2],\n            y_range=[-1.5, 1.5],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.sin(x), color=WHITE)\n        self.play(Write(axes), ShowCreation(graph))\n        self.wait(2)\n\n        # Conclude with the graph\n        self.clear()\n        self.play(ShowCreation(graph))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function_label = MathTex(r\"f(x) = x^2\", font_size=24).to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Show the integral\n        integral = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Integration process\n        integration = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_1^3\")\n        self.play(Transform(integral, integration))\n        self.wait(2)\n\n        # Calculation of definite integral value\n        final_value = MathTex(r\"= \\frac{1}{3}(3^3 - 1^3)\", r\"= \\frac{1}{3}(27 - 1)\", r\"= \\frac{1}{3}(26)\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, final_value))\n        self.wait(3)\n\n        # Display final result\n        self.clear()\n        self.play(Write(final_value))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Demonstrating the power rule with limits\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n        \n        # Performing the integration step with boundaries\n        solution1 = MathTex(r\"= \\left[\\frac{3x^{2+1}}{2+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n        \n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Evaluating the integral at the boundaries\n        solution2 = MathTex(r\"= \\left[\\frac{3x^3}{3}\\right]_0^2\")\n        self.play(Transform(solution1, solution2))\n        self.wait(1)\n        \n        # Plugging in the upper and lower limits\n        solution3 = MathTex(r\"= \\left[ x^3 \\right]_0^2\")\n        self.play(Transform(solution1, solution3))\n        self.wait(1)\n\n        # Calculating the final value\n        final_value = MathTex(r\"= 2^3 - 0^3 = 8 \")\n        self.play(ReplacementTransform(solution3, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final value\n        self.play(Write(final_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function_tex = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explaining the area calculation\n        explanation1 = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the integral\n        integral = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        self.play(Transformation(function_tex, integral))\n        self.wait(1)\n\n        # Integration step\n        integration_result = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^2\")\n        self.play(ReplacementTransform(integral, integration_result))\n        self.wait(2)\n\n        # Evaluate the definite integral\n        evaluate_integral = MathTex(r\"= \\frac{2^3}{3} - \\frac{1^3}{3}\")\n        self.play(Write(evaluate_integral.move_to(integration_result)))\n        self.wait(1)\n\n        # Simplifying the result\n        simplified_result = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(evaluate_integral, simplified_result))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"The area is \\frac{7}{3}\")\n        self.play(Transform(simplified_result, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}x^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Showing the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(2)\n\n        # Displaying solution form\n        solution_form = Text(\"Solutions can be of the form u(x, t) = f(x \\pm ct)\", font_size=24).to_edge(DOWN)\n        self.play(Write(solution_form))\n        self.wait(3)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(2)\n\n        # Explaining the parameters\n        parameters_explanation = Text(\"Here, A is amplitude, k is the wave number, and \u03c9 is the angular frequency\", font_size=24).to_edge(DOWN)\n        self.play(Transform(solution_form, parameters_explanation))\n        self.wait(3)\n\n        # Show boundary conditions\n        boundary_conditions = MathTex(r\"u(0, t) = u(L, t) = 0\")\n        self.play(FadeIn(boundary_conditions), FadeOut(specific_solution), FadeOut(solution_form))\n        self.wait(3)\n\n        # Clear the scene and show a conclusion\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Wave equations model vibrations and waves.\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power of e\n        explanation1 = Text(\"Use the power rule for e\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrate step\n        integrate_step = MathTex(r\"\\frac{1}{2} e^{2x}\")\n        self.play(ReplacementTransform(problem.copy(), integrate_step))\n        self.wait(1)\n\n        # Explanation for adding constant of integration\n        explanation2 = Text(\"Add the constant of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integrate_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(integrate_step), FadeOut(explanation1))\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using substitution\n        explanation1 = Text(\"Use substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        sub_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"\\frac{du}{dx}=2\", r\"\\quad\", r\"dx=\\frac{du}{2}\")\n        self.play(Write(sub_step))\n        self.wait(2)\n\n        # Rewrite integral with substitution\n        integral_sub = MathTex(r\"\\int e^u \\frac{du}{2}\")\n        self.play(ReplacementTransform(problem.copy(), integral_sub))\n        self.wait(2)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integral_sub, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(sub_step), FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n        conclusion = Text(\"Thus, the integral is solved.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r \\, dr \\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now, integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Simplified solution\n        simplified_solution = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the graph\n        ax = Axes(\n            x_range=[0, 2],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n        self.add(ax)\n\n        # Define the function and its graph\n        def func(x):\n            return x**2\n\n        graph = ax.plot(func, color=WHITE)\n        self.play(Create(graph))\n\n        # Display the problem of finding the area under the curve\n        problem_text = MathTex(r\"\\text{Area under } y=x^2 \\text{ from } x = 0 \\text{ to } x = 2\")\n        problem_text.to_edge(UP)\n        self.play(Write(problem_text))\n        self.wait(2)\n\n        # Fill area under curve\n        area = ax.get_riemann_rectangles(graph, x_range=[0, 2], color=BLUE, opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"A = \\int_{0}^{2} x^2 \\,dx\")\n        self.play(Write(calc_step))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(calc_step.copy(), final_solution))\n        self.wait(2)\n\n        # Calculate the definite integral value\n        def_integral_val = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Write(def_integral_val))\n        self.wait(2)\n\n        # Show the numerical result\n        numerical_result = Tex(r\"The area is approximately 2.67 square units\")\n        numerical_result.next_to(def_integral_val, DOWN)\n        self.play(Write(numerical_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Write final answer\n        self.play(Write(Tex(r\"The final area is $\\frac{8}{3}$ square units\")))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(2)\n\n        # Show area visualization\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(1, 3), color=[BLUE, GREEN], opacity=0.3)\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(3)\n\n        # Integration process\n        integration = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(area_problem, integration))\n        self.wait(2)\n\n        # Calculating result\n        result = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, result))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text('The shaded area is \\\\( \\\\frac{26}{3} \\\\) square units.', font_size=24)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), Transform(result, conclusion))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3} r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} \\sin(\\theta) - \\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(2)\n\n        # Display final evaluated solution\n        evaluated_solution = MathTex(r\"= \\frac{1}{3} - (-\\frac{1}{3}) = \\frac{2}{3}\")\n        self.play(Write(evaluated_solution))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CircleAreaScene(Scene):\n    def construct(self):\n        # Write the equation of the circle area\n        equation = MathTex(\"A = \\pi r^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the elements of the equation\n        explanation = Text(\"Area of a circle with radius r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the radius squared term\n        square_term = equation[2:5]\n        self.play(Indicate(square_term))\n        self.wait(1)\n\n        # Show a circle with its radius\n        circle = Circle(color=BLUE)\n        radius = Line(ORIGIN, RIGHT, color=GREEN).shift(DOWN)\n        radius_label = MathTex(\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromPoint(radius, ORIGIN), Write(radius_label))\n        self.wait(2)\n\n        # Calculate the area for r=1\n        area_calculation = MathTex(r\"A = \\pi \\cdot 1^2 = \\pi\")\n        self.play(Transform(equation, area_calculation))\n        self.wait(1)\n\n        # Show that for r=1, the area of the circle is \u03c0\n        circle_area_highlight = Circle(color=YELLOW).scale(np.sqrt(np.pi))\n        self.play(Transform(circle, circle_area_highlight), FadeOut(radius), FadeOut(radius_label))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_calculation))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral\n        integral = MathTex(r\"\\int_0^3 x^2 \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Setting up the visualization of the area under the curve\n        axes = Axes(\n            x_range=[0, 4], y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0,3), color=GREY, opacity=0.5)\n\n        # Show the axes and graph with shaded area\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(1)\n\n        # Calculation step\n        calculation = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^3\")\n        self.play(ReplacementTransform(integral.copy(), calculation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} (3)^3 - 0\")\n        self.play(Transform(calculation, final_solution))\n        self.wait(1)\n\n        # Conclusion, show the area equals final integral value\n        conclusion_text = Text(\"Area under the curve is equal to the integral value\", font_size=24).to_edge(UP)\n        final_value = MathTex(r\"= 9\").next_to(conclusion_text, DOWN)\n        self.play(Write(conclusion_text), ReplacementTransform(final_solution.copy(), final_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        func = lambda x: x**2\n        area_start = 0\n        area_end = 2\n\n        # Display the function\n        function_graph = FunctionGraph(func, x_min=area_start, x_max=area_end)\n        self.play(Create(function_graph))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = area = Integral(function_graph, (area_start, area_end))\n        self.play(Write(area))\n        self.wait(2)\n\n        # Display the integral form\n        integral_text = MathTex(r\"\\int_{0}^{2} x^2 \\,dx\")\n        integral_text.next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Show the solution step-by-step\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(Transform(integral_text, solution))\n        self.wait(2)\n\n        solution_final = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_final))\n        self.wait(2)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_final))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_1^3 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Showing the general solution\n        general_solution = MathTex(r\"= \\left[ \\frac{3x^{2+1}}{2+1} \\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), general_solution))\n        self.wait(2)\n        \n        # Evaluation step 1\n        evaluation1 = MathTex(r\"= \\left[ x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(general_solution, evaluation1))\n        self.wait(2)\n        \n        # Evaluation from the upper bound to the lower bound\n        evaluation2 = MathTex(r\"= 3^3 - 1^3\")\n        self.play(ReplacementTransform(evaluation1, evaluation2))\n        self.wait(1)\n\n        # Final value after calculation\n        final_value = MathTex(r\"= 27 - 1 = 26\")\n        self.play(ReplacementTransform(evaluation2, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        self.play(Write(final_value))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function to integrate\n        problem = MathTex(r\"\\int_1^3 \\sqrt{x}\\,dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Set up the axes\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Plot the function\n        graph = axes.plot(lambda x: np.sqrt(x), color=WHITE)\n        labels = axes.get_axis_labels()\n\n        # Highlight area under curve\n        area = axes.get_area(graph, x_range=(1, 3), color=[BLUE, GREEN], opacity=0.3)\n\n        # Display graph\n        self.play(Create(axes), Create(labels))\n        self.play(Write(graph))\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        # Integral solution setup\n        solution_setup = MathTex(r\"=[\\frac{2}{3}x^{3/2}]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution_setup))\n        self.wait(2)\n\n        # Calculate final answer\n        final_answer = MathTex(r\"=\\frac{2}{3}(3^{3/2}) - \\frac{2}{3}(1^{3/2})\", \"=\", \"2\\sqrt{3}-\\frac{2}{3}\")\n        self.play(ReplacementTransform(solution_setup, final_answer))\n        self.wait(2)\n\n        # Clear the scene for the final answer\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Introduction text for first integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Solving the innermost integral with respect to z\n        integral_z = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [frac{1}{2}x y z^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integral_z))\n        self.wait(1)\n\n        # Introduction text for second integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the middle integral with respect to y\n        integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} x (y^2 z^2)]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(integral_z, integral_y))\n        self.wait(1)\n\n        # Introduction text for third integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solving the outermost integral with respect to x and showing the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (y^2 x^3 z^2)]_{0}^{1}\", r\"= \\frac{1}{3} (1)^2 (1)^3 (2)^2\", r\"= \\frac{4}{3}\")\n        self.play(ReplacementTransform(integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and present the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculation of the final integral\n        result = MathTex(r\"= [-\\frac{1}{3}\\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, result))\n        self.wait(1)\n\n        # Final answer\n        answer = MathTex(r\"= -\\frac{1}{3}(\\cos(\\pi) - cos(0))\")\n        self.play(ReplacementTransform(result, answer))\n        self.wait(1)\n\n        # Simplified answer\n        final_answer = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(answer, final_answer))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Displaying the Pythagorean theorem\n        theorem = MathTex('a^2 + b^2 = c^2')\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Draw right triangle\n        right_triangle = RightAngleTriangle()\n        self.play(Create(right_triangle))\n        self.wait(1)\n\n        # Explaining the square on the hypotenuse\n        explanation1 = Text(\"Consider squares on each side\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Creating squares on each side of the triangle\n        square_a = Square().scale(0.5).next_to(right_triangle, UP, buff=0)\n        square_b = Square().scale(0.5).next_to(right_triangle, RIGHT, buff=0)\n        square_c = Square().scale(0.7).next_to(right_triangle.hypotenuse, RIGHT, buff=0)\n        self.play(Create(square_a), Create(square_b), Create(square_c))\n        self.wait(2)\n\n        # Explaining Pythagorean theorem in this context\n        explanation2 = Text(\"Area of c^2 is equal to sum of a^2 and b^2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # The conclusion\n        conclusion = MathTex('a^2', '+', 'b^2', '=', 'c^2').move_to(DOWN * 3)\n        self.play(ReplacementTransform(theorem.copy(), conclusion))\n        self.wait(1)\n\n        # Clear the scene and show the conclusion again\n        self.clear()\n        self.wait(1)\n        conclusion_final = MathTex('a^2 + b^2 = c^2').move_to(DOWN * 3)\n        self.play(Write(conclusion_final))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2}y z \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4} z \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the equation of the ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Display the process of solving the ODE\n        solve_ode = Text(\"Solve the differential equation\", font_size=24).to_edge(UP)\n        self.play(Write(solve_ode))\n        self.wait(2)\n\n        # Display the integrating factor\n        int_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.wait(1)\n\n        # Replace the Text with the next step\n        method_step = Text(\"Use the integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, method_step))\n        self.wait(2)\n\n        # Multiply through by integrating factor and solve\n        solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(int_factor, solution))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"y(x) = Ce^{3x}\")\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explain the general solution\n        explanation = Text(\"General solution of the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Highlight general solution for the ODE\n        self.play(Write(general_solution.scale(1.5)))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesVisual(Scene):\n    def construct(self):\n        # Introduction to Fourier Series\n        title = Text(\"Fourier Series Representation\", font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.wait()\n\n        # Example of a square wave\n        square_wave_text = Text(\"Square Wave\", font_size=28).to_edge(UP).shift(DOWN)\n        square_wave = Square(color=BLUE).scale(2)\n        self.play(Write(square_wave_text))\n        self.wait(0.5)\n        self.play(ShowCreation(square_wave))\n        self.wait()\n\n        # Display Fourier Series Equation\n        fourier_series_text = MathTex(\n            \"f(x) = a_0 + \\sum_{n=1}^\\infty (a_n \\cos(nx) + b_n \\sin(nx))\"\n        ).next_to(square_wave, DOWN)\n        self.play(ReplacementTransform(square_wave_text, fourier_series_text))\n        self.wait(2)\n\n        # Explanation for Fourier Analysis\n        explanation_fourier = Text(\"Fourier analysis breaks down\",\n                                   \"periodic functions into a sum of sine and cosine functions.\",\n                                   font_size=24).next_to(fourier_series_text, DOWN)\n        self.play(FadeIn(explanation_fourier, UP))\n        self.wait(2)\n\n        # Clear the scene for partial sum\n        self.clear()\n        self.wait()\n\n        # Fourier Series Partial Sum Equation\n        partial_sum_title = Text(\"Fourier Series Partial Sum\", font_size=36).to_edge(UP)\n        partial_sum_eq = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(partial_sum_title))\n        self.wait()\n        self.play(Write(partial_sum_eq))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"As N approaches infinity,\", \n                          \"the partial sum converges to the function\", font_size=24).next_to(partial_sum_eq, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene at the end\n        self.play(FadeOut(partial_sum_title), FadeOut(partial_sum_eq), FadeOut(conclusion))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Function to graph\n        curve = lambda x: 0.1 * (x - 3) ** 2\n\n        # Displaying the function\n        graph = FunctionGraph(curve, x_range=[0, 5])\n        graph_label = MathTex(\"f(x) = 0.1(x - 3)^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = area = self.get_area(graph, [1, 4])\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem to solve\n        problem = MathTex(r\"\\int_1^4 0.1(x - 3)^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the definite integral\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Evaluation of integral\n        evaluation = MathTex(r\"= [\\frac{0.1}{3}(x - 3)^3]_1^4\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\frac{0.1}{3}(4 - 3)^3 - \\frac{0.1}{3}(1 - 3)^3\", r\"= \\frac{0.1}{3}\")\n        self.play(ReplacementTransform(evaluation, solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Equation of heat conduction\n        heat_eq = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(heat_eq))\n        self.wait(1)\n\n        # Explanation of heat equation\n        explanation1 = Text(\"This is the one-dimensional heat equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Steady-state solution\n        explanation2 = Text(\"In steady state, the solution does not change over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Heat steady-state equation\n        steady_state_eq = MathTex(r\"\\frac{d^2 u}{dx^2} = 0\")\n        self.play(ReplacementTransform(heat_eq, steady_state_eq))\n        self.wait(1)\n\n        # Explanation of boundary conditions\n        explanation3 = Text(\"Boundary conditions are needed for a specific solution.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Concluding the example\n        self.play(FadeOut(explanation1), FadeOut(steady_state_eq))\n        self.wait(1)\n\n        # Restating the heat equation\n        self.play(Write(heat_eq))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Convergence condition\n        condition = MathTex(r\"p > 1\")\n        self.play(ReplacementTransform(series_problem.copy(), condition))\n        self.wait(1)\n\n        # Applying the p-test\n        p_test_application = MathTex(r\"\\text{Since } p = 2 > 1, \\text{ the series converges.}\")\n        self.play(ReplacementTransform(condition, p_test_application))\n        self.wait(1)\n\n        # Explanation for p-test result\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Closing conclusion\n        final_conclusion = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ is convergent}\")\n        self.play(ReplacementTransform(p_test_application, final_conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\pi \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the definite integral\n        explanation1 = Text(\"Evaluate the definite integral of sine from 0 to \u03c0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\pi\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for the antiderivative of sine\n        explanation2 = Text(\"Antiderivative of sine is -cosine\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the antiderivative at bounds\n        evaluation_step = MathTex(r\"= -\\cos(\\pi) - (-\\cos(0))\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the bounds\n        explanation3 = Text(\"Evaluate -cosine at \u03c0 and 0\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"=\\left. \\frac{x^{3+1}}{3+1} \\right|_0^1\")\n        self.play(Transform(problem, integration_step))\n        self.wait(2)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate at bounds\n        evaluate_at_bounds = MathTex(r\"=\\left. \\frac{x^4}{4} \\right|_0^1 = \\frac{1^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(problem, evaluate_at_bounds))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}\")\n        self.play(Transform(problem, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution on screen\n        self.play(FadeIn(final_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\int_{0}^{1} \\rho^2 \\sin(\\phi) d\\rho\\,d\\phi\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\left[ \\frac{1}{3}\\rho^3 \\sin(\\phi) \\right]_{0}^{1} d\\phi\\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\phi) d\\phi\\,d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ -\\frac{1}{3} \\cos(\\phi) \\right]_{0}^{\\pi/2} d\\theta\")\n        self.play(ReplacementTransform(middle_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ -\\frac{1}{3} \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Display the solution\n        solution_text = Text(\"The solution is -pi/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Computing the definite integral\n        computed_solution = MathTex(r\"= [\\frac{1}{3} (-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, computed_solution))\n        self.wait(1)\n\n        # Result of the computation\n        result = MathTex(r\"= \\frac{1}{3} (1 - (-1)) = \\frac{2}{3}\")\n        self.play(Write(result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Defining the integral problem\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Displaying the integration bounds\n        bounds = Text(\"From x=2 to x=3\", font_size=24).to_edge(UP)\n        self.play(Write(bounds))\n        self.wait(2)\n\n        # Applying the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration between the bounds\n        solution = MathTex(r\"= \\left. \\frac{x^{3}}{3} \\right|_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Evaluating the definite integral at the upper bound\n        evaluated_at_upper = MathTex(r\"= \\frac{3^3}{3}\")\n        self.play(ReplacementTransform(solution.copy(), evaluated_at_upper))\n        self.wait(1)\n\n        # Evaluating the definite integral at the lower bound\n        evaluated_at_lower = MathTex(r\"-\\frac{2^3}{3}\")\n        self.play(Write(evaluated_at_lower.next_to(evaluated_at_upper, RIGHT)))\n        self.wait(1)\n\n        # Calculating the final value of the definite integral\n        final_value = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(ReplacementTransform(VGroup(evaluated_at_upper, evaluated_at_lower), final_value))\n        self.wait(1)\n\n        # Simplifying the final result\n        final_result = MathTex(r\"= 6\")\n        self.play(ReplacementTransform(final_value, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final solution\n        final_solution_display = MathTex(r\"\\int_2^3 x^2 \\,dx = 6\")\n        self.play(Write(final_solution_display))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the original function\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for calculating area under curve\n        explanation1 = Text(\"Calculate area under curve from x = 0 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The definite integral setup\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_text))\n        self.wait(1)\n\n        # Explanation for using the integral to find the area\n        explanation2 = Text(\"Use the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solution\n        solution = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\")\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_result))\n        self.wait(1)\n\n        # Clear the scene and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)} \\right)\")\n        self.play(Write(fourier_eq))\n        self.wait(2)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying a harmonic term\n        harmonic_term = MathTex(r\"a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)}\")\n        self.play(Transform(fourier_eq, harmonic_term))\n        self.wait(2)\n\n        # Explanation of harmonics\n        explanation2 = Text(\"Each term represents a harmonic at a multiple of the fundamental frequency\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example with a finite number of terms\n        partial_sum = MathTex(r\"f_N(x) = a_0 + \\sum_{n=1}^{N} \\left( a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)} \\right)\")\n        self.play(Transform(fourier_eq, partial_sum))\n        self.wait(2)\n\n        # Explanation of practical computation with partial sums\n        explanation3 = Text(\"In practice, we use partial sums to approximate the function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the finite approximation\n        self.clear()\n        self.wait(1)\n        self.play(Write(partial_sum))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Drawing axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 10, 2],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Creating the curve \n        curve = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_area(curve, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Adding text\n        area_label = MathTex(r\"A=\\int_{0}^{2} x^2 \\,dx\", font_size=24).next_to(area, UP + LEFT)\n\n        # Displaying all elements\n        self.play(Create(axes), Create(labels))\n        self.play(Create(curve), FadeIn(area), Write(area_label))\n        self.wait(1)\n\n        # Calculating the area\n        area_calculation = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_0^2\")\n        self.play(Transform(area_label, area_calculation))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(Transform(area_label, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(area_label))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the given double integral\n        problem = MathTex(r\"\\int_0^1 \\int_{-1}^1 (x^2 + y^2) dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the integration with respect to y\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration over y\n        inner_integral = MathTex(r\"= \\int_0^1 \\left[\\frac{1}{3}y^3 + xy^2 \\right]_{-1}^1 dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explaining the integration with respect to x\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the inner integral\n        evaluated_inner = MathTex(r\"= \\int_0^1 \\left(\\frac{2}{3} + 2x\\right) dx\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner))\n        self.wait(1)\n\n        # Explaining the final integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution to the integral\n        final_solution = MathTex(r\"= \\left[ \\frac{2}{3}x + x^2 \\right]_0^1\")\n        self.play(ReplacementTransform(evaluated_inner, final_solution))\n        self.wait(2)\n\n        # Showing the result of the integral\n        result = MathTex(r\"= 2\")\n        self.play(Write(result))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass SimpleHarmonicMotion(Scene):\n    def construct(self):\n        # Display the differential equation for Simple Harmonic Motion\n        differential_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\frac{k}{m}x = 0\")\n        self.play(Write(differential_eq))\n        self.wait(2)\n\n        # Explain the transformation to the angular frequency\n        explanation1 = Text(\"Introduce angular frequency \", r\"\\(\\omega=\\sqrt{\\frac{k}{m}}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Show the transformed equation\n        transformed_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(differential_eq.copy(), transformed_eq))\n        self.wait(2)\n\n        # Explain the solution process\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Write down the general solution\n        general_solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(transformed_eq, general_solution))\n        self.wait(2)\n\n        # State the initial conditions\n        initial_conditions = Text(\"Given initial conditions determine \\(A\\) and \\(\\phi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(initial_conditions))\n        self.wait(3)\n\n        # Show the system in motion (example)\n        oscillator = Dot().shift(LEFT * 2)\n        path = TracedPath(oscillator.get_center, stroke_width=6, stroke_color=YELLOW)\n        self.add(path)\n        self.play(MoveAlongPath(oscillator, Circle(radius=2).shift(LEFT * 2)), run_time=4, rate_func=lambda t: there_and_back(t))\n        self.wait(2)\n\n        # Concluding the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the SHM demonstration.\", font_size=30)))\n        self.wait(3)"
  },
  {
    "text": "from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of the wave equation\n        explanation1 = Text(\"This is a second-order wave equation for u(x,t).\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The general solution is of the form u(x, t) = f(x - ct) + g(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n\n        # Explanation for specific solution using initial conditions\n        explanation3 = Text(\"Specific solutions require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AtomGridScene(Scene):\n    def construct(self):\n        grid = self.create_atom_grid(4, 4)\n        self.play(Create(grid))\n        self.wait(2)\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        atom_list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.hydrogen_atom().move_to(np.array([i - rows // 2, j - cols // 2, 0])))\n                else:\n                    atom_list.append(self.chlorine_atom().move_to(np.array([i - rows // 2, j - cols // 2, 0])))\n        return VGroup(*atom_list)\n\n    def hydrogen_atom(self) -> Mobject:\n        return Circle(radius=0.2, color=WHITE).add(Tex(\"H\", color=BLACK).scale(0.5))\n\n    def chlorine_atom(self) -> Mobject:\n        return Circle(radius=0.3, color=GREEN).add(Tex(\"Cl\", color=WHITE).scale(0.5))"
  },
  {
    "text": "from manim import *\n\nclass AnimatedScene(Scene):\n    def construct(self):\n        # Generate grid of metals and oxygen\n        metal_oxides_grid = metal_oxid(5, 5)\n        self.add(metal_oxides_grid)\n\n        # Create carbon grids at the top of the screen\n        carbon_grids = carbon_grid(3)\n        carbon_grids.to_edge(UP, buff=0.5)\n        self.add(carbon_grids)\n\n        # Create a lithium ion and electron\n        li_ion = lithium_ion().shift(DOWN * 2 + LEFT * 3)\n        e_particle = electron().next_to(li_ion, RIGHT, buff=0.5)\n\n        # Move lithium ion and electron across the screen\n        path_points = [li_ion.get_center(), *[RIGHT * x for x in range(7)], li_ion.get_center() + DOWN * 3]\n        move_animations = move_along_complex_path(li_ion, [2, 4], path_points, run_time=3)\n\n        # Move electron along a mirrored path\n        e_path_points = [e_particle.get_center(), *[RIGHT * x + DOWN * 0.1 for x in range(7)], e_particle.get_center() + DOWN * 3 - RIGHT * 6]\n        move_e_animations = move_along_complex_path(e_particle, [2, 4], e_path_points, run_time=3, rate_func=there_and_back_with_pause)\n\n        # Animate lithium ion and electron moving\n        self.play(AnimationGroup(*move_animations), AnimationGroup(*move_e_animations), lag_ratio=0.5)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBonds(Scene):\n    def construct(self):\n        # Create a water molecule representation with bonds\n        oxygen_atom = Circle(radius=0.5, color=BLUE).set_fill(BLUE, opacity=1)\n        hydrogen_atom1 = Circle(radius=0.25, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_atom2 = Circle(radius=0.25, color=WHITE).set_fill(WHITE, opacity=1)\n\n        bond1 = Line(start=oxygen_atom.get_right(), end=hydrogen_atom1.get_left())\n        bond2 = Line(start=oxygen_atom.get_left(), end=hydrogen_atom2.get_left())\n\n        water_molecule = VGroup(\n            oxygen_atom, \n            hydrogen_atom1.next_to(oxygen_atom, RIGHT, buff=0.5), \n            hydrogen_atom2.next_to(oxygen_atom, LEFT, buff=0.5),\n            bond1, \n            bond2\n        )\n\n        # Create labels for the atoms\n        oxygen_label = Text(\"O\", color=WHITE).move_to(oxygen_atom.get_center())\n        hydrogen_label1 = Text(\"H\", color=BLACK).move_to(hydrogen_atom1.get_center())\n        hydrogen_label2 = Text(\"H\", color=BLACK).move_to(hydrogen_atom2.get_center())\n\n        # Combine the molecule and the labels\n        molecule_with_labels = VGroup(water_molecule, oxygen_label, hydrogen_label1, hydrogen_label2)\n\n        # Animate the construction of the water molecule\n        self.play(Create(oxygen_atom))\n        self.play(Create(hydrogen_atom1), Create(hydrogen_atom2))\n        self.play(Create(bond1), Create(bond2))\n        self.play(FadeIn(oxygen_label), FadeIn(hydrogen_label1), FadeIn(hydrogen_label2))\n\n        # Scale up the molecule to focus on it\n        self.play(molecule_with_labels.animate.scale(2))\n\n        # Rotate the molecule within the scene\n        self.play(Rotate(molecule_with_labels, angle=2 * PI))\n\n        self.wait(2)  # Pause to admire our water molecule before ending the scene.\n"
  },
  {
    "text": "from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_particle = oxygen()\n        metal_particle = metal()\n\n        # Place the particles on screen\n        electron_particle.shift(LEFT * 2 + UP * 2)\n        oxygen_particle.shift(UP * 2)\n        metal_particle.shift(RIGHT * 2 + UP * 2)\n\n        self.play(FadeIn(electron_particle), FadeIn(oxygen_particle), FadeIn(metal_particle))\n        \n        # Movement animations\n        self.play(\n            electron_particle.animate.shift(RIGHT * 4),\n            oxygen_particle.animate.shift(DOWN * 2),\n            metal_particle.animate.shift(LEFT * 4),\n            run_time=2\n        )\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create an atom with electrons orbiting around a nucleus made of protons and neutrons\n        nucleus = VGroup(*[self.proton() for _ in range(6)], *[self.neutron() for _ in range(6)]).arrange_in_grid(buff=0.1)\n        electron_orbit = Circle(color=BLUE).surround(nucleus)\n        electrons = VGroup(*[self.electron() for _ in range(6)]).move_to(electron_orbit.points[::int(len(electron_orbit.points)/6)])\n\n        atom = VGroup(nucleus, electron_orbit, electrons)\n        self.play(Create(nucleus), Create(electron_orbit), *([FadeIn(e) for e in electrons]))\n        self.wait(2)\n\n        # Make electrons orbit around the nucleus\n        orbits = self.get_orbit_animations(electrons, electron_orbit)\n        self.play(AnimationGroup(*orbits, lag_ratio=0.5))\n\n        self.wait(2)\n\n    def proton(self) -> Mobject:\n        return self.circle_with_text(\n            0.2, \"p$^+$\", RED_D, font_size=18, font_color=WHITE, stroke_width=2, fill_color=RED_D\n        )\n\n    def neutron(self) -> Mobject:\n        return self.circle_with_text(\n            0.2, \"n$^0$\", GREY_B, font_size=18, font_color=WHITE, stroke_width=2, fill_color=GREY_B\n        )\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(\n            0.15, \"e$^-$\", BLUE_E, font_size=24, font_color=BLACK, stroke_width=1, fill_color=BLUE_E\n        )\n\n    def circle_with_text(\n        self, r: float, txt: str, color, font_size: int, font_color, stroke_width: int, fill_color\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color).move_to(c.get_center())\n        return VGroup(c, t)\n\n    def get_orbit_animations(self, electrons, orbit):\n        animations = []\n        for electron in electrons:\n            animations.append(Rotate(electron, angle=2*PI, about_point=orbit.get_center(), rate_func=linear))\n        return animations"
  },
  {
    "text": "from manim import *\n\nclass Custom2DGridScene(Scene):\n    def create_grid(self, rows: int, cols: int, cell_size: float = 1.0):\n        \"\"\"\n        Create a 2D grid of squares given row and column counts.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            cell_size (float): The side length of each square cell.\n\n        Returns:\n            VGroup: A group containing all the grid squares.\n        \"\"\"\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                square = Square(side_length=cell_size)\n                square.move_to(np.array([j * cell_size, -i * cell_size, 0]))\n                grid.add(square)\n        grid.move_to(ORIGIN)  # Center the grid.\n        return grid\n\n    def construct(self):\n        rows, cols = 5, 5  # Define the number of rows and columns for the grid.\n        grid = self.create_grid(rows, cols)  # Create the grid using the helper function.\n        self.add(grid)  # Add the grid to the scene.\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a dot that will move along a path.\n        dot = Dot(radius=0.1, color=RED)\n        \n        # Define the complex path points.\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP + LEFT * 2, UP * 2]\n        complex_path = VGroup()\n        \n        # Iterate over the points to create the visual path with lines.\n        for i in range(len(path_points) - 1):\n            line = Line(path_points[i], path_points[i + 1], stroke_width=2, color=BLUE)\n            complex_path.add(line)\n        \n        # Show the path on screen.\n        self.add(complex_path)\n        \n        # Create a custom animation by moving the dot along the defined path.\n        def custom_path_position(alpha):\n            num_points = len(path_points)\n            curr_point = int(alpha * (num_points - 1))\n            sub_alpha = (alpha * (num_points - 1)) % 1\n            return path_points[curr_point] + (path_points[curr_point + 1] - path_points[curr_point]) * sub_alpha\n\n        self.play(MoveAlongPath(dot, complex_path), run_time=4, rate_func=linear)\n        self.add(dot)  # Keep the dot displayed at the end."
  },
  {
    "text": "from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electron_orbit(atom)\n        self.play(FadeIn(atom))\n        self.play(AnimationGroup(*[\n            MoveAlongPath(e, orbit) for e, orbit in electrons\n        ], lag_ratio=0.5))\n        self.wait(2)\n\n    def create_atom(self) -> Mobject:\n        nucleus = Dot(radius=0.2, color=BLUE).set_fill(BLUE_E, opacity=1)\n        protons = Tex(r'8p$^+$').set_color(WHITE).scale(0.5)\n        neutrons = Tex(r'8n').next_to(protons, DOWN, buff=0.1).set_color(WHITE).scale(0.5)\n        return VGroup(nucleus, protons, neutrons)\n\n    def create_electron_orbit(self, atom: Mobject) -> List[Tuple[Mobject, VMobject]]:\n        electrons = []\n        for i in range(1, 3):  # Creating 2 orbits\n            orbit = Ellipse(width=2*i, height=1*i, color=GREY).shift(atom.get_center())\n            num_electrons = 2 * i\n            for _ in range(num_electrons):\n                electron = Dot(radius=0.05, color=RED).set_fill(RED_D, opacity=1)\n                electrons.append((electron, orbit))\n        return electrons\n\n    @staticmethod\n    def position_electrons_on_orbit(electrons: List[Tuple[Mobject, VMobject]], angle_offset: float = 0):\n        for i, (electron, orbit) in enumerate(electrons):\n            num_electrons = len(orbit)\n            angle = (TAU / num_electrons) * i + angle_offset\n            direction = orbit.point_at_angle(angle)\n            electron.move_to(direction)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        li_ion = lithium_ion()\n        elctron = electron()\n        mtl_oxid = metal_oxid(4, 5)\n\n        # Place lithium ion at the top left corner\n        li_ion.move_to(UP + LEFT)\n\n        # Place electron at the bottom right corner\n        elctron.move_to(DOWN + RIGHT)\n\n        # Position metal oxide grid in the center\n        mtl_oxid.move_to(ORIGIN)\n\n        # Add to scene\n        self.add(li_ion, elctron, mtl_oxid)\n\n        # Move lithium ion and electron towards the metal oxide grid\n        self.play(\n            li_ion.animate.move_to(mtl_oxid[0].get_center()),\n            elctron.animate.move_to(mtl_oxid[-1].get_center()),\n            run_time=2\n        )\n\n        # Show a reaction happening\n        self.play(\n            Flash(mtl_oxid[0].get_center()),\n            Flash(mtl_oxid[-1].get_center()),\n            run_time=1\n        )\n\n        # Remove lithium ion and electron from the scene\n        self.play(\n            FadeOut(li_ion),\n            FadeOut(elctron),\n            run_time=1\n        )\n\n        # Highlight the change in the metal oxide grid after the reaction\n        self.play(\n            mtl_oxid.animate.set_opacity(0.5),\n            run_time=1\n        )\n\n        # Keep the final state for a while before ending the scene\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create Molecules\n        reactant1 = electron()\n        reactant2 = oxygen()\n        product = metal_oxid(2, 3)\n\n        # Position Molecules\n        reactant1.next_to(reactant2, LEFT, buff=1)\n        product.to_edge(RIGHT)\n\n        # Display Reactants\n        self.play(FadeIn(reactant1), FadeIn(reactant2))\n        self.wait(1)\n\n        # React and form Product\n        self.play(Transform(VGroup(reactant1, reactant2), product))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBondingScene(Scene):\n    def construct(self):\n        # Create an Oxygen molecule\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=1)\n\n        # Create a Sodium atom\n        sodium_atom = metal().scale(0.9).next_to(oxygen_molecule, LEFT, buff=1)\n\n        # Create a Chlorine atom\n        chlorine_atom = negative().scale(0.9).next_to(oxygen_molecule, RIGHT, buff=1)\n\n        # Animate the creation of the Sodium-Oxygen-Chlorine structure\n        self.play(AnimationGroup(\n            Create(sodium_atom),\n            Create(oxygen_molecule),\n            Create(chlorine_atom),\n            lag_ratio=0.5\n        ))\n\n        # Pause for a moment\n        self.wait(1)\n\n        # Animate the transformation to a new structure\n        self.play(\n            sodium_atom.animate.shift(UP * 2),\n            oxygen_molecule.animate.shift(DOWN * 2),\n            chlorine_atom.animate.shift(UP * 2)\n        )\n\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(VGroup(sodium_atom, oxygen_molecule, chlorine_atom)))"
  },
  {
    "text": "from manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=BLUE)\n        oxygen_atom.set_fill(BLUE, opacity=0.5)\n        oxygen_text = Text(\"O\", color=WHITE)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.3, color=GREY)\n        hydrogen_atom.set_fill(GREY, opacity=0.5)\n        hydrogen_text = Text(\"H\", color=WHITE)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position the hydrogen atoms around the oxygen\n        hydrogen.move_to(oxygen.get_edge_center(UP) + UP * 0.4)\n        hydrogen_copy1 = hydrogen.copy().shift(LEFT * 0.8 + DOWN * 0.4)\n        hydrogen_copy2 = hydrogen.copy().shift(RIGHT * 0.8 + DOWN * 0.4)\n\n        # Connect the atoms with lines to indicate bonds\n        bond1 = Line(hydrogen.get_center(), oxygen.get_edge_center(UP))\n        bond2 = Line(hydrogen_copy1.get_center(), oxygen.get_edge_center(DL))\n        bond3 = Line(hydrogen_copy2.get_center(), oxygen.get_edge_center(DR))\n\n        # Create a water molecule group\n        water_molecule = VGroup(oxygen, hydrogen, hydrogen_copy1, hydrogen_copy2, bond1, bond2, bond3)\n\n        # Display the water molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))"
  },
  {
    "text": "from manim import *\n\nclass AnimatedScene(Scene):\n    def construct(self):\n        # Create a grid of lithium ions\n        lithium_ions = self.lithium_grid(5, 5)\n        \n        # Create an electron object\n        electron_obj = electron()\n        \n        # Define path points for electron movement\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP * 2]\n        \n        # Create animations for electron moving along complex path\n        electron_animations = move_along_complex_path(\n            electron_obj, stop_indices=[1, 3], points=path_points, run_time=3\n        )\n\n        # Add lithium ions to the scene\n        self.add(lithium_ions)\n        # Add electron to the scene\n        self.add(electron_obj)\n        # Play electron animations\n        self.play(*electron_animations)\n        # Hold the final frame\n        self.wait()\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def lithium_ion(self) -> Mobject:\n        return circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                path = Line(points[i], points[i + 1])\n                animations.append(MoveAlongPath(obj, path, run_time=run_time / len(points), rate_func=rate_func))\n        return animations\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color=color, fill_opacity=1).set_fill(color=fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)"
  },
  {
    "text": "from manim import *\n\nclass ChemistryAnimation(Scene):\n    def construct(self):\n        # Create an electron Mobject\n        electron_particle = electron()\n        electron_particle.move_to(LEFT * 4)\n\n        # Create an oxygen Mobject\n        oxygen_molecule = oxygen()\n        oxygen_molecule.move_to(4 * RIGHT)\n\n        # Animate the electron moving towards the oxygen\n        self.play(MoveToTarget(electron_particle, target_position=oxygen_molecule.get_center(), run_time=3))\n\n        # Create a group of metal oxide molecules in a grid layout\n        metal_oxide_grid = metal_oxid(rows=3, cols=3)\n        metal_oxide_grid.move_to(DOWN * 2)\n\n        # Display oxygen molecule and metal oxide grid\n        self.play(FadeIn(oxygen_molecule), FadeIn(metal_oxide_grid))\n\n        # Move the metal oxide grid upwards while electron moves toward it\n        self.play(metal_oxide_grid.animate.move_to(UP * 2),\n                  MoveToTarget(electron_particle, target_position=metal_oxide_grid.get_center()))\n\n        # Finish the scene\n        self.wait(2)\n        self.play(FadeOut(oxygen_molecule), FadeOut(metal_oxide_grid), FadeOut(electron_particle))"
  },
  {
    "text": "from manim import *\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        co_oxid_grid = self.metal_oxid(4, 3, 2)\n        self.play(ShowCreation(co_oxid_grid))\n        self.wait()\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    oxygen_atom = self.oxygen().move_to(np.array([i, j, 0]) / scale)\n                    grid.add(oxygen_atom)\n                else:\n                    metal_atom = self.metal().move_to(np.array([i, j, 0]) / scale)\n                    grid.add(metal_atom)\n        return grid\n\n    def oxygen(self) -> Mobject:\n        circle = Circle(radius=0.285, color=GREY_B)\n        circle.set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O$^2$\", color=WHITE).scale(0.7)\n        oxygen_atom = VGroup(circle, oxygen_text)\n        return oxygen_atom\n\n    def metal(self) -> Mobject:\n        circle = Circle(radius=0.285, color=BLUE_D)\n        circle.set_fill(BLUE_D, opacity=1)\n        metal_text = Tex(\"Co\", color=WHITE).scale(0.7)\n        metal_atom = VGroup(circle, metal_text)\n        return metal_atom\n"
  },
  {
    "text": "from manim import *\n\nclass MovingElectronScene(Scene):\n    def construct(self):\n        # Create an electron object using the previously defined function\n        electron_object = electron()\n        \n        # Define starting and ending points\n        start_point = LEFT * 4\n        end_point = RIGHT * 4\n        \n        # Create a path for the electron to follow\n        path = VMobject()\n        path.set_points_as_corners([start_point, UP*2, end_point])\n        \n        # Move electron along the path\n        self.play(MoveAlongPath(electron_object, path, rate_func=there_and_back, run_time=5))\n        \n        # Keep the electron on screen at the end of the path\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        # Create a grid of alternating oxygen and metal ions\n        grid = metal_oxid(3, 3)\n        self.play(FadeIn(grid))\n        \n        # Add an electron moving through the grid\n        e = electron()\n        self.play(FadeIn(e))\n        path_points = [\n            UP * 0.5 + LEFT * 0.5,\n            UP * 0.5 + RIGHT * 1.5,\n            DOWN * 1.5 + RIGHT * 1.5,\n            DOWN * 1.5 + LEFT * 0.5,\n            UP * 0.5 + LEFT * 0.5\n        ]\n        self.play(*move_along_complex_path(e, [2], path_points, run_time=2))\n        \n        # Display positive and negative ions\n        positive_ion = positive()\n        negative_ion = negative()\n        self.play(FadeIn(positive_ion), FadeIn(negative_ion))\n        self.play(positive_ion.animate.move_to(UP * 2), negative_ion.animate.move_to(DOWN * 2))\n        \n        # Add a lithium_grid\n        lithium = lithium_grid(2, 2)\n        self.play(FadeIn(lithium))\n        self.play(lithium.animate.move_to(RIGHT * 3))\n        \n        # Add a carbon grid\n        carbon_lattice = carbon_grid(2)\n        self.play(FadeIn(carbon_lattice))\n        self.play(carbon_lattice.animate.move_to(LEFT * 3))\n        \n        # Wait to see the full animation before exiting\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass WaterScene(Scene):\n    def construct(self):\n        # Create water molecule (H2O)\n        oxygen_center = oxygen()\n        hydrogen1 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        hydrogen2 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        \n        hydrogen1.next_to(oxygen_center, UP+LEFT, buff=0)\n        hydrogen2.next_to(oxygen_center, UP+RIGHT, buff=0)\n        \n        water_molecule = VGroup(oxygen_center, hydrogen1, hydrogen2)\n        \n        # Animate creation of the water molecule\n        self.play(Create(water_molecule))\n        self.wait(1)\n        \n        # Rotate water molecule\n        self.play(Rotate(water_molecule, angle=2*PI), run_time=2)\n        self.wait(1)\n        \n        # Dissociation of water molecule\n        self.play(\n            hydrogen1.animate.shift(LEFT*3),\n            hydrogen2.animate.shift(RIGHT*3),\n        )\n        self.wait(1)\n        \n        # Recombination of hydrogen and oxygen to form water\n        self.play(\n            hydrogen1.animate.next_to(oxygen_center, UP+LEFT, buff=0),\n            hydrogen2.animate.next_to(oxygen_center, UP+RIGHT, buff=0)\n        )\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of electrons\n        electrons = VGroup(*[electron().move_to(2*RIGHT*i+2*UP*j) for i in range(-2,3) for j in range(-2,3)])\n        \n        # Animate electrons entering the screen and create oxygen at the center\n        self.play(LaggedStart(*[FadeInFromPoint(elec, ORIGIN) for elec in electrons], lag_ratio=0.1))\n        central_oxygen = oxygen().move_to(ORIGIN)\n        self.wait(1)\n        \n        # Transform one electron into an oxygen and move others outwards\n        self.play(\n            ReplacementTransform(electrons[12], central_oxygen),\n            *[elec.animate.move_to(3 * elec.get_center()) for elec in electrons if elec is not electrons[12]],\n        )\n        self.wait(1)\n        \n        # Create a lithium ion grid and move it in\n        li_grid = lithium_grid(3, 3).next_to(central_oxygen, UP, buff=1)\n        self.play(FadeIn(li_grid), run_time=2)\n        self.wait(1)\n\n        # Animate lithium ions moving in a complex path\n        complex_path = [\n            ORIGIN, 2*LEFT, 2*LEFT + 3*DOWN, 4*RIGHT + 3*DOWN, 4*RIGHT, 2*UP + 4*RIGHT\n        ]\n        lithium_animations = move_along_complex_path(li_grid, [1,3], complex_path, 2)\n        self.play(AnimationGroup(*lithium_animations))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass BatteryAnimation(Scene):\n    def construct(self):\n        anode = self.create_electrode(\"Anode\", LEFT * 2)\n        cathode = self.create_electrode(\"Cathode\", RIGHT * 2)\n        battery = VGroup(anode, cathode)\n        self.add(battery)\n\n        electron_path = self.get_electron_path(LEFT * 2, RIGHT * 2, 3)\n        electron = electron().move_to(anode)\n        self.play(*move_along_complex_path(electron, [], electron_path, run_time=5, rate_func=there_and_back))\n\n    def create_electrode(self, label_text, position):\n        electrode = Rectangle(height=3, width=1, fill_opacity=1, fill_color=DARK_GREY)\n        label = Tex(label_text, color=WHITE)\n        electrode_group = VGroup(electrode, label).arrange(DOWN)\n        electrode_group.move_to(position)\n        return electrode_group\n\n    def get_electron_path(self, start_point, end_point, num_curves):\n        path = [start_point]\n        for i in range(num_curves):\n            path.append(path[-1] + UP if i % 2 == 0 else path[-1] + DOWN)\n            path.append(end_point if i % 2 == 0 else start_point)\n        return path\n"
  },
  {
    "text": "from manim import *\n\nclass AtomDrawing(Scene):\n    def construct(self):\n        # Create a proton, neutron, and electron\n        proton = self.create_atom_part(radius=0.2, label_text=\"p^+\", color=RED)\n        neutron = self.create_atom_part(radius=0.2, label_text=\"n^0\", color=GREY)\n        electron = self.create_atom_part(radius=0.1, label_text=\"e^-\", color=BLUE)\n\n        # Positioning the protons and neutrons to form a nucleus\n        nucleus = VGroup(proton, neutron).arrange(buff=0.5)\n        \n        # Positioning the electron around the nucleus\n        electron.move_to(nucleus.get_edge_center(LEFT) + LEFT*0.5)\n\n        # Animating the electron to move around the nucleus\n        self.play(MoveAlongPath(electron, Circle(radius=1, color=WHITE).move_to(nucleus.get_center()), run_time=2, rate_func=linear))\n        self.wait(2)\n\n        # Group everything and add to the scene\n        atom = VGroup(nucleus, electron)\n        self.add(atom)\n        self.wait(2)\n\n    def create_atom_part(self, radius, label_text, color):\n        atom_part = Circle(radius=radius, color=color)\n        atom_part.set_fill(color, opacity=0.5)\n\n        # Create the label\n        label = Tex(label_text, color=color).scale(0.5)\n        atom_part.add(label)\n        \n        return atom_part\n"
  },
  {
    "text": "from manim import *\n\nclass HydrogenAnimation(Scene):\n    def construct(self):\n        hydrogen = self.create_hydrogen()\n        self.play(FadeIn(hydrogen))\n        self.play(Rotate(hydrogen, angle=2 * PI), run_time=2)\n        self.play(FadeOut(hydrogen))\n\n    def create_hydrogen(self) -> Mobject:\n        circle = Circle(radius=0.3, color=BLUE)\n        text = Tex(\"H\", font_size=30, color=WHITE)\n        electron = self.create_electron()\n\n        hydrogen = VGroup(circle, text, electron)\n        hydrogen.arrange(RIGHT)\n\n        return hydrogen\n\n    def create_electron(self) -> Mobject:\n        orbit = Ellipse(width=0.8, height=0.5, stroke_color=RED)\n        dot = Dot(color=RED)\n        elec = VGroup(orbit, dot)\n\n        return elec.rotate_in_place(PI/2)"
  },
  {
    "text": "from manim import *\n\n\nclass WaterMoleculeScene(Scene):\n    def construct(self):\n        # Create a water molecule with one oxygen and two hydrogen atoms\n        molecule = VGroup()\n        \n        # Oxygen atom\n        oxygen_atom = self.create_atom(\"O\", WHITE, RED_B)\n        molecule.add(oxygen_atom)\n\n        # Hydrogen atoms\n        hydrogen_atom1 = self.create_atom(\"H\", WHITE, BLUE)\n        hydrogen_atom2 = self.create_atom(\"H\", WHITE, BLUE)\n\n        hydrogen_atom1.next_to(oxygen_atom, UP + LEFT, buff=0.7)\n        hydrogen_atom2.next_to(oxygen_atom, UP + RIGHT, buff=0.7)\n\n        molecule.add(hydrogen_atom1, hydrogen_atom2)\n\n        # Bonds\n        bond1 = Line(oxygen_atom.get_center(), hydrogen_atom1.get_center(), buff=0.2)\n        bond2 = Line(oxygen_atom.get_center(), hydrogen_atom2.get_center(), buff=0.2)\n\n        molecule.add(bond1, bond2)\n\n        # Make the molecule move in a path\n        molecule.move_to(ORIGIN)\n\n        # Animation\n        self.play(FadeIn(molecule))\n        self.play(Rotate(molecule, angle=2*PI), run_time=4)\n        self.wait()\n\n    def create_atom(\n        self, label: str,\n        label_color: str,\n        circle_color: str,\n        radius: float = 0.3\n    ) -> VGroup:\n        atom_circle = Circle(radius=radius, color=circle_color)\n        atom_circle.set_fill(circle_color, opacity=1)\n\n        atom_label = Text(label, color=label_color)\n        atom = VGroup(atom_circle, atom_label)\n        atom_label.move_to(atom_circle.get_center())\n\n        return atom\n"
  },
  {
    "text": "from manim import *\n\nclass CreateGraph(Scene):\n    def construct(self):\n        # Create vertices\n        v1 = Dot(LEFT)\n        v2 = Dot(RIGHT)\n        v3 = Dot(UP)\n\n        vertices = VGroup(v1, v2, v3)\n\n        # Create edges connecting the vertices\n        e1 = Line(v1.get_center(), v2.get_center())\n        e2 = Line(v2.get_center(), v3.get_center())\n        e3 = Line(v3.get_center(), v1.get_center())\n\n        edges = VGroup(e1, e2, e3)\n\n        # Create a graph from vertices and edges\n        graph = VGroup(vertices, edges)\n\n        # Perform animation\n        self.play(FadeIn(graph))\n        self.wait(1)\n\n        # Label vertices\n        l1 = Tex(\"V1\").next_to(v1, DOWN)\n        l2 = Tex(\"V2\").next_to(v2, DOWN)\n        l3 = Tex(\"V3\").next_to(v3, UP)\n\n        labels = VGroup(l1, l2, l3)\n\n        self.play(FadeIn(labels))\n        self.wait(1)\n\n        # Create a path to move an object along\n        path = VMobject()\n        path.set_points_as_corners([v1.get_center(), v2.get_center(), v3.get_center(), v1.get_center()])\n\n        # Create a moving object\n        moving_dot = Dot(color=RED).move_to(v1)\n\n        # Animation: move along the path created\n        self.play(MoveAlongPath(moving_dot, path), run_time=3, rate_func=linear)\n\n        # Finish animation\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass CreateGraphScene(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        dotted_line = DashedVMobject(axes.get_vertical_line_to_graph(1, graph, color=YELLOW))\n\n        self.play(Create(axes), Create(graph))\n        self.play(FadeIn(graph_label), Create(dotted_line))\n        self.wait(2)\n        \n        derivative = axes.plot_derivative_graph(graph, color=PURPLE)\n        self.play(Create(derivative))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electrons(atom)\n        self.play(FadeIn(atom))\n        self.play(*[FadeIn(e) for e in electrons])\n        self.play(*[self.electron_orbit_animation(e) for e in electrons])\n        self.wait(2)\n\n    def create_atom(self) -> Mobject:\n        proton = Circle(color=PURE_RED).set_fill(PURE_RED)\n        neutron = Circle(color=GRAY_B).set_fill(GRAY_B).shift(DOWN * 0.2 + RIGHT * 0.2)\n        nucleus = VGroup(proton, neutron).arrange_in_grid(1, 2, buff=0.1)\n        return nucleus\n\n    def create_electrons(self, nucleus: Mobject) -> List[Mobject]:\n        electrons = []\n        for _ in range(2):\n            electron = Circle(color=PURE_BLUE).scale(0.1).set_fill(PURE_BLUE)\n            electron.add_updater(\n                lambda m, dt: m.move_to(nucleus.get_center() + np.array([\n                    np.cos(self.time), \n                    np.sin(self.time), \n                    0\n                ]) * 1.5)\n            )\n            electrons.append(electron)\n        return electrons\n\n    def electron_orbit_animation(self, electron: Mobject) -> Animation:\n        return Rotate(electron, angle=2 * PI, about_point=electron.get_center(), run_time=2, rate_func=linear)"
  },
  {
    "text": "from manim import *\n\nclass ChemistryAnimation(Scene):\n    def construct(self):\n        molecule_group = VGroup(oxygen(), metal(), electron())\n        molecule_group.arrange(RIGHT, buff=1)\n\n        self.play(Create(molecule_group))\n        self.wait(2)\n\n        # Animate creation of a positive ion\n        positive_ion = positive()\n        self.play(FadeIn(positive_ion, shift=UP))\n        self.wait(1)\n\n        # Animate creation of a negative ion\n        negative_ion = negative()\n        self.play(FadeIn(negative_ion, shift=DOWN))\n        self.wait(1)\n\n        # Combine ions into an ionic compound\n        compound = VGroup(positive_ion, negative_ion)\n        compound.arrange(RIGHT, buff=0.5)\n        self.play(Transform(molecule_group, compound))\n        self.wait(2)\n\n        # Move the compound in a zigzag pattern\n        zigzag_path = VMobject()\n        zigzag_path.set_points_as_corners([UL, UR, DL, DR, ORIGIN])\n        self.play(MoveAlongPath(compound, zigzag_path), run_time=4, rate_func=linear)\n        self.wait(2)\n\n        # Finish the scene\n        self.play(FadeOut(compound))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create an electron\n        electron_object = electron()\n        self.play(FadeIn(electron_object))\n        self.wait(1)\n\n        # Create an oxygen atom\n        oxygen_object = oxygen()\n        self.play(Transform(electron_object, oxygen_object))\n        self.wait(1)\n\n        # Create grid of metal oxides\n        metal_oxide_grid = metal_oxid(3, 3)\n        self.play(FadeTransform(oxygen_object, metal_oxide_grid))\n        self.wait(1)\n\n        # Create a single carbon atom\n        carbon_object = carbon()\n        self.play(FadeIn(carbon_object))\n        self.wait(1)\n\n        # Move the carbon atom along a complex path\n        complex_path = [UP, UP + RIGHT, RIGHT, DOWN + RIGHT, DOWN, DOWN + LEFT, LEFT, UP + LEFT, UP]\n        stop_indices = [2, 5]\n        animations = move_along_complex_path(carbon_object, stop_indices, complex_path, run_time=2, rate_func=smooth)\n        self.play(*animations)  # Play all the animations together\n        self.wait(2)\n\n        # Final fade out of all objects\n        all_objects = VGroup(electron_object, metal_oxide_grid, carbon_object)\n        self.play(FadeOut(all_objects))"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        proton = self.create_proton()\n        electron = self.create_electron()\n        hydrogen_atom = VGroup(proton, electron).arrange(RIGHT, buff=1)\n        self.add(hydrogen_atom)\n        self.play(hydrogen_atom.animate.shift(UP))\n\n    def create_proton(self) -> Mobject:\n        return circle_with_text(0.2, \"p$^+$\", RED_E, 24, WHITE, 2, RED_E)\n\n    def create_electron(self) -> Mobject:\n        return circle_with_text(0.15, \"e$^-$\", BLUE_E, 24, WHITE, 1, BLUE_E)\n\n    def circle_with_text(\n        self,\n        radius: float,\n        text: str,\n        border_color: str,\n        font_size: int,\n        font_color: str,\n        stroke_width: int,\n        fill_color: str\n    ) -> Mobject:\n        circle = Circle(radius, color=border_color).set_opacity(1).set_fill(fill_color)\n        label = Tex(text, font_size=font_size, color=font_color).set_stroke(width=stroke_width)\n        return VGroup(circle, label)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        # Create reactants\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=0.5)\n        hydrogen_molecule = VGroup(electron(), electron()).arrange(RIGHT, buff=0.5)\n\n        # Create products\n        water_molecule = VGroup(oxygen(), electron(), electron()).arrange(RIGHT, buff=0.25)\n\n        # Position molecules on screen\n        oxygen_molecule.next_to(ORIGIN, LEFT, buff=1)\n        hydrogen_molecule.next_to(ORIGIN, RIGHT, buff=1)\n        water_molecule.move_to(3 * DOWN)\n\n        # Display the reactants\n        self.play(FadeIn(oxygen_molecule), FadeIn(hydrogen_molecule))\n        self.wait(1)\n\n        # Move reactants off screen and products on screen\n        self.play(\n            oxygen_molecule.animate.shift(UP),\n            hydrogen_molecule.animate.shift(UP),\n            FadeIn(water_molecule)\n        )\n        self.wait(1)\n\n        # Display reactants turning into products\n        self.play(\n            FadeOut(oxygen_molecule),\n            FadeOut(hydrogen_molecule),\n            water_molecule.animate.move_to(ORIGIN)\n        )\n        self.wait(2)\n\n        # Clean up\n        self.play(FadeOut(water_molecule))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ElementSymbol(Scene):\n    def construct(self):\n        symbol = Tex(\"He\", color=WHITE, font_size=144)\n        electron_orbit = Ellipse(width=3.6, height=2.2, color=YELLOW_C).shift(DOWN*0.5)\n        electron_1 = Dot(color=RED, radius=0.1).shift(LEFT*1.8)\n        electron_2 = Dot(color=RED, radius=0.1).shift(RIGHT*1.8)\n\n        element_group = VGroup(symbol, electron_orbit, electron_1, electron_2)\n\n        self.play(FadeIn(element_group))\n        self.play(\n            Rotate(electron_1, angle=2*PI, about_point=symbol.get_center()),\n            Rotate(electron_2, angle=2*PI, about_point=symbol.get_center()),\n            rate_func=linear,\n            run_time=4\n        )\n        self.play(FadeOut(element_group))"
  },
  {
    "text": "from manim import *\n\nclass HydrogenScene(Scene):\n    def construct(self):\n        hydrogen = self.hydrogen_atom()\n        self.play(ShowCreation(hydrogen))\n        self.wait(2)\n\n    def hydrogen_atom(self) -> Mobject:\n        electron_orbit = self.get_electron_orbit()\n        proton = self.proton()\n        electron = self.electron()\n        return VGroup(proton, electron_orbit, electron)\n\n    def get_electron_orbit(self) -> Mobject:\n        orbit = Circle(radius=1, color=BLUE)\n        orbit.set_stroke(width=2)\n        return orbit\n\n    def proton(self) -> Mobject:\n        return circle_with_text(0.3, \"P$^+$\", RED, 24, BLACK, 2, RED)\n\n    def electron(self) -> Mobject:\n        electron = Dot(point=RIGHT, radius=0.08, color=BLUE)\n        electron.shift(UP * self.get_electron_orbit().radius)\n        orbit_animation = Rotate(electron, angle=2 * PI, about_point=ORIGIN, rate_func=linear)\n        self.play(orbit_animation, run_time=5, rate_func=linear)\n        return electron\n\ndef circle_with_text(\n    radius: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    circle = Circle(radius, color=color, fill_opacity=1).set_fill(color=fill_color)\n    text = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(circle, text).move_to(ORIGIN)"
  },
  {
    "text": "from manim import *\n\nclass AtomAnimation(Scene):\n    def construct(self):\n        # Create an atom with electrons orbiting around the nucleus\n        nucleus = Dot(radius=0.2, color=RED)\n        electron_orbit = Circle(radius=0.5)\n        electron_orbit.set_stroke(WHITE, 2)\n        electrons = VGroup(*[Dot(radius=0.05, color=BLUE).move_to(electron_orbit.point_from_proportion(i/3)) for i in range(3)])\n        \n        atom = VGroup(nucleus, electron_orbit, electrons)\n        \n        # Show creation of the atom\n        self.play(FadeIn(nucleus), ShowCreation(electron_orbit), FadeIn(electrons))\n        \n        # Animate electrons\n        electron_animations = [\n            Rotate(electron, about_point=nucleus.get_center(), angle=2*PI, run_time=4, rate_func=linear)\n            for electron in electrons\n        ]\n        self.play(*electron_animations, rate_func=linear)\n        \n        # Move atom to the side\n        self.play(atom.animate.to_edge(LEFT))\n        \n        # Create another atom and move it to the opposite side\n        second_atom = atom.copy()\n        self.add(second_atom)\n        self.play(second_atom.animate.to_edge(RIGHT))\n        \n        # Fade out everything\n        self.play(FadeOut(VGroup(atom, second_atom)))"
  },
  {
    "text": "from manim import *\n\nclass MolecularAnimation(Scene):\n    def construct(self):\n        # Create a sequence of objects\n        mol1 = electron()\n        mol2 = metal()\n        mol3 = positive()\n        mol4 = negative()\n        \n        # Position objects on the screen\n        mol_group = VGroup(mol1, mol2, mol3, mol4).arrange(RIGHT, buff=1)\n\n        # Animate the objects\n        self.play(Create(mol_group))\n        self.wait(1)\n\n        # Show them moving to different locations\n        self.play(\n            mol1.animate.shift(UP * 2),\n            mol2.animate.shift(DOWN * 2),\n            mol3.animate.shift(LEFT * 2),\n            mol4.animate.shift(RIGHT * 2),\n        )\n        self.wait(2)\n\n        # Disappear animation\n        self.play(FadeOut(mol_group))"
  },
  {
    "text": "from manim import *\n\nclass HydrogenIonScene(Scene):\n    def construct(self):\n        h_ion = self.create_hydrogen_ion()\n        self.play(FadeIn(h_ion))\n        self.wait(1)\n        self.play(h_ion.animate.shift(UP * 2))\n        self.wait(1)\n        self.play(FadeOut(h_ion))\n\n    def create_hydrogen_ion(self) -> Mobject:\n        return Circle(radius=0.2, color=RED_B).set_fill(RED_B, opacity=1).add(\n            Tex('H$^+$', color=WHITE).scale(1.5)\n        )\n\nclass ElectronPathScene(Scene):\n    def construct(self):\n        electron_particle = Electron()\n        path = self.define_path()\n        self.add(electron_particle)\n        self.play(*move_along_complex_path(electron_particle, [0, 3], path, run_time=2, rate_func=there_and_back_with_pause))\n\n    def define_path(self):\n        points = [UP + LEFT, UP + RIGHT, DOWN + RIGHT, DOWN + LEFT]\n        return [self.coords_to_point(p[0], p[1]) for p in points]\n\ndef Electron():\n    return Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=1).add(\n        Tex('e$^-$', color=WHITE).scale(0.5)\n    )"
  },
  {
    "text": "from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        grid = self.create_grid(4, 4, 0.5)\n        self.add(grid)\n        self.wait(1)\n        \n        path = self.create_complex_path()\n        electron_particle = electron()\n        self.play(*move_along_complex_path(electron_particle, [2, 4], path, 0.5))\n        self.wait(1)\n        \n        self.play(FadeOut(grid), FadeOut(electron_particle))\n        \n    def create_grid(self, rows: int, cols: int, cell_size: float) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                cell = Square(side_length=cell_size)\n                cell.move_to(np.array([j * cell_size, i * cell_size, 0]))\n                grid.add(cell)\n        grid.move_to(ORIGIN)\n        return grid\n    \n    def create_complex_path(self):\n        points = [UP * 2, UP + RIGHT, ORIGIN, DOWN + LEFT * 2, DOWN * 2 + RIGHT * 2]\n        return points\n        "
  },
  {
    "text": "from manim import *\n\nclass MoleculeMovementScene(Scene):\n    def construct(self):\n        # Create a grid of atoms representing a molecule\n        molecule_grid = self.create_molecule_grid(rows=3, cols=3)\n        molecule_grid.move_to(ORIGIN)\n        self.add(molecule_grid)\n\n        # Randomly move an electron around the molecule grid\n        moving_electron = electron().shift(LEFT * 2 + UP * 2)\n        self.add(moving_electron)\n\n        # Define complex path for the electron to move along\n        path_points = [\n            UR * 2, RIGHT * 2 + DOWN, UP + LEFT * 2, DOWN * 2 + RIGHT, ORIGIN\n        ]\n\n        # Move the electron along the path\n        self.play(\n            *move_along_complex_path(moving_electron, stop_indices=[1, 3], points=path_points, run_time=2)\n        )\n        self.wait(1)\n\n    def create_molecule_grid(self, rows: int, cols: int) -> Mobject:\n        # Create a grid of alternating positive and negative ions\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                ion = positive() if (i + j) % 2 == 0 else negative()\n                ion.move_to(i * RIGHT + j * UP)\n                grid.add(ion)\n        return grid.shift(DOWN + LEFT)"
  },
  {
    "text": "from manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = self.create_atom_grid(5, 5)\n        # Animate the grid\n        self.play(Create(grid))\n        # Wait for two seconds\n        self.wait(2)\n    \n    def create_atom_circle(self, label: str, atom_color: str, label_color: str = WHITE):\n        circle = Circle(radius=0.3, color=atom_color, fill_opacity=1)\n        text = Tex(label, color=label_color).scale(0.7)\n        return VGroup(circle, text)\n    \n    def create_atom_grid(self, rows: int, cols: int):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom = self.create_atom_circle(\"H\", RED_B)\n                else:\n                    atom = self.create_atom_circle(\"He\", BLUE_B)\n                atom.move_to(np.array([i - rows // 2, j - cols // 2, 0]))\n                grid.add(atom)\n        return grid\n\nclass ElectronOrbit(Scene):\n    def construct(self):\n        # Create a proton\n        proton = self.create_atom_circle(\"+\", RED_A)\n        # Create an electron\n        electron = self.create_atom_circle(\"-\", BLUE_D)\n        # Create an orbit\n        orbit = self.create_orbit()\n        # Position electron at a specific point on the orbit\n        electron.move_to(orbit.points[0])\n\n        # Animate the proton, electron and its orbit\n        self.play(FadeIn(proton), Create(orbit))\n        self.play(FadeIn(electron))\n        # Electron orbits around the proton\n        self.play(MoveAlongPath(electron, orbit, rate_func=linear, run_time=5))\n        # Wait for two seconds\n        self.wait(2)\n\n    def create_atom_circle(self, label: str, atom_color: str):\n        circle = Circle(radius=0.2, color=atom_color, fill_opacity=1)\n        text = Tex(label, color=WHITE).scale(0.5)\n        return VGroup(circle, text)\n    \n    def create_orbit(self):\n        orbit = Ellipse(width=3, height=1.5, color=WHITE).shift(DOWN*0.5)\n        return orbit"
  },
  {
    "text": "from manim import *\n\nclass OscillatingCircleScene(Scene):\n    def construct(self):\n        circle = Circle(color=BLUE).scale(2)\n        oscillation_path = ParametricFunction(\n            lambda t: np.array([np.sin(t), np.cos(2 * t), 0]),\n            t_min=0,\n            t_max=TAU,\n            color=YELLOW\n        )\n\n        self.play(Create(oscillation_path), run_time=2)\n        self.play(ShowCreation(circle), run_time=2)\n        self.play(MoveAlongPath(circle, oscillation_path, rate_func=linear), run_time=4)\n        self.play(FadeOut(circle), FadeOut(oscillation_path), run_time=2)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Mobject):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=0.2, color=WHITE)\n        self.text = Tex(\"H\", color=BLACK, font_size=36)\n        self.add(self.circle, self.text)\n\n\nclass WaterScene(Scene):\n    def construct(self):\n        oxygen = Circle(radius=0.3, color=BLUE)\n        oxygen_text = Tex(r\"O\", color=WHITE, font_size=36)\n        oxygen_group = VGroup(oxygen, oxygen_text)\n\n        hydrogen1 = Hydrogen()\n        hydrogen1.shift(UP + LEFT)\n\n        hydrogen2 = Hydrogen()\n        hydrogen2.shift(UP + RIGHT)\n\n        molecule = VGroup(oxygen_group, hydrogen1, hydrogen2)\n\n        self.play(FadeIn(molecule))\n        self.wait(1)\n\n        self.play(molecule.animate.scale(2))\n        self.wait(1)\n\n        self.play(molecule.animate.scale(0.5))\n        self.wait(1)\n\n        self.play(FadeOut(molecule))"
  },
  {
    "text": "from manim import *\n\nclass HydrogenGrid(Scene):\n    def construct(self):\n        h_grid = self.create_hydrogen_grid(5, 7)\n        self.play(ShowCreation(h_grid))\n        self.wait(2)\n\n    def create_hydrogen_grid(self, rows: int, cols: int, scale=1.5) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                hydrogen_atom = self.hydrogen(i % 2 == 0).shift(RIGHT * i * scale + UP * j * scale)\n                grid.add(hydrogen_atom)\n        return grid\n\n    def hydrogen(self, isotope: bool) -> Mobject:\n        text = \"D\" if isotope else \"H\"\n        subscript = \"2\" if isotope else \"1\"\n        return Circle(color=BLUE_E).set_stroke(WHITE, 2).set_fill(GREEN_SCREEN, opacity=0.5)\\\n            .surround(Tex(f\"{text}_{{{subscript}}}$^+$\", color=WHITE))\n\nclass ElectronTransition(Scene):\n    def construct(self):\n        electron = Circle(color=YELLOW).scale(0.2)\n        electron.set_fill(YELLOW, opacity=0.8)\n        self.play(ShowCreation(electron))\n        path = Arc(radius=2, start_angle=-TAU/4, angle=-TAU/2)\n        self.play(MoveAlongPath(electron, path), run_time=2, rate_func=there_and_back) \n        self.wait(1) \n\nclass Proton(Scene):\n    def construct(self):\n        proton = Circle(color=RED_E).scale(0.5)\n        proton.set_fill(RED_E, opacity=1)\n        proton_text = Tex(\"p$^+$\", color=WHITE).scale(1.5)\n        proton_group = VGroup(proton, proton_text)\n        self.play(FadeIn(proton_group))\n        self.wait(2)\n        self.play(proton_group.animate.shift(UP*2), run_time=1.5)\n        self.play(proton_group.animate.shift(DOWN*2), run_time=1.5)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBond(Scene):\n    def construct(self):\n        # Create a hydrogen atom\n        hydrogen = self.create_atom(\"H\", WHITE, 0.2, font_size=24)\n        # Create a chlorine atom\n        chlorine = self.create_atom(\"Cl\", GREEN, 0.25, font_size=24)\n        # Arrange the atoms in space\n        hydrogen.next_to(chlorine, LEFT, buff=1.5)\n        # Create a bond between atoms\n        bond = Line(hydrogen.get_right(), chlorine.get_left(), color=GREY)\n\n        # Group the atoms and the bond\n        molecule = VGroup(hydrogen, chlorine, bond)\n\n        # Show the molecule components with some animations\n        self.play(FadeIn(hydrogen), FadeIn(chlorine), GrowFromCenter(bond))\n        self.wait(1)\n\n        # Move the entire molecule to the center of the scene\n        self.play(molecule.animate.move_to(ORIGIN))\n        self.wait(1)\n\n    def create_atom(self, element_symbol, color, radius, font_size=20):\n        atom = Circle(radius=radius, color=color)\n        atom.set_stroke(color=color, width=2)\n        atom.set_fill(color, opacity=0.5)\n\n        symbol = Tex(element_symbol, color=color, font_size=font_size)\n        \n        return VGroup(atom, symbol)"
  },
  {
    "text": "from manim import *\n\nclass Atom(Scene):\n    def construct(self):\n        proton = Circle(color=RED, fill_opacity=0.5)\n        proton_text = Tex('p$^+$', color=WHITE)\n        proton_group = VGroup(proton, proton_text)\n\n        neutron = Circle(color=BLUE, fill_opacity=0.5)\n        neutron_text = Tex('n$^0$', color=WHITE)\n        neutron_group = VGroup(neutron, neutron_text)\n\n        electron = Circle(radius=0.1, color=WHITE).shift(DOWN)\n        electron_text = Tex('e$^-$', color=WHITE).scale(0.5).move_to(electron.get_center())\n        electron_group = VGroup(electron, electron_text)\n\n        nucleus = VGroup(proton_group, neutron_group).arrange(buff=0.1)\n\n        self.play(Create(nucleus))\n        self.play(nucleus.animate.scale(0.8).to_edge(UP))\n        self.play(Create(electron_group))\n        self.play(electron_group.animate.rotate(PI / 2).shift(UP * 2 + RIGHT * 2))\n\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass MainScene(Scene):\n    def construct(self):\n        grid = self.create_ion_grid(5, 5)\n        self.play(Create(grid))\n        self.wait()\n\n        path = self.create_complex_path()\n        electron_obj = electron()\n        self.play(Create(electron_obj))\n        self.wait()\n\n        animations = move_along_complex_path(\n            obj=electron_obj,\n            stop_indices=[1, 3],\n            points=path,\n            run_time=2\n        )\n        self.play(*animations)\n        self.wait()\n\n    def create_complex_path(self):\n        points = [\n            LEFT * 3,\n            UP * 2,\n            RIGHT * 4 + UP * 2,\n            RIGHT * 4 + DOWN * 3,\n            LEFT * 3 + DOWN * 3,\n            ORIGIN\n        ]\n        return points\n\n    def create_ion_grid(self, rows, cols):\n        grid = VGroup(*[\n            Circle(radius=0.2, color=BLUE if (i+j) % 2 == 0 else RED).move_to([i - rows//2, j - cols//2, 0])\n            for i in range(rows) for j in range(cols)\n        ])\n        return grid\n\n# Helper Functions\ndef electron():\n    electron_circle = Circle(radius=0.15, color=YELLOW_D).set_opacity(1).set_fill(YELLOW_D)\n    electron_text = Tex(\"e$^-$\", color=BLACK, font_size=24)\n    return VGroup(electron_circle, electron_text).set_z_index(1)\n\ndef move_along_complex_path(obj, stop_indices, points, run_time, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for path in paths:\n        animations.append(MoveAlongPath(obj, path, run_time=run_time / len(paths), rate_func=rate_func))\n    \n    return animations\n"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBondAnimation(Scene):\n    def construct(self):\n        # Create oxygen and hydrogen elements\n        oxygen_atom = self.create_oxygen_atom()\n        hydrogen_atom = self.create_hydrogen_atom()\n\n        # Position the atoms on screen\n        oxygen_atom.to_edge(UP)\n        hydrogen_atom.next_to(oxygen_atom, DOWN, buff=1)\n\n        # Display atoms\n        self.play(Create(oxygen_atom), Create(hydrogen_atom))\n        self.wait(1)\n\n        # Animate electron transfer from hydrogen to oxygen\n        electron = hydrogen_atom.submobjects[1].copy()\n        self.play(electron.animate.move_to(oxygen_atom.submobjects[1].get_center()))\n        self.wait(1)\n\n        # Transform into a water molecule\n        water_molecule = self.create_water_molecule()\n        water_molecule.move_to(ORIGIN)\n        self.play(Transform(VGroup(oxygen_atom, hydrogen_atom, electron), water_molecule))\n        self.wait(2)\n\n    def create_oxygen_atom(self):\n        oxygen_core = Circle(color=BLUE, fill_opacity=1).scale(0.5)\n        oxygen_label = Text(\"O\", color=WHITE).scale(0.8)\n        oxygen_atom = VGroup(oxygen_core, oxygen_label)\n        return oxygen_atom\n\n    def create_hydrogen_atom(self):\n        hydrogen_core = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        hydrogen_label = Text(\"H\", color=WHITE).scale(0.5)\n        hydrogen_electron = Dot(color=RED).scale(0.2)\n        hydrogen_atom = VGroup(hydrogen_core, hydrogen_electron, hydrogen_label)\n        hydrogen_atom.arrange(RIGHT, center=False, buff=0.1)\n        return hydrogen_atom\n\n    def create_water_molecule(self):\n        # Create water molecule components\n        oxygen_core = Circle(color=BLUE, fill_opacity=1).scale(0.5)\n        hydrogen_core_left = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        hydrogen_core_right = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        bonding_electron = Dot(color=RED).scale(0.2)\n\n        # Position components to form water molecule\n        water_molecule = VGroup(oxygen_core, hydrogen_core_left, hydrogen_core_right, bonding_electron)\n        hydrogen_core_left.next_to(oxygen_core, DL, buff=0.2)\n        hydrogen_core_right.next_to(oxygen_core, DR, buff=0.2)\n        bonding_electron.move_to(oxygen_core.get_center())\n\n        return water_molecule\n"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        # Create reactants\n        reactant1 = oxygen().shift(LEFT * 2)\n        reactant2 = metal().shift(RIGHT * 2)\n        \n        # Create products\n        product1 = electron().shift(LEFT * 2 + DOWN * 2)\n        product2 = positive().shift(RIGHT * 2 + DOWN * 2)\n        \n        # Create plus and arrow symbols\n        plus = Tex(\"+\").shift(UP * 0.5)\n        arrow = Tex(r\"\\rightarrow\").next_to(plus, DOWN)\n        \n        # Group elements\n        reactants = VGroup(reactant1, plus, reactant2)\n        products = VGroup(product1, arrow, product2)\n        \n        # Animate the chemical reaction\n        self.play(FadeIn(reactants))\n        self.wait(1)\n        self.play(Transform(reactants, products))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBonding(Scene):\n    def construct(self):\n        # Create Oxygen and Metal objects\n        oxygen_atom = oxygen()\n        metal_atom = metal()\n        # Position Oxygen and Metal\n        oxygen_atom.to_edge(UP)\n        metal_atom.next_to(oxygen_atom, DOWN)\n\n        # Create Bonds\n        bond_up = Line(oxygen_atom.get_bottom(), metal_atom.get_top())\n        bond_down = Line(metal_atom.get_bottom(), metal_atom.get_bottom() + DOWN * 0.5)\n\n        # Group objects\n        molecule = VGroup(oxygen_atom, metal_atom, bond_up)\n\n        # Display molecule\n        self.play(Create(molecule))\n        self.wait(1)\n\n        # Display bond_down\n        self.play(Create(bond_down))\n        self.wait(1)\n\n        # Move molecule around\n        self.play(molecule.animate.shift(RIGHT * 2), run_time=2)\n        self.play(molecule.animate.shift(LEFT * 2), run_time=2)\n\n        # Grow from Center\n        electron_particle = electron()\n        self.play(GrowFromCenter(electron_particle))\n        self.wait(1)\n\n        # Fade out all objects\n        self.play(FadeOut(molecule), FadeOut(bond_down), FadeOut(electron_particle))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass HydrogenGridScene(Scene):\n    def construct(self):\n        grid = self.create_hydrogen_grid(5, 5)\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n    def create_hydrogen_grid(self, rows: int, cols: int) -> VGroup:\n        group = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                hydrogen = self.create_hydrogen().move_to(np.array([i - rows // 2, j - cols // 2, 0]))\n                group.add(hydrogen)\n        return group\n\n    def create_hydrogen(self) -> Mobject:\n        return Circle(radius=0.2, color=WHITE).set_fill(color=WHITE, opacity=0.5).add(\n            Tex('H').set_color(BLACK).scale(0.5)\n        )"
  },
  {
    "text": "from manim import *\n\nclass HydrogenMolecule(VGroup):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.add(hydrogen_atom())\n        self.add(hydrogen_atom().next_to(self[0], RIGHT, buff=0.5))\n        self.add(Bond(self[0], self[1]))\n\ndef hydrogen_atom() -> Mobject:\n    return circle_with_text(0.2, \"H\", WHITE, 24, BLACK, 1, WHITE)\n\nclass Bond(Line):\n    def __init__(self, start_mobj, end_mobj, **kwargs):\n        start = start_mobj.get_center()\n        end = end_mobj.get_center()\n        super().__init__(start, end, buff=start_mobj.width/2, **kwargs)\n\nclass HydrogenMoleculeScene(Scene):\n    def construct(self):\n        molecule = HydrogenMolecule()\n        self.play(Create(molecule))\n        self.wait()\n\n        # Let's make the molecule move in a square path\n        square_path = [UP, RIGHT, DOWN, LEFT]\n        path_points = [molecule.get_center() + dir * 2 for dir in square_path]\n        path_points.append(molecule.get_center())  # Closing the loop\n\n        animations = move_along_complex_path(molecule, [3], path_points, run_time=4)\n        self.play(*animations)\n        self.wait()\n\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time / len(paths), rate_func=rate_func))\n\n    return animations"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        grid = self.create_ionic_grid(3, 3)\n        self.play(Create(grid))\n        self.wait()\n        ion_path = self.generate_ion_path(grid)\n        lithium_ion_obj = lithium_ion()\n        self.play(FadeIn(lithium_ion_obj))\n        ion_animations = move_along_complex_path(lithium_ion_obj, [1, 3], ion_path, run_time=2)\n        self.play(*ion_animations)\n        self.wait(2)\n\n    def create_ionic_grid(self, rows: int, cols: int) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    ion = oxygen().shift(RIGHT * j + UP * i)\n                else:\n                    ion = metal().shift(RIGHT * j + UP * i)\n                grid.add(ion)\n        grid.move_to(ORIGIN)\n        return grid\n    \n    def generate_ion_path(self, grid: VGroup) -> List[Point]:\n        # Starting from the center of the grid, create a complex path\n        path_points = []\n        center = grid.get_center()\n        path_points.append(center)\n        offset = RIGHT + UP\n\n        for _ in range(4):\n            new_point = center + offset\n            path_points.append(new_point)\n            center = new_point\n            offset.rotate(PI/2)\n        \n        return path_points\n\n# Helper function as defined in user's sample code\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color=color, stroke_width=stroke_width).set_fill(fill_color, opacity=1)\n    t = Tex(txt, font_size=font_size, color=font_color).set_z_index(1)\n    return VGroup(c, t)\n\n# Other helper functions would be included as they are from the user's sample\ndef oxygen() -> Mobject:\n    # function definition from user's sample\n\ndef metal() -> Mobject:\n    # function definition from user's sample\n\ndef lithium_ion() -> Mobject:\n    # function definition from user's sample\n\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    # function definition from user's sample\n\n# Other Manim scene construction would continue as usual..."
  },
  {
    "text": "from manim import *\n\nclass SceneWithMovingCharge(Scene):\n    def construct(self):\n        # Create an electron Mobject\n        electron_obj = electron()\n        # Set initial position of the electron\n        electron_obj.move_to(LEFT * 4)\n\n        # Define complex path points for the electron\n        path_points = [\n            LEFT * 4, LEFT * 3 + UP * 2, LEFT * 2 + UP * 4,\n            LEFT + UP * 2, ORIGIN, RIGHT + DOWN * 2,\n            RIGHT * 2 + DOWN * 4, RIGHT * 3 + DOWN * 2, RIGHT * 4\n        ]\n\n        # Call move_along_complex_path to get animations for the electron\n        electron_animations = move_along_complex_path(\n            electron_obj, stop_indices=[2, 5], points=path_points, run_time=2\n        )\n\n        # Add electron to the scene and play the animations\n        self.add(electron_obj)\n        self.play(*electron_animations)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of alternating electrons and oxygen atoms\n        grid = self.create_alternating_grid(rows=5, cols=5)\n        \n        # Position the grid\n        grid.move_to(ORIGIN)\n        \n        # Animate the creation of the grid\n        self.play(AnimationGroup(*[FadeIn(mobj, shift=UP*0.1) for mobj in grid], lag_ratio=0.1))\n        self.wait()\n\n        # Animate electrons moving in a pattern on the grid\n        path_indices = [0, 5, 6, 11, 16, 17, 22, 23, 18, 13, 8, 7, 2, 3, 4, 9, 14, 19, 24, 20, 15, 10]\n        electrons = self.get_electrons_on_grid(grid)\n        # Define the complex path for our electron to move along\n        points = [grid[i].get_center() for i in path_indices]\n        \n        # Create the move animations for the electron\n        move_animations = move_along_complex_path(electrons, stop_indices=[], points=points, run_time=2)\n        self.play(AnimationGroup(*move_animations, lag_ratio=0))\n        self.wait()\n\n    def create_alternating_grid(self, rows, cols):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    grid.add(electron().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n                else:\n                    grid.add(oxygen().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n        return grid\n    \n    def get_electrons_on_grid(self, grid):\n        electrons = VGroup()\n        for atom in grid:\n            if \"e$^-$\" in atom.submobjects[1].get_tex_string():\n                electrons.add(atom)\n        return electrons\n\n# Additional functions used within the code may be identical to the functions provided by the user, e.g., 'electron()' and 'oxygen()' functions."
  },
  {
    "text": "from manim import *\n\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n\n        # Create an oxygen atom\n        o_atom = oxygen()\n\n        # Create a metallic atom\n        metal_atom = metal()\n\n        # Create a positive ion\n        pos_ion = positive()\n\n        # Create a negative ion\n        negative_ion = negative()\n\n        # Create a metal oxide grid\n        metal_oxide_grid = metal_oxid(3, 3)\n        \n        # Create a carbon layer\n        c_layer = carbon_layer()\n\n        # Create a complex moving electron\n        electron_path = [LEFT * 3, LEFT * 2 + UP * 2, RIGHT * 2 + UP * 2, RIGHT * 3]\n        stop_indices = [1, 2]  # Stop at the first and second index positions\n        complex_move = move_along_complex_path(e.copy(), stop_indices, electron_path, run_time=2)\n\n        # Arrange atoms in a grid\n        atoms_group = VGroup(e, o_atom, metal_atom, pos_ion, negative_ion).arrange_in_grid(1, 5, buff=1)\n\n        # Animate all elements\n        self.play(LaggedStart(*[FadeIn(atom) for atom in atoms_group], lag_ratio=0.5))\n        self.wait(1)\n        self.play(Transform(atoms_group, metal_oxide_grid))\n        self.wait(1)\n        self.play(Transform(atoms_group, c_layer))\n        self.wait(1)\n        self.play(*complex_move)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create Molecules\n        reactant1 = oxygen()\n        reactant2 = lithium_ion()\n        product = metal_oxid(2, 3)\n\n        # Position Molecules\n        reactant1.shift(LEFT * 2)\n        reactant2.shift(RIGHT * 2)\n        product.move_to(ORIGIN)\n\n        # Animate reaction\n        self.play(FadeIn(reactant1), FadeIn(reactant2))\n        self.wait(1)\n        self.play(Transform(reactant1, product), Transform(reactant2, product))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electrons(atom)\n        self.play(FadeIn(atom))\n        self.play(*[FadeIn(e) for e in electrons])\n        self.play(*[Rotate(e, angle=2*PI, about_point=atom.get_center()) for e in electrons])\n        self.wait(2)\n    \n    def create_atom(self) -> Mobject:\n        proton = Circle(radius=0.2, stroke_color=RED, fill_color=RED, fill_opacity=1)\n        neutron = Circle(radius=0.2, stroke_color=BLUE, fill_color=BLUE, fill_opacity=1)\n        nucleus = VGroup(proton, neutron).arrange(RIGHT, buff=0.1)\n        return nucleus\n\n    def create_electrons(self, nucleus: Mobject) -> List[Mobject]:\n        electrons = []\n        positions = [UP, DOWN, LEFT, RIGHT]\n        for pos in positions:\n            electron = Circle(radius=0.05, stroke_color=YELLOW, fill_color=YELLOW, fill_opacity=1)\n            electron.move_to(nucleus.get_center() + pos * 0.5)\n            electrons.append(electron)\n        return electrons\n"
  },
  {
    "text": "from manim import *\n\nclass HydrogenGridScene(Scene):\n    def construct(self):\n        grid = self.hydrogen_grid(3, 3)\n        self.play(ShowCreation(grid))\n        self.wait(1)\n\n    def hydrogen_atom(self) -> Mobject:\n        return circle_with_text(0.2, \"H\", RED_B, 20, BLACK, 1, RED_B)\n\n    def hydrogen_grid(self, rows: int, cols: int) -> Mobject:\n        list_of_atoms = []\n        for i in range(rows):\n            for j in range(cols):\n                atom = self.hydrogen_atom().shift(RIGHT * i + UP * j)\n                list_of_atoms.append(atom)\n        return VGroup(*list_of_atoms)\n\n    def circle_with_text(\n        self, r: float, txt: str, color=WHITE, font_size: int = 20, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        circle_obj = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n        text_obj = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(circle_obj, text_obj)"
  },
  {
    "text": "from manim import *\n\nclass MoleculeScene(Scene):\n    def construct(self):\n        # Adding hydrogen molecule\n        molecule = self.create_molecule()\n        self.play(FadeIn(molecule))\n        self.wait()\n\n        # Moving molecule in a zigzag path\n        points = [UP * 2, UP * 2 + RIGHT * 4, DOWN * 2, DOWN * 2 + LEFT * 4]\n        path_animations = move_along_complex_path(molecule, [1, 2], points, run_time=4)\n        self.play(*path_animations)\n        self.wait()\n\n    def create_molecule(self):\n        # Create atoms\n        hydrogen_1 = circle_with_text(0.3, 'H', WHITE, 24, BLACK, 1, RED_A).shift(LEFT)\n        hydrogen_2 = circle_with_text(0.3, 'H', WHITE, 24, BLACK, 1, BLUE_A).shift(RIGHT)\n\n        # Create bond\n        bond = Line(hydrogen_1.get_center(), hydrogen_2.get_center(), color=GREY_B)\n\n        # Create molecule out of atoms and bond\n        molecule = VGroup(hydrogen_1, hydrogen_2, bond)\n        return molecule\n\n# Example function from the provided code\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\n# Example function from the provided code\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n    return animations\n\n# To view the animation, uncomment the following line:\n# if __name__ == '__main__':\n#     scene = MoleculeScene()\n#     scene.render()"
  },
  {
    "text": "from manim import *\n\n\nclass Hydrogen(Scene):\n    def construct(self):\n        proton = self.proton()\n        electron = self.electron()\n        self.add(VGroup(proton, electron))\n\n    def proton(self) -> Mobject:\n        return self.circle_with_text(0.25, \"H$^+$\", RED_B, 25, WHITE, 1, RED_B)\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(0.15, \"e$^-$\", BLUE_D, 24, BLACK, 1, BLUE_D)\n        \n    def circle_with_text(self, r: int, txt: str, color=BLACK, font_size: int=10, font_color=BLACK, stroke_width: int=2, fill_color=BLACK) -> Mobject:\n        c = Circle(r, color=color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_atom = oxygen()\n        metal_atom = metal()\n        positive_ion = positive()\n        negative_ion = negative()\n        metal_oxide_structure = metal_oxid(4, 4)\n        lithium_ion_structure = lithium_grid(3, 3)\n        carbon_structure = carbon_grid(2)\n\n        self.play(Create(electron_particle))\n        self.play(electron_particle.animate.move_to(RIGHT * 2 + UP * 1))\n        self.wait()\n\n        self.play(Transform(electron_particle, oxygen_atom))\n        self.wait()\n\n        self.play(Transform(electron_particle, metal_atom))\n        self.play(electron_particle.animate.move_to(LEFT * 2 + UP * 1))\n        self.wait()\n\n        self.play(Transform(electron_particle, positive_ion))\n        self.play(ReplacementTransform(electron_particle, negative_ion))\n        self.wait(1)\n\n        self.play(FadeIn(metal_oxide_structure))\n        self.wait(2)\n\n        self.play(FadeOut(metal_oxide_structure), FadeIn(lithium_ion_structure))\n        self.wait(2)\n\n        self.play(ReplacementTransform(lithium_ion_structure, carbon_structure))\n        self.wait(2)\n\n        self.play(FadeOut(carbon_structure))\n        self.wait(1)\n\n        self.play(electron_particle.animate.move_to(ORIGIN))\n        self.play(GrowFromCenter(electron_particle))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n\nclass WaterScene(Scene):\n    def construct(self):\n        water_molecule = self.create_water_molecule()\n        self.play(Create(water_molecule))\n        self.wait(2)\n\n    def create_water_molecule(self) -> VGroup:\n        oxygen = Circle(color=BLUE, fill_opacity=1).scale(0.5).set_fill(BLUE)\n        hydrogen_1 = Circle(color=WHITE, fill_opacity=1).scale(0.2).shift(UP * 0.3 + RIGHT * 0.5)\n        hydrogen_2 = Circle(color=WHITE, fill_opacity=1).scale(0.2).shift(DOWN * 0.3 + RIGHT * 0.5)\n\n        bond_1 = Line(oxygen.get_center(), hydrogen_1.get_center(), color=GREY)\n        bond_2 = Line(oxygen.get_center(), hydrogen_2.get_center(), color=GREY)\n\n        water_molecule = VGroup(oxygen, hydrogen_1, hydrogen_2, bond_1, bond_2)\n        water_molecule.move_to(ORIGIN)\n\n        return water_molecule\n"
  },
  {
    "text": "from manim import *\n\nclass ChemicalElementScene(Scene):\n    def construct(self):\n        # Create an Oxygen atom using a predefined method from the example\n        oxygen_atom = oxygen()\n        \n        # Create a Carbon atom using a predefined method from the example\n        carbon_atom = carbon()\n        \n        # Set new positions for the atoms\n        oxygen_atom.to_edge(UP)\n        carbon_atom.to_edge(DOWN)\n        \n        # Create electron movement around Oxygen\n        electron_obj = electron()\n        electron_obj.move_to(oxygen_atom)\n        electron_movement = self.electron_orbit(oxygen_atom, electron_obj, 1, True)\n        \n        # Show everything on the screen\n        self.play(AnimationGroup(Create(oxygen_atom), Create(carbon_atom), *electron_movement, lag_ratio=0.5))\n        self.wait(2)\n        \n    def electron_orbit(self, around: Mobject, obj: Mobject, run_time: float, clockwise: bool = False) -> list[Animation]:\n        # Creating the orbit path\n        path = Circle(radius=0.5)\n        path.move_to(around)\n        \n        # Creating the Rotate animation for the electron\n        direction = 1 if clockwise else -1\n        electron_orbit_animation = Rotating(obj, radians=direction * TAU, about_point=around.get_center(), run_time=run_time, rate_func=smooth)\n\n        # Align electron to start from the rightmost side of the atom\n        obj.move_to(path.point_from_proportion(0))\n        \n        return [electron_orbit_animation]"
  },
  {
    "text": "from manim import *\n\nclass WaterMoleculeScene(Scene):\n    def construct(self):\n        # Define the positions of hydrogen and oxygen atoms\n        oxygen_position = ORIGIN\n        hydrogen_position1 = UP + RIGHT\n        hydrogen_position2 = UP + LEFT\n        \n        # Create water molecule components\n        oxygen_atom = self.create_oxygen(oxygen_position)\n        hydrogen_atom1 = self.create_hydrogen(hydrogen_position1)\n        hydrogen_atom2 = self.create_hydrogen(hydrogen_position2)\n        \n        # Create bonding lines\n        bond1 = Line(oxygen_position, hydrogen_position1, color=WHITE)\n        bond2 = Line(oxygen_position, hydrogen_position2, color=WHITE)\n\n        # Combine all components into a water molecule group\n        water_molecule = VGroup(oxygen_atom, hydrogen_atom1, hydrogen_atom2, bond1, bond2)\n        \n        # Show the molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(ApplyMethod(water_molecule.scale, 2))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))\n        \n    def create_oxygen(self, position):\n        # Create an oxygen atom with a red circle and \"O\" text in the center\n        oxygen_circle = Circle(radius=0.5, color=RED).set_fill(RED, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE, font_size=30)\n        oxygen_atom = VGroup(oxygen_circle, oxygen_text).move_to(position)\n        return oxygen_atom\n        \n    def create_hydrogen(self, position):\n        # Create a hydrogen atom with a blue circle and \"H\" text in the center\n        hydrogen_circle = Circle(radius=0.3, color=BLUE).set_fill(BLUE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=WHITE, font_size=20)\n        hydrogen_atom = VGroup(hydrogen_circle, hydrogen_text).move_to(position)\n        return hydrogen_atom\n"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        self.add(Text(\"Chemical Reaction Simulation\").shift(UP * 3))\n\n        # Create electron, oxygen and metal objects\n        e = electron()\n        o = oxygen()\n        m = metal()\n\n        # Position the objects on the screen\n        e.move_to(LEFT * 4)\n        o.move_to(LEFT * 2)\n        m.move_to(RIGHT * 2)\n\n        # Display the objects with animations\n        self.play(FadeIn(e))\n        self.play(FadeIn(o))\n        self.play(FadeIn(m))\n        self.wait(1)\n\n        # Run a reaction animation\n        self.play(e.animate.move_to(o.get_center()))\n        self.play(ReplacementTransform(e, o))\n        self.wait(0.5)\n\n        # Move metal closer to oxygen\n        self.play(m.animate.move_to(o.get_center()))\n        self.wait(0.5)\n\n        # Bond the metal and oxygen together to create a metal oxide\n        mo = VGroup(m, o)\n        self.play(ReplacementTransform(VGroup(m, o), mo))\n        self.wait(1)\n\n        # Creating a lattice structure of metal oxide\n        lattice = metal_oxid(3, 3)\n        self.play(Transform(mo, lattice))\n        self.wait(2)\n\n        # Conclude the scene\n        self.play(FadeOut(mo))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\n\nclass AtomicStructure(Scene):\n    def construct(self):\n        # Create elements for the atomic structure\n        nucleus = self.create_nucleus()\n        electron_orbit = self.create_electron_orbit()\n\n        # Position elements\n        nucleus.move_to(ORIGIN)\n        electron_orbit.move_to(nucleus.get_center())\n\n        # Create electron and define its motion\n        electron = electron().move_to(electron_orbit.point_from_proportion(0))\n        electron_motion = self.create_electron_motion(electron, electron_orbit)\n\n        # Animate elements\n        self.play(FadeIn(nucleus, scale=0.5), FadeIn(electron_orbit, scale=0.5))\n        self.wait(1)\n        self.play(*electron_motion)\n        self.wait(2)\n\n    def create_nucleus(self):\n        nucleus = VGroup()\n        # Create protons and neutrons for the nucleus\n        protons = VGroup(*[positive().next_to(ORIGIN, direction, buff=SMALL_BUFF) for direction in [UP, LEFT]])\n        neutrons = VGroup(*[neutral().next_to(ORIGIN, direction, buff=SMALL_BUFF) for direction in [DOWN, RIGHT]])\n        \n        # Add the protons and neutrons to the nucleus\n        nucleus.add(protons, neutrons)\n        return nucleus\n\n    def create_electron_orbit(self, radius=1.5):\n        orbit = Circle(radius=radius, color=BLUE_D, opacity=0.5)\n        return orbit\n\n    def create_electron_motion(self, electron, orbit):\n        electron_motion = Rotate(electron, angle=2*PI, about_point=orbit.get_center())\n        return electron_motion\n\ndef positive() -> Mobject:\n    return circle_with_text(0.2, \"+\", RED, 28, WHITE, 4, RED)\n\ndef neutral() -> Mobject:\n    return circle_with_text(0.2, \"n\", GREY_BROWN, 28, WHITE, 4, GREY_BROWN)"
  },
  {
    "text": "from manim import *\n\nclass HydrogenGrid(Scene):\n    def construct(self):\n        rows, cols = 5, 6\n        hydrogen_grid = VGroup(*[self.hydrogen_atom().move_to([j - rows//2, i - cols//2, 0]) \n                                 for i in range(rows) for j in range(cols)])\n        self.add(hydrogen_grid)\n    \n    def hydrogen_atom(self) -> Mobject:\n        electron = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=1)\n        proton = Circle(radius=0.15, color=RED).set_fill(RED, opacity=1)\n        text_e = Text(\"e-\", color=WHITE, font_size=18).move_to(electron.get_center())\n        text_p = Text(\"p+\", color=WHITE, font_size=18).move_to(proton.get_center())\n        return VGroup(electron, text_e, proton, text_p).arrange(RIGHT, buff=0.25)\n"
  },
  {
    "text": "from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        electron_particle = self.create_electron()\n        self.play(FadeIn(electron_particle))\n        self.wait()\n        self.play(ApplyMethod(electron_particle.shift, UP * 2))\n        self.wait()\n        \n    def create_electron(self) -> Mobject:\n        return Circle(radius=0.15, color=YELLOW_D).add(Tex(\"e$^-$\", color=BLACK).scale(0.5)).move_to(ORIGIN)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n        self.play(FadeIn(e))\n        self.wait(1)\n\n        # Move the electron around in a circle\n        circle_path = Circle(radius=1.0)\n        self.play(MoveAlongPath(e, circle_path), run_time=2, rate_func=smooth)\n        self.wait(1)\n\n        # Create a grid of metal and oxygen\n        grid = metal_oxid(rows=3, cols=3, scale=2)\n        self.play(FadeIn(grid))\n        self.wait(1)\n\n        # Transition from metal_oxid to carbon_grid\n        carbon_grid_mobject = carbon_grid(rows=2)\n        self.play(ReplacementTransform(grid, carbon_grid_mobject))\n        self.wait(1)\n\n        # Create and move a lithium ion along a complex path\n        li_ion = lithium_ion()\n        self.play(FadeIn(li_ion))\n\n        # Example of complex path\n        complex_path_points = [UP + LEFT, UP + RIGHT, DOWN + RIGHT, DOWN + LEFT]\n        complex_path_animations = move_along_complex_path(li_ion, [2], complex_path_points, run_time=1)\n\n        for anim in complex_path_animations:\n            self.play(anim)\n        \n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        # Create a grid of metal and oxygen\n        grid = self.metal_oxid(4, 4)\n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Animate an electron moving along a complex path\n        electron_particle = self.electron()\n        self.add(electron_particle)\n        complex_path = [\n            UP * 2 + LEFT * 2,\n            UP * 2 + RIGHT * 2,\n            DOWN * 2 + RIGHT * 2,\n            DOWN * 2 + LEFT * 2,\n            UP * 2 + LEFT * 2,\n        ]\n        animations = self.move_along_complex_path(electron_particle, [0, 3], complex_path, run_time=2)\n        self.play(*animations)\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(grid), FadeOut(electron_particle))\n\n    def electron(self) -> Mobject:\n        return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    list.append(self.oxygen().move_to(np.array([i, j, 0]) / scale))\n                else:\n                    list.append(self.metal().move_to(np.array([i, j, 0]) / scale))\n        return VGroup(*list)\n\n    def oxygen(self) -> Mobject:\n        o_atom = circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1)\n        o_atom.set_z_index(1)\n        return o_atom\n\n    def metal(self) -> Mobject:\n        co_atom = circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n        co_atom.set_z_index(1)\n        return co_atom\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1], color=WHITE).set_opacity(0.5))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time / len(paths), rate_func=rate_func))\n            if i in stop_indices:\n                animations.append(AnimationGroup(Wait(run_time / len(paths))))\n\n        return animations\n\ndef circle_with_text(\n    r: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    c = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBondingScene(Scene):\n    def construct(self):\n        # Create Oxygen and Hydrogen molecules\n        o2_molecule = self.create_o2_molecule()\n        h2_molecule_1 = self.create_h2_molecule().shift(LEFT * 3)\n        h2_molecule_2 = self.create_h2_molecule().shift(RIGHT * 3)\n\n        # Display O2 and two H2 molecules\n        self.play(FadeIn(o2_molecule), FadeIn(h2_molecule_1), FadeIn(h2_molecule_2))\n        self.wait(2)\n\n        # Move H2 molecules towards O2 and form H2O molecules\n        h2o_molecule_1, h2o_molecule_2 = self.create_h2o_molecules()\n        self.play(Transform(h2_molecule_1, h2o_molecule_1))\n        self.play(Transform(h2_molecule_2, h2o_molecule_2.shift(RIGHT * 3)))\n        self.wait(2)\n\n    def create_o2_molecule(self):\n        o_atom_1 = self.create_atom(\"O\", color=RED_E)\n        o_atom_2 = self.create_atom(\"O\", color=RED_E)\n        bond = Line(o_atom_1.get_right(), o_atom_2.get_left()).set_stroke(width=2)\n        o2_molecule = VGroup(o_atom_1, bond, o_atom_2).arrange(buff=0.2)\n        return o2_molecule\n\n    def create_h2_molecule(self):\n        h_atom_1 = self.create_atom(\"H\", color=BLUE)\n        h_atom_2 = self.create_atom(\"H\", color=BLUE)\n        bond = Line(h_atom_1.get_right(), h_atom_2.get_left()).set_stroke(width=2)\n        h2_molecule = VGroup(h_atom_1, bond, h_atom_2).arrange(buff=0.1)\n        return h2_molecule\n\n    def create_h2o_molecules(self):\n        h_atom_1 = self.create_atom(\"H\", color=BLUE)\n        o_atom = self.create_atom(\"O\", color=RED_E)\n        h_atom_2 = self.create_atom(\"H\", color=BLUE)\n        bond_1 = Line(h_atom_1.get_right(), o_atom.get_left()).set_stroke(width=2)\n        bond_2 = Line(h_atom_2.get_right(), o_atom.get_bottom()).set_stroke(width=2)\n        h2o_molecule_1 = VGroup(h_atom_1, bond_1, o_atom).arrange(buff=0.1)\n        h2o_molecule_2 = VGroup(o_atom, bond_2, h_atom_2).arrange(buff=0.1, aligned_edge=DOWN)\n        return h2o_molecule_1, h2o_molecule_2\n\n    def create_atom(self, text, color):\n        atom = Circle(radius=0.5, color=color, fill_opacity=1)\n        symbol = Tex(text, color=WHITE).scale(0.8)\n        return VGroup(atom, symbol)"
  },
  {
    "text": "from manim import *\n\nclass CreateMolecules(Scene):\n    def construct(self):\n        molecule = VGroup(\n            oxygen().shift(LEFT * 2),\n            electron().next_to(oxygen(), UP),\n            metal().shift(RIGHT * 2),\n            positive().next_to(metal(), UP),\n            negative().next_to(electron(), RIGHT * 2),\n        )\n\n        self.play(Create(oxygen()))\n        self.play(Create(electron()))\n        self.play(Create(metal()))\n        self.play(Create(positive()))\n        self.play(Create(negative()))\n        self.play(FadeIn(molecule))\n        self.wait()\n\n        grid = metal_oxid(3, 3)\n        self.play(ReplacementTransform(molecule, grid))\n        self.wait()\n\n        carbon_struct = carbon_grid(3)\n        self.play(Transform(grid, carbon_struct))\n        self.wait()\n\n        self.play(grid.animate.scale(0.5).to_corner(UL))\n\n        electron_path = [LEFT, LEFT + UP, UP, RIGHT + UP, RIGHT, RIGHT + DOWN, DOWN, LEFT + DOWN]\n        self.play(*move_along_complex_path(electron(), [0, 2, 4, 6], electron_path, run_time=3, rate_func=smooth))\n\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with one proton and one electron\n        electron_group = self.create_electron()\n        proton = self.create_proton()\n\n        # Create a hydrogen molecule (H2) by adding a second hydrogen atom\n        hydrogen_molecule = VGroup(proton, electron_group).arrange(RIGHT, buff=1)\n        second_hydrogen = hydrogen_molecule.copy().next_to(hydrogen_molecule, RIGHT, buff=0.2)\n        \n        # Combine the individual hydrogen atoms to form a molecule group\n        h2_molecule_group = VGroup(hydrogen_molecule, second_hydrogen)\n\n        # Show the construction of hydrogen molecule\n        self.play(Write(proton))\n        self.play(FadeIn(electron_group))\n        self.play(h2_molecule_group.animate.shift(LEFT*0.6))\n        self.play(FadeIn(second_hydrogen))\n        self.play(h2_molecule_group.animate.scale(0.8).move_to(ORIGIN))\n\n        self.wait(2)\n\n    # Helper function to create an electron\n    def create_electron(self):\n        electron_circle = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        electron = Tex('e$^-$', color=WHITE, font_size=20).move_to(electron_circle.get_center())\n        return VGroup(electron_circle, electron)\n\n    # Helper function to create a proton\n    def create_proton(self):\n        proton_circle = Circle(radius=0.2, color=RED).set_fill(RED, opacity=0.5)\n        proton = Tex('p$^+$', color=WHITE, font_size=20).move_to(proton_circle.get_center())\n        return VGroup(proton_circle, proton)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        rows, cols = 5, 5\n        grid = VGroup()\n        for i in range(rows):\n            row = VGroup()\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom = carbon() if (j % 3 == 0) else oxygen()\n                else:\n                    atom = metal() if (i % 3 == 0) else electron()\n                atom.shift(RIGHT * j + UP * i)\n                row.add(atom)\n            grid.add(row)\n        grid.center()\n\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        electron_particle = electron()\n        self.play(FadeIn(electron_particle))\n\n        path = VMobject()\n        path_points = [\n            UP * 2 + LEFT * 2, UP * 2, UP * 2 + RIGHT * 2, RIGHT * 2,\n            DOWN * 2 + RIGHT * 2, DOWN * 2, DOWN * 2 + LEFT * 2, LEFT * 2, ORIGIN\n        ]\n        path.set_points_as_corners(path_points)\n\n        self.play(MoveAlongPath(electron_particle, path, run_time=5, rate_func=linear))\n\n        self.wait(2)\n        self.play(FadeOut(grid), FadeOut(electron_particle))"
  },
  {
    "text": "from manim import *\n\nclass SimpleMoleculeScene(Scene):\n    def construct(self):\n        electron_m = electron()\n        oxygen_m = oxygen()\n        metal_m = metal()\n        positive_m = positive()\n        negative_m = negative()\n        \n        # Position Mobjects\n        electron_m.shift(LEFT * 2)\n        oxygen_m.next_to(electron_m, RIGHT, buff=1.5)\n        metal_m.next_to(oxygen_m, RIGHT, buff=1.5)\n        positive_m.next_to(metal_m, RIGHT, buff=1.5)\n        negative_m.next_to(positive_m, RIGHT, buff=1.5)\n\n        molecule_group = VGroup(electron_m, oxygen_m, metal_m, positive_m, negative_m)\n\n        # Animate Mobjects\n        self.play(Write(molecule_group))\n        self.wait(1)\n\n        # Move electron around the oxygen atom\n        self.play(*move_along_complex_path(electron_m, [], [UP * 1.5 + LEFT * 2,\n                                                            UP * 1.5 + RIGHT * 0.5,\n                                                            DOWN * 1.5 + RIGHT * 0.5,\n                                                            DOWN * 1.5 + LEFT * 2], run_time=4))\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass ChargeTransferScene(Scene):\n    def construct(self):\n        # Creating an electron, a lithium ion, and a metal atom\n        e = electron()\n        li = lithium_ion()\n        m = metal()\n\n        # Positioning the objects on screen\n        e.move_to(LEFT * 2)\n        li.move_to(ORIGIN)\n        m.move_to(RIGHT * 2)\n\n        # Moving the electron to the lithium ion\n        electron_transfer = move_along_complex_path(\n            obj=e, \n            stop_indices=[0, 2], \n            points=[e.get_center(), li.get_center(), m.get_center()], \n            run_time=2\n        )\n\n        # Moving the lithium ion to the metal atom\n        lithium_transfer = move_along_complex_path(\n            obj=li, \n            stop_indices=[0, 2], \n            points=[li.get_center(), m.get_center(), e.get_center()],\n            run_time=2\n        )\n\n        # Playing the animations of charge transfer\n        self.play(*electron_transfer)\n        self.play(*lithium_transfer)\n\n        # Creating a grid of metal_oxid\n        grid = metal_oxid(rows=3, cols=3)\n\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(e, li, m, grid)))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=1)\n        electron_pair = electron()\n        carbon_molecule = carbon_layer()\n\n        self.play(AnimationGroup(\n            FadeIn(oxygen_molecule),\n            FadeIn(electron_pair, shift=DOWN),\n            FadeIn(carbon_molecule, shift=UP),\n            lag_ratio=0.5\n        ))\n        self.wait(1)\n\n        path = ArcBetweenPoints(oxygen_molecule[0].get_center(), carbon_molecule.get_center(), angle=-TAU/4)\n        self.play(MoveAlongPath(electron_pair, path), run_time=2)\n        self.wait(1)\n\n        reaction_product = VGroup(oxygen_molecule, carbon_molecule, electron_pair).arrange(DOWN)\n\n        self.play(TransformMatchingShapes(VGroup(oxygen_molecule, electron_pair, carbon_molecule), reaction_product))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        # Create grid of lithium ions\n        li_grid = self.lithium_grid(3, 3)\n\n        # Create a single carbon layer\n        carbon_l = self.carbon_layer()\n\n        # Create a molecule of oxygen and a metal\n        oxy = self.oxygen().shift(LEFT * 2)\n        met = self.metal().shift(RIGHT * 2)\n\n        # Animate the objects\n        self.play(FadeIn(li_grid))\n        self.wait(1)\n        self.play(Transform(li_grid, carbon_l))\n        self.wait(1)\n        self.play(FadeIn(oxy), FadeIn(met))\n        self.wait(2)\n\n        # Move the oxygen in a triangle path\n        tri_points = [UP * 2 + LEFT, UP * 2, UP * 2 + RIGHT]\n        oxy_animations = self.move_along_complex_path(oxy, [1], tri_points, run_time=3)\n        self.play(*oxy_animations)\n\n        self.wait(3)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n        return animations\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def carbon_layer(self) -> Mobject:\n        list = []\n        positions = [\n            [-1.2, 0, 0],\n            [-0.45, 0.4, 0],\n            [0.45, 0.4, 0],\n            [1.2, 0, 0],\n            [0.55, -0.3, 0],\n            [-0.55, -0.3, 0],\n        ]\n        small = [2, 1, 1, 2, 0, 0]\n        for i in range(len(positions)):\n            list.append(Line(positions[i], positions[(i + 1) % len(positions)], color=GREY_B).set_z_index(4))\n            list.append(self.carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n        list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n        return VGroup(*list)\n\n    def lithium_ion(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def carbon(self, small: int = False) -> Mobject:\n        return self.circle_with_text(\n            0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n            \"C\",\n            GRAY_B,\n            30 if small == 0 else (24 if small == 1 else 27),\n            WHITE,\n            1,\n        ).set_z_index(5 if small == 1 else 10)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of metal oxide cells\n        mo_grid = self.metal_oxid(3, 3)\n        self.add(mo_grid)\n\n        # Animate an electron moving along a complex path\n        electron_obj = self.electron()\n        self.add(electron_obj)\n        complex_path = [\n            LEFT * 2 + UP * 2,\n            RIGHT * 2 + UP * 2,\n            RIGHT * 2 + DOWN * 2,\n            LEFT * 2 + DOWN * 2,\n            ORIGIN\n        ]\n        electron_animations = self.move_along_complex_path(\n            electron_obj, [2, 4], complex_path, run_time=5\n        )\n        self.play(AnimationGroup(*electron_animations, lag_ratio=0.5))\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(radius=r, color=color).set_opacity(1).set_fill(color=fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    list.append(self.oxygen().move_to([i / scale, j / scale, 0]))\n                else:\n                    list.append(self.metal().move_to([i / scale, j / scale, 0]))\n        return VGroup(*list)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for path in paths:\n            animations.append(MoveAlongPath(obj, path, run_time=run_time/len(paths), rate_func=rate_func))\n\n        return animations"
  },
  {
    "text": "from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n        # Create an oxygen molecule\n        o2 = oxygen()\n        # Create a metal atom\n        metal_atom = metal()\n        # Create a positive ion\n        pos_ion = positive()\n        # Create a negative ion\n        neg_ion = negative()\n        # Create a metal oxide grid\n        metal_oxide_grid = metal_oxid(rows=3, cols=3)\n        # Create a lithium grid\n        li_grid = lithium_grid(rows=3, cols=3)\n        # Create a carbon grid\n        c_grid = carbon_grid(rows=3)\n        \n        # Creating and adding several elements to the scene\n        self.add(e)\n        self.add(o2.move_to(UP * 2))\n        self.add(metal_atom.move_to(UP * 2 + RIGHT * 2))\n        self.add(pos_ion.move_to(UP * 2 + RIGHT * 4))\n        self.add(neg_ion.move_to(UP * 2 + LEFT * 2))\n        self.add(metal_oxide_grid.move_to(DOWN * 2))\n        self.add(li_grid.move_to(DOWN * 2 + RIGHT * 4))\n        self.add(c_grid.move_to(DOWN * 2 + LEFT * 4))"
  },
  {
    "text": "from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        grid = metal_oxid(3, 3)\n        self.add(grid)\n\n        electron_particle = electron()\n        self.add(electron_particle)\n\n        path_points = [UP * 2 + LEFT * 2, UP * 2 + RIGHT * 2, DOWN * 2 + RIGHT * 2, DOWN * 2 + LEFT * 2, UP * 2 + LEFT * 2]\n        stop_indices = [1, 3]\n        run_time = 2\n\n        animations = move_along_complex_path(electron_particle, stop_indices, path_points, run_time)\n        self.play(AnimationGroup(*animations, lag_ratio=1))"
  },
  {
    "text": "from manim import *\n\nclass WaterFormation(Scene):\n    def construct(self):\n        # Create hydrogen atoms\n        h1 = self.create_hydrogen_atom().to_edge(UP + LEFT)\n        h2 = self.create_hydrogen_atom().to_edge(UP + RIGHT)\n        \n        # Create oxygen atom\n        o = self.create_oxygen_atom().to_edge(DOWN)\n        \n        # Animate the formation of water by moving hydrogen atoms to oxygen\n        self.play(\n            h1.animate.move_to(o.get_center() + np.array([-1, 1, 0])),\n            h2.animate.move_to(o.get_center() + np.array([1, 1, 0])),\n            run_time=3\n        )\n\n        # Group atoms to a single water molecule\n        water_molecule = VGroup(h1, o, h2)\n        \n        # Show the formation of the water molecule\n        self.play(\n            Rotate(water_molecule, PI), \n            water_molecule.animate.scale(0.5).move_to(ORIGIN), \n            run_time=3\n        )\n        \n        # Keep the molecule on screen\n        self.wait(2)\n    \n    def create_hydrogen_atom(self):\n        # Creates a hydrogen atom with a plus sign\n        proton = Circle(color=BLUE, fill_opacity=1).scale(0.2)\n        plus = Tex(\"+\").move_to(proton.get_center())\n        return VGroup(proton, plus)\n    \n    def create_oxygen_atom(self):\n        # Creates an oxygen atom with an O\n        electron_cloud = Circle(color=RED, fill_opacity=1).scale(0.5)\n        oxygen_text = Tex(\"O\").move_to(electron_cloud.get_center()).set_color(WHITE)\n        return VGroup(electron_cloud, oxygen_text)"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with an electron orbiting around it\n        proton = self.create_proton()\n        electron = self.create_electron()\n\n        orbit = Circle(color=BLUE).scale(0.5)\n        orbit.move_to(proton)\n\n        electron.move_to(orbit.point_from_proportion(0))\n        self.play(FadeIn(proton), FadeIn(orbit), FadeIn(electron))\n        self.play(Rotate(electron, angle=2*PI, about_point=proton.get_center()), run_time=2, rate_func=smooth)\n        self.wait()\n\n    def create_proton(self) -> Mobject:\n        # Proton represented by a circle with a 'P+'\n        return Circle(radius=0.15, color=RED).set_fill(RED, opacity=1).add(\n            Tex(\"P$^+$\", color=WHITE).scale(0.7)\n        )\n\n    def create_electron(self) -> Mobject:\n        # Electron represented by a small dot\n        return Dot(radius=0.05, color=WHITE)\n\n# Additional function to animate the electron along a custom path\ndef electron_orbit_path(electron: Mobject, orbit: Mobject, run_time: float) -> Animation:\n    def update_electron(mob, dt):\n        mob.move_to(orbit.point_from_proportion((mob.time_elapsed / run_time) % 1))\n        mob.time_elapsed += dt\n\n    electron.time_elapsed = 0\n    return UpdateFromFunc(electron, update_electron)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBondAnimation(Scene):\n    def construct(self):\n        # Create two oxygen atoms\n        oxygen_1 = oxygen().shift(LEFT)\n        oxygen_2 = oxygen().shift(RIGHT)\n\n        # Create an electron\n        e = electron()\n\n        # Animations\n        self.play(FadeIn(oxygen_1), FadeIn(oxygen_2))\n        self.play(e.animate.move_to(oxygen_1))\n        self.wait(0.5)\n        self.play(e.animate.move_to(oxygen_2))\n        self.wait(0.5)\n\n        # Bond creation\n        bond = Line(oxygen_1.get_center(), oxygen_2.get_center(), color=GRAY)\n        self.play(Create(bond))\n\n        # Group oxygen and bond together\n        molecule = VGroup(oxygen_1, oxygen_2, bond)\n\n        # Show the shifting of the molecule\n        self.play(molecule.animate.shift(UP * 2))\n        self.play(molecule.animate.scale(0.5).rotate(PI / 2))\n        self.wait(1)\n\n        # Disappear the molecule\n        self.play(FadeOut(molecule))"
  },
  {
    "text": "from manim import *\n\nclass AtomDistribution(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        atom_grid = self.create_atom_grid(5, 5)\n        # Animate the creation of the atom grid\n        self.play(Create(atom_grid))\n        # Show the scene\n        self.wait(2)\n\n    def atom_element(self, symbol: str, color: Color, text_color: Color) -> Mobject:\n        # Create a circle with element symbol text inside\n        atom_circle = Circle(radius=0.5, color=color).set_opacity(1).set_fill(color)\n        atom_text = Tex(symbol, color=text_color).scale(1.5)\n        atom = VGroup(atom_circle, atom_text)\n        return atom\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        # Initialize empty list to hold atoms\n        atom_list = []\n        # Loop to populate the list with atoms\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.atom_element(\"Cl\", GREEN, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n                else:\n                    atom_list.append(self.atom_element(\"Na\", ORANGE, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n        # Create a group with all atoms\n        atom_group = VGroup(*atom_list)\n        return atom_group"
  },
  {
    "text": "from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create a group of molecules in a grid\n        molecule_group = self.create_molecule_grid(rows=4, cols=4)\n        # Animate the group of molecules\n        self.play(FadeIn(molecule_group, shift=UP))\n        self.wait(1)\n        self.play(Rotate(molecule_group, angle=PI/2))\n        self.wait(1)\n        self.play(FadeOut(molecule_group, shift=DOWN))\n\n    def hydrogen_molecule(self) -> Mobject:\n        # Create a group of two hydrogen atoms\n        left_hydrogen = circle_with_text(0.25, \"H\", color=BLUE, font_size=24, font_color=WHITE, stroke_width=1, fill_color=BLUE)\n        right_hydrogen = circle_with_text(0.25, \"H\", color=BLUE, font_size=24, font_color=WHITE, stroke_width=1, fill_color=BLUE)\n        right_hydrogen.next_to(left_hydrogen, RIGHT, buff=0.5)\n        bond = Line(left_hydrogen.get_center(), right_hydrogen.get_center()).set_stroke(width=2)\n        return VGroup(left_hydrogen, bond, right_hydrogen)\n\n    def create_molecule_grid(self, rows: int, cols: int) -> VGroup:\n        # Create a grid of hydrogen molecules\n        molecule_group = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                molecule = self.hydrogen_molecule()\n                molecule.move_to(np.array([i - rows / 2, j - cols / 2, 0]))\n                molecule_group.add(molecule)\n        return molecule_group\n    \n    def circle_with_text(self, r: float, txt: str, color=WHITE, font_size: int = 24, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE) -> Mobject:\n        # Create a circle with text in the center\n        c = Circle(radius=r, color=color)\n        c.set_fill(color=fill_color, opacity=1)\n        c.set_stroke(color=color, width=stroke_width)\n        t = Text(txt, font_size=font_size, color=font_color)\n        t.move_to(c.get_center())\n        return VGroup(c, t)"
  },
  {
    "text": "from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Creating atoms\n        hydrogen_atom = self.create_atom(\"H\", WHITE, 0.1)\n        carbon_atom = self.create_atom(\"C\", BLUE_E, 0.2)\n        nitrogen_atom = self.create_atom(\"N\", GREEN_E, 0.2)\n        oxygen_atom = self.create_atom(\"O\", RED_E, 0.2)\n\n        # Positioning atoms\n        molecule = VGroup(hydrogen_atom, carbon_atom, nitrogen_atom, oxygen_atom)\n        molecule.arrange_in_grid(rows=2, cols=2, buff=1)\n\n        # Animating creation of atoms\n        self.play(AnimationGroup(\n            FadeIn(hydrogen_atom, shift=UP*0.5),\n            FadeIn(carbon_atom, shift=DOWN*0.5),\n            FadeIn(nitrogen_atom, shift=LEFT*0.5),\n            FadeIn(oxygen_atom, shift=RIGHT*0.5),\n            lag_ratio=0.5\n        ))\n        \n        # Rotate the molecule\n        self.play(Rotate(molecule, angle=PI/2))\n        \n        # Wait for 2 seconds\n        self.wait(2)\n\n    def create_atom(self, symbol, color, radius):\n        # Create an atom with a symbol inside a circle\n        atom_circle = Circle(radius=radius, color=color)\n        atom_symbol = Tex(symbol, color=color)\n        atom = VGroup(atom_circle, atom_symbol)\n        return atom\n"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        self.add(hydrogen_atom())\n\ndef hydrogen_atom() -> Mobject:\n    electron_layer = Circle(radius=1, color=BLUE).set_opacity(0.5)\n    nucleus = Dot(radius=0.1, color=RED_A).shift(ORIGIN)\n\n    electron = Dot(radius=0.05, color=WHITE)\n    electron.set_z_index(1)\n\n    orbit = electron_layer.copy().set_fill(opacity=0)\n    electron.move_to(orbit.point_from_proportion(0))\n\n    circle_group = VGroup(orbit, electron, nucleus)\n\n    def update_electron(mob, dt):\n        rate = dt * 0.1  # revolutions per second\n        mob.move_to(orbit.point_from_proportion((mob.get_center()[0]+rate) % 1))\n\n    electron.add_updater(update_electron)\n\n    return VGroup(circle_group)\n\ndef hydrogen_migration(scene: Scene, electron_path: Arc, run_time: float):\n    hydrogen = hydrogen_atom()\n    scene.play(ShowCreation(hydrogen))\n    scene.wait(1)\n\n    electron = hydrogen[0][1]\n    hydrogen.remove(electron)  # We'll animate the electron separately\n\n    def update_pos(mob, alpha):\n        mob.move_to(electron_path.point_from_proportion(alpha))\n\n    scene.play(\n        UpdateFromAlphaFunc(electron, update_pos),\n        MoveAlongPath(hydrogen, electron_path),\n        run_time=run_time,\n        rate_func=linear\n    )\n    scene.play(FadeOut(hydrogen), FadeOut(electron))"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create a reactant molecule\n        reactant = VGroup(electron(), metal(), oxygen())\n        reactant.arrange(RIGHT, buff=0.3)\n        reactant.to_edge(UP)\n        \n        # Create a product molecule\n        product = VGroup(metal_oxid(2, 2), electron())\n        product.arrange(RIGHT, buff=0.3)\n        product.to_edge(DOWN)\n        \n        # Create arrows for the reaction\n        arrow = Arrow(reactant.get_bottom(), product.get_top(), buff=0.1)\n        \n        # Add reactant, arrow, and product to the scene\n        self.add(reactant, arrow, product)\n        \n        # Animate reactant and product changing color to show reaction\n        self.play(reactant.animate.set_color(GREEN), product.animate.set_color(ORANGE))\n        \n        # Wait to observe the scene\n        self.wait(2)\n        \n        # Animate the reformation of the original reactant\n        self.play(Uncreate(product), Uncreate(arrow), reactant.animate.move_to(ORIGIN))\n        \n        # Wait to observe the final scene\n        self.wait()"
  },
  {
    "text": "from manim import *\n\n\nclass ChemicalStructureScene(Scene):\n    def construct(self):\n        # Display the title\n        title = Tex(\"Chemical Structure Example\").to_edge(UP)\n        self.add(title)\n\n        # Create a grid of oxygen and metal\n        grid = self.create_metal_oxid_grid(3, 3)\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        # Create electron\n        electron_obj = electron()\n        electron_obj.next_to(grid, DOWN)\n\n        # Create lithium ion near the grid\n        lithium_ion = lithium_ion()\n        lithium_ion.next_to(grid, LEFT)\n\n        # Animate electron path around the grid\n        electron_path = self.get_electron_path(grid)\n        electron_animations = move_along_complex_path(electron_obj, [], electron_path, run_time=5)\n        self.play(*electron_animations)\n        self.wait(2)\n\n        # Arrange some lithium ions at the bottom\n        lithium_row = VGroup(*[lithium_ion.copy() for _ in range(5)])\n        lithium_row.arrange(RIGHT, buff=0.5)\n        lithium_row.next_to(grid, DOWN, buff=1)\n        self.play(FadeIn(lithium_row))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(grid, electron_obj, lithium_ion, lithium_row)))\n        self.wait()\n\n    def create_metal_oxid_grid(self, rows, cols):\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                element = oxygen() if (j + i) % 2 == 0 else metal()\n                element.move_to(np.array([2 * i, 2 * j, 0]))\n                list.append(element)\n        grid = VGroup(*list)\n        grid.move_to(ORIGIN)\n        return grid\n\n    def get_electron_path(self, grid):\n        path_points = [point.get_center() for point in grid]\n        # Create a looped path that goes through the points of the grid\n        path_points.append(path_points[0])\n        return path_points\n\n# To display the scene, save this code into a Python file and\n# run it with Manim, or use it within a Jupyter Notebook cell."
  },
  {
    "text": "from manim import *_x000D_\n_x000D_\n_x000D_\nclass ChemicalReactionsScene(Scene):_x000D_\n    def construct(self):_x000D_\n        oxygen_molecule = self.create_oxygen_molecule()_x000D_\n        electron = electron()_x000D_\n        electron_path = self.get_electron_path(oxygen_molecule)_x000D_\n_x000D_\n        self.play(Create(oxygen_molecule))_x000D_\n        self.play(*move_along_complex_path(electron, [2, 5], electron_path, 2))_x000D_\n        self.play(FadeOut(oxygen_molecule), FadeOut(electron))_x000D_\n_x000D_\n    def create_oxygen_molecule(self) -> Mobject:_x000D_\n        oxygen_atom_1 = oxygen().shift(LEFT)_x000D_\n        oxygen_atom_2 = oxygen().shift(RIGHT)_x000D_\n        bond = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center())_x000D_\n        return VGroup(oxygen_atom_1, oxygen_atom_2, bond)_x000D_\n_x000D_\n    def get_electron_path(self, molecule: Mobject) -> List:_x000D_\n        path_points = [_x000D_\n            molecule.get_left() + LEFT,_x000D_\n            molecule.get_top() + UP,_x000D_\n            molecule.get_right() + RIGHT,_x000D_\n            molecule.get_bottom() + DOWN_x000D_\n        ]_x000D_\n        return path_points_x000D_\n_x000D_\n_x000D_\ndef oxygen() -> Mobject:_x000D_\n    list = []_x000D_\n    for angle in (0, PI / 2, PI, (3 * PI) / 2):_x000D_\n        start = 0.3 * np.array([np.cos(angle), np.sin(angle), 0])_x000D_\n        end = 0.6 * np.array([np.cos(angle), np.sin(angle), 0])_x000D_\n        list.append(Line(start=start, end=end).set_opacity(0.7))_x000D_\n    return VGroup(circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)_x000D_\n_x000D_\n_x000D_\ndef circle_with_text(_x000D_\n    r: int, txt: str, color=BLACK, font_size: int = 10,_x000D_\n    font_color=BLACK, stroke_width: int = 2, fill_color=BLACK_x000D_\n) -> Mobject:_x000D_\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)_x000D_\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)_x000D_\n    return VGroup(c, t)_x000D_\n_x000D_\n_x000D_\ndef electron() -> Mobject:_x000D_\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)_x000D_\n_x000D_\n_x000D_\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):_x000D_\n    animations = []_x000D_\n    paths = []_x000D_\n    for i in range(len(points) - 1):_x000D_\n        if i not in stop_indices:_x000D_\n            paths.append(Line(points[i], points[i + 1]))_x000D_\n_x000D_\n    for i in range(len(paths)):_x000D_\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))_x000D_\n_x000D_\n    return animations"
  },
  {
    "text": "from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        proton = self.create_particle(\"p^+\", color=RED, size=0.2, label_size=24, label_color=WHITE)\n        neutron = self.create_particle(\"n^0\", color=BLUE, size=0.2, label_size=24, label_color=WHITE)\n        electron = self.create_particle(\"e^-\", color=YELLOW, size=0.1, label_size=18, label_color=BLACK)\n\n        self.play(FadeIn(proton))\n        self.wait(0.5)\n\n        self.play(proton.animate.shift(LEFT))\n        self.play(FadeIn(neutron.next_to(proton, RIGHT)), FadeIn(electron.next_to(proton, UP)))\n        self.wait(0.5)\n\n        self.play(electron.animate.orbit(proton, ellipse=True, run_time=2))\n        self.wait(1)\n\n        self.play(FadeOut(VGroup(proton, neutron, electron)))\n        \n    def create_particle(self, label, color, size, label_size, label_color):\n        particle_circle = Circle(radius=size, color=color, fill_opacity=1)\n        particle_label = Tex(label).scale(label_size).set_color(label_color)\n        \n        particle = VGroup(particle_circle, particle_label)\n        return particle\n    \n    def orbit(self, obj, about=None, ellipse=False, run_time=1):\n        if about is None:\n            about = self.plane.c2p(0, 0)\n        path = Ellipse() if ellipse else Circle()\n        \n        self.play(MoveAlongPath(obj, path, run_time=run_time))\n        "
  },
  {
    "text": "from manim import *\n\nclass MagnetScene(Scene):\n    def construct(self):\n        magnet = self.create_magnet()\n        magnetic_field_lines = self.create_magnetic_field_lines()\n        \n        self.play(Create(magnet))\n        self.wait(1)\n        \n        self.play(AnimationGroup(*[Create(line) for line in magnetic_field_lines], lag_ratio=0.1))\n        self.wait(2)\n\n    def create_magnet(self) -> Mobject:\n        red_pole = Rectangle(width=1, height=2, color=RED, fill_opacity=0.8).shift(LEFT * 0.5)\n        blue_pole = Rectangle(width=1, height=2, color=BLUE, fill_opacity=0.8).shift(RIGHT * 0.5)\n        magnet = VGroup(red_pole, blue_pole)\n        return magnet\n    \n    def create_magnetic_field_lines(self) -> List[Mobject]:\n        lines = []\n        for i in range(-5, 6):\n            lines.append(Arc(start_angle=-TAU/4, angle=TAU/2, radius=abs(i) + 0.5).shift(DOWN * i * 0.2))\n        return lines\n\nclass FlowingElectronScene(Scene):\n    def construct(self):\n        electron_group = VGroup(*[self.create_electron() for _ in range(5)])\n        electron_group.arrange(RIGHT, buff=1)\n        path = Line(LEFT * 4, RIGHT * 4)\n\n        self.play(Create(electron_group))\n        self.wait(1)\n\n        animations = [self.electron_flow_animation(electron, path) for electron in electron_group]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))\n        self.wait(2)\n\n    def electron_flow_animation(self, electron: Mobject, path: Mobject) -> Animation:\n        return MoveAlongPath(electron, path, run_time=5, rate_func=linear)\n\n    def create_electron(self) -> Mobject:\n        return Circle(radius=0.2, color=YELLOW).set_fill(YELLOW, opacity=0.8).add(Tex(\"e$^-$\", color=BLACK).scale(0.5))"
  },
  {
    "text": "from manim import *\n\nclass ChemicalBonding(Scene):\n    def construct(self):\n        # Create oxygen and hydrogen objects\n        oxygen = Circle(radius=0.5, color=BLUE).set_fill(BLUE, opacity=0.5)\n        hydrogen1 = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=0.5)\n        hydrogen2 = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=0.5)\n\n        # Positioning hydrogen objects on the left and right of the oxygen\n        hydrogen1.move_to(LEFT)\n        hydrogen2.move_to(RIGHT)\n\n        # Adding bond lines\n        bond1 = Line(hydrogen1.get_center(), oxygen.get_center())\n        bond2 = Line(hydrogen2.get_center(), oxygen.get_center())\n\n        # Group the molecules and bonds\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Animate creation of the water molecule\n        self.play(\n            Create(oxygen),\n            Create(hydrogen1),\n            Create(hydrogen2),\n            GrowFromCenter(bond1),\n            GrowFromCenter(bond2)\n        )\n\n        # Wait for 2 seconds\n        self.wait(2)\n\n        # Rotate the molecule\n        self.play(Rotate(water_molecule, PI), run_time=2)\n\n        # Wait for 2 seconds\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(water_molecule))\n\n        # End the scene\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        electron_cloud = Ellipse(width=2.0, height=1.2, color=BLUE).set_fill(BLUE, opacity=0.3)\n        nucleus = Dot(color=RED).scale(0.5)\n        proton = Text(\"H\", color=WHITE, font_size=36).move_to(nucleus.get_center())\n        hydrogen = VGroup(electron_cloud, nucleus, proton)\n\n        self.play(FadeIn(hydrogen))\n        self.wait()\n        self.play(hydrogen.animate.scale(2))\n        self.wait()"
  },
  {
    "text": "from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        reactant1 = electron()\n        reactant2 = oxygen()\n        product = metal_oxid(2, 3)\n\n        self.play(FadeIn(reactant1))\n        self.wait(0.5)\n        \n        self.play(Transform(reactant1, reactant2))\n        self.wait(0.5)\n        \n        self.play(Transform(reactant1, product))\n        self.wait(2)\n\n        self.play(FadeOut(reactant1))\n\n# The code provided lacks the complete structure for a manim scene.\n# You can run this scene using the Manim command line utility with the -s flag to get a still image of the final frame.\n\n# Example: `manim -pql -s your_script.py ChemicalReaction`"
  },
  {
    "text": "from manim import *\n\nclass MyScene(Scene):\n    def construct(self):\n        grid = self.create_grid(4, 5)\n        self.play(Create(grid))\n        self.wait(1)\n\n        moving_electron = electron()\n        self.play(Create(moving_electron))\n        self.play(*self.electron_movement(moving_electron, 3))\n        self.wait(2)\n\n    def electron_movement(self, electron, total_movements):\n        movements = []\n        for _ in range(total_movements):\n            movements.append(electron.animate.shift(RIGHT * 0.5))\n            movements.append(electron.animate.shift(UP * 0.5))\n        return movements\n    \n    def create_grid(self, rows, cols):\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    list.append(negative().shift(RIGHT*j + UP*i))\n                else:\n                    list.append(positive().shift(RIGHT*j + UP*i))\n        return VGroup(*list)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_particle = oxygen()\n        metal_particle = metal()\n        positive_particle = positive()\n        negative_particle = negative()\n\n        self.play(\n            FadeIn(electron_particle),\n            FadeIn(oxygen_particle),\n            FadeIn(metal_particle),\n            FadeIn(positive_particle),\n            FadeIn(negative_particle),\n        )\n\n        self.wait(1)\n\n        grid = metal_oxid(3, 3)\n        self.play(Transform(VGroup(electron_particle, oxygen_particle, metal_particle, positive_particle, negative_particle), grid))\n\n        self.wait(1)\n\n        lithium_grid_object = lithium_grid(2, 2)\n        self.play(Transform(grid, lithium_grid_object))\n\n        self.wait(1)\n\n        carbon_grid_object = carbon_grid(3)\n        self.play(Transform(lithium_grid_object, carbon_grid_object))\n\n        self.wait(1)\n\n        complex_path_points = [UP * 2, UP + RIGHT, RIGHT * 2, DOWN + RIGHT, DOWN * 2, DOWN + LEFT, LEFT * 2, UP + LEFT, UP * 2]\n        stopping_indices = [2, 5]\n\n        electron_particle.move_to(UP * 2)\n        self.play(*(move_along_complex_path(electron_particle, stopping_indices, complex_path_points, run_time=2)))\n\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass ChemicalCompoundScene(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=GREY_B).set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE).scale(1.5)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=BLACK).scale(0.8)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position hydrogen atoms around the oxygen\n        hydrogen1 = hydrogen.copy().next_to(oxygen, UP, buff=0.6)\n        hydrogen2 = hydrogen.copy().next_to(oxygen, DOWN, buff=0.6)\n\n        # Create bond lines\n        bond1 = Line(oxygen.get_top(), hydrogen1.get_center(), color=WHITE)\n        bond2 = Line(oxygen.get_bottom(), hydrogen2.get_center(), color=WHITE)\n\n        # Group together the full molecule\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Center the molecule and animate its creation\n        water_molecule.move_to(ORIGIN)\n        self.play(FadeIn(water_molecule, shift=UP), run_time=3)\n        self.wait()\n\n        # Label for the molecule\n        water_label = Tex(\"H$_2$O\", color=WHITE).next_to(water_molecule, DOWN)\n\n        # Animate the label\n        self.play(Write(water_label))\n        self.wait(2)\n\n        # Animate the dissociation of the water molecule\n        self.play(\n            FadeOut(hydrogen1),\n            FadeOut(bond1),\n            hydrogen2.shift, LEFT * 3,\n            oxygen.shift, RIGHT * 3,\n            FadeOut(bond2),\n            run_time=2\n        )\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create an Oxygen molecule\n        oxygen_molecule = self.create_oxygen_molecule()\n        # Position the oxygen molecule\n        oxygen_molecule.to_edge(UP)\n\n        # Create a Lithium ion\n        lithium_ion = self.create_lithium_ion()\n        # Position the lithium ion\n        lithium_ion.next_to(oxygen_molecule, DOWN)\n\n        # Animate the creation of the oxygen molecule and the lithium ion\n        self.play(Create(oxygen_molecule), FadeIn(lithium_ion))\n\n        # Move the lithium ion to the oxygen molecule\n        self.play(lithium_ion.animate.move_to(oxygen_molecule.get_center()))\n\n        # Combine the lithium ion with the oxygen molecule to form a compound\n        lithium_oxygen_compound = VGroup(oxygen_molecule, lithium_ion)\n        self.play(FadeIn(lithium_oxygen_compound))\n\n        # Show the final combined molecule\n        self.play(lithium_oxygen_compound.animate.scale(1.5).move_to(ORIGIN))\n\n        # Hold the final state for a while before ending the scene\n        self.wait(2)\n\n    def create_oxygen_molecule(self):\n        oxygen_left = circle_with_text(0.3, \"O\", RED, 30, WHITE, 2, RED)\n        oxygen_right = circle_with_text(0.3, \"O\", RED, 30, WHITE, 2, RED)\n        oxygen_pair = VGroup(oxygen_left, oxygen_right).arrange(buff=0.5)\n        return oxygen_pair\n\n    def create_lithium_ion(self):\n        return circle_with_text(0.2, \"Li$^+$\", GREY_B, 26, BLACK, 2, GREY_B)"
  },
  {
    "text": "from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create objects\n        co_ = self.create_co_molecule()\n        h2o = self.create_h2o_molecule()\n\n        # Position objects on the screen\n        co_.to_edge(LEFT, buff=1)\n        h2o.to_edge(RIGHT, buff=1)\n\n        # Display the molecules\n        self.play(FadeIn(co_), FadeIn(h2o))\n        self.wait(2)\n\n        # Animate movements and interactions\n        self.play(co_.animate.shift(RIGHT * 2), h2o.animate.shift(LEFT * 2))\n        self.wait(1)\n\n        # Create a reaction product\n        product = self.create_reaction_product()\n        product.move_to(ORIGIN)\n\n        # Transform molecules into the reaction product\n        self.play(Transform(VGroup(co_, h2o), product))\n        self.wait(2)\n\n    def create_co_molecule(self) -> Mobject:\n        c = Circle(radius=0.3, color=GRAY, fill_opacity=1).set_fill(GRAY)\n        c_text = Tex(r\"C\", color=WHITE).scale(0.7)\n        o = Circle(radius=0.35, color=BLUE_E, fill_opacity=1).set_fill(BLUE_E)\n        o_text = Tex(r\"O\", color=WHITE).scale(0.8)\n        o.shift(RIGHT * 0.7)\n        o_text.move_to(o.get_center())\n\n        co_molecule = VGroup(c, c_text, o, o_text)\n        return co_molecule\n\n    def create_h2o_molecule(self) -> Mobject:\n        o = Circle(radius=0.35, color=BLUE_E, fill_opacity=1).set_fill(BLUE_E)\n        o_text = Tex(r\"O\", color=WHITE).scale(0.8)\n        h_left = Circle(radius=0.2, color=WHITE, fill_opacity=1).set_fill(WHITE)\n        h_left_text = Tex(r\"H\", color=BLACK).scale(0.5)\n        h_left.shift(LEFT * 0.5 + UP * 0.3)\n        h_left_text.move_to(h_left.get_center())\n\n        h_right = Circle(radius=0.2, color=WHITE, fill_opacity=1).set_fill(WHITE)\n        h_right_text = Tex(r\"H\", color=BLACK).scale(0.5)\n        h_right.shift(RIGHT * 0.5 + UP * 0.3)\n        h_right_text.move_to(h_right.get_center())\n\n        h2o_molecule = VGroup(o, o_text, h_left, h_left_text, h_right, h_right_text)\n        return h2o_molecule\n\n    def create_reaction_product(self) -> Mobject:\n        h2co3 = Tex(r\"H$_2$CO$_3$\")\n        return h2co3"
  },
  {
    "text": "from manim import *\n\nclass CustomAnimationScene(Scene):\n    def construct(self):\n        # Create an electron\n        electron_item = electron()\n\n        # Create an oxygen atom\n        oxygen_item = oxygen()\n\n        # Create a metal atom\n        metal_item = metal()\n\n        # Create a positive ion\n        positive_item = positive()\n\n        # Create a negative ion\n        negative_item = negative()\n\n        # Arrange elements in a grid\n        grid = VGroup(electron_item, oxygen_item, metal_item, positive_item, negative_item)\n        grid.arrange_in_grid(rows=1, cols=5, buff=1.0)\n\n        # Animate the additions\n        self.play(AnimationGroup(*[FadeIn(atom) for atom in grid], lag_ratio=0.5))\n\n        # Animate movement along a complex path\n        complex_path = [UP*2, UP+RIGHT*2, DOWN+RIGHT*2, DOWN*2, LEFT*4]\n        electron_animations = move_along_complex_path(electron_item, [0, 2], complex_path, run_time=2)\n        self.play(*electron_animations)\n\n        # Fade everything out\n        self.play(FadeOut(grid))"
  },
  {
    "text": "from manim import *\n\nclass Atom(VMobject):\n    def __init__(self, label, radius=0.2, color=BLUE, label_color=WHITE, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=radius, color=color)\n        self.label = Tex(label, color=label_color).scale(0.5)\n        self.add(self.circle, self.label)\n\n    def set_label(self, new_label):\n        self.label.become(Tex(new_label).scale(0.5))\n        return self\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = VGroup()\n        for x in range(-5, 6):\n            for y in range(-3, 4):\n                atom = Atom(label=\"H\", radius=0.3, color=RED)\n                atom.move_to(x*0.6*RIGHT + y*0.6*UP)\n                grid.add(atom)\n\n        self.play(Create(grid))\n        self.wait()\n\n        # Animate the change of all atoms labels to \"He\"\n        for atom in grid:\n            self.play(atom.set_label(\"He\"), run_time=0.1)\n        self.wait()"
  },
  {
    "text": "from manim import *_x000D_\nimport numpy as np_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FullyConnectedLayer_x000D_\n_x000D_\nconfig.pixel_height = 720_x000D_\nconfig.pixel_width = 1280_x000D_\nconfig.frame_height = 6.0_x000D_\nconfig.frame_width = 6.0_x000D_\n_x000D_\nclass SimpleNNVisualization(Scene):_x000D_\n    def construct(self):_x000D_\n        # Random input data generation_x000D_\n        input_data = np.random.rand(10, 3) * 0.1_x000D_\n_x000D_\n        # Define the layers of the neural network_x000D_\n        neural_net_layers = [_x000D_\n            FullyConnectedLayer(_x000D_\n                input_neurons=3,_x000D_\n                output_neurons=4,_x000D_\n                neuron_radius=0.15,_x000D_\n                layer_height=2.5_x000D_\n            ),_x000D_\n            FullyConnectedLayer(_x000D_\n                input_neurons=4,_x000D_\n                output_neurons=2,_x000D_\n                neuron_radius=0.15,_x000D_\n                layer_height=2.5_x000D_\n            ),_x000D_\n        ]_x000D_\n_x000D_\n        # Create the neural network object_x000D_\n        neural_network = NeuralNetwork(_x000D_\n            input_data=input_data,_x000D_\n            layers=neural_net_layers,_x000D_\n            spacing=0.3_x000D_\n        )_x000D_\n_x000D_\n        # Position the neural network on the screen_x000D_\n        neural_network.to_edge(LEFT, buff=0.75)_x000D_\n_x000D_\n        # Neural Network Animation_x000D_\n        animation = neural_network.get_edge_propagation_animation(run_time=2)_x000D_\n_x000D_\n        # Add neural network to the scene_x000D_\n        self.add(neural_network)_x000D_\n_x000D_\n        # Play the animation_x000D_\n        self.play(animation)_x000D_\n_x000D_\n        # Wait for a second after the animation has finished_x000D_\n        self.wait(1)"
  },
  {
    "text": "from manim import Scene, Create_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\n_x000D_\nclass FeedForwardNeuralNetworkScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Define a feedforward neural network_x000D_\n        feedforward_nn = NeuralNetwork([_x000D_\n            FeedForwardLayer(4),_x000D_\n            FeedForwardLayer(6, activation_function=\"ReLU\"),_x000D_\n            FeedForwardLayer(3, activation_function=\"Softmax\")_x000D_\n        ])_x000D_\n_x000D_\n        # Display the neural network_x000D_\n        self.play(Create(feedforward_nn))_x000D_\n_x000D_\n        # Animate a forward pass through the network_x000D_\n        forward_pass_animation = feedforward_nn.make_forward_pass_animation()_x000D_\n        self.play(forward_pass_animation)"
  },
  {
    "text": "from manim import *\nimport numpy as np\nfrom manim_ml.neural_network.layers import *\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\n\nROOT_DIR = Path(__file__).parent\n\nclass NeuralNetworkScene(MovingCameraScene):\n    def construct(self):\n        # Load image and convert to numpy array\n        image_path = ROOT_DIR / \"assets/mnist/sample_digit.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n        \n        # Define a simple neural network\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=2),\n            Convolutional2DLayer(\n                num_feature_maps=1,\n                feature_map_size=5,\n                filter_size=3,\n                padding=1,\n                stride=1,\n            ),\n            MaxPoolingLayer(\n                pool_size=2,\n                stride=2,\n            ),\n            FlattenLayer(),\n            FeedForwardLayer(10),\n        ])\n        \n        # Animation: Show neural network layers and perform forward pass\n        self.play(Create(nn))\n        self.wait(1)\n        forward_pass_animation = nn.make_forward_pass_animation()\n        self.play(forward_pass_animation)\n        self.wait(1)"
  },
  {
    "text": "from manim import Scene, VGroup_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\nfrom manim_ml.neural_network.animations import TrainNeuralNetwork_x000D_\n_x000D_\nclass TrainNNAnimation(Scene):_x000D_\n    def construct(self):_x000D_\n        layers = [_x000D_\n            FeedForwardLayer(4, stroke_width=2),_x000D_\n            FeedForwardLayer(7, stroke_width=2, fill_opacity=0.5),_x000D_\n            FeedForwardLayer(4, stroke_width=2)_x000D_\n        ]_x000D_\n_x000D_\n        neural_network = NeuralNetwork(layers, neuron_spacing=0.15)_x000D_\n        neural_network.center()_x000D_\n_x000D_\n        data_points = VGroup(_x000D_\n            *[_x000D_\n                neural_network.get_random_neuron_position(layer_index=0)_x000D_\n                for _ in range(5)_x000D_\n            ]_x000D_\n        )_x000D_\n_x000D_\n        training_animation = TrainNeuralNetwork(neural_network, data_points)_x000D_\n_x000D_\n        self.add(neural_network)_x000D_\n        self.play(training_animation)_x000D_\n        self.wait()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define the layers of the neural network\n        layers = [\n            FeedForwardLayer(20, neuron_radius=0.15, stroke_width=3.0),\n            FeedForwardLayer(10, neuron_radius=0.15, stroke_width=3.0),\n            FeedForwardLayer(5, neuron_radius=0.15, stroke_width=3.0),\n        ]\n\n        # Create the neural network\n        neural_network = NeuralNetwork(layers, layer_spacing=0.3)\n\n        # Position the neural network in the center\n        neural_network.move_to(ORIGIN)\n\n        # Create animation for each layer to fade in sequentially\n        layer_animations = [\n            FadeIn(layer, shift=UP, rate_func=linear)\n            for layer in neural_network.layers\n        ]\n\n        # Play the layer animations\n        self.play(AnimationGroup(*layer_animations, lag_ratio=1))\n\n        # Create forward pass animation for the neural network\n        forward_pass = neural_network.make_forward_pass_animation(rate_func=linear)\n\n        # Play the forward pass animation\n        self.play(forward_pass)\n\n        # Hold the final image for a couple seconds before exiting\n        self.wait(2)\n"
  },
  {
    "text": "from manim import *\n\nclass SigmoidNeuron(VGroup):\n    def __init__(self, position, neuron_radius=0.2, color=BLUE, **kwargs):\n        super().__init__(**kwargs)\n        self.neuron_circle = Circle(radius=neuron_radius, color=color)\n        self.neuron_circle.move_to(position)\n        self.activation_text = MathTex(r'\\sigma').scale(0.5).move_to(self.neuron_circle.get_center())\n        self.add(self.neuron_circle, self.activation_text)\n\n    def get_activation_animation(self):\n        activation = ApplyMethod(self.neuron_circle.set_fill, YELLOW, rate_func=there_and_back)\n        return activation\n\n\nclass LayerOfSigmoidNeurons(VGroup):\n    def __init__(self, n_neurons, center, **kwargs):\n        super().__init__(**kwargs)\n        self.neurons = VGroup(*[\n            SigmoidNeuron(position=center + i * RIGHT * 0.5)\n            for i in range(n_neurons)\n        ])\n        self.add(self.neurons)\n\n    def get_layer_activation_animation(self):\n        return AnimationGroup(*[neuron.get_activation_animation() for neuron in self.neurons], lag_ratio=0.1)\n\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        sigmoid_layer = LayerOfSigmoidNeurons(n_neurons=5, center=UP*2)\n        output_neuron = SigmoidNeuron(position=DOWN*2, color=RED, neuron_radius=0.3)\n        self.add(sigmoid_layer, output_neuron)\n\n        # Creating animated edges\n        edges = VGroup()\n        for neuron in sigmoid_layer.neurons:\n            edge = Line(neuron.get_center(), output_neuron.get_center(), buff=0.2, stroke_width=2.0)\n            edges.add(edge)\n        self.add(edges)\n\n        # Animating neurons\n        self.play(sigmoid_layer.get_layer_activation_animation())\n        self.wait(1)\n\n        # Creating animated output edges with color change\n        edges_animation = [\n            ShowPassingFlash(\n                edge.copy().set_color(YELLOW),\n                time_width=0.5,\n                run_time=1\n            ) for edge in edges\n        ]\n        output_activation = output_neuron.get_activation_animation()\n\n        self.play(\n            AnimationGroup(*edges_animation, lag_ratio=0.1),\n            output_activation\n        )\n        self.wait(1)"
  },
  {
    "text": "from manim import *\nimport numpy as np\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        # Manim configuration\n        config.pixel_height = 1080\n        config.pixel_width = 1920\n        config.frame_height = 8.0\n        config.frame_width = 14.0\n\n        # Neural network layers\n        layers = VGroup(\n            Text(\"Input Image\").scale(0.5),\n            Text(\"Conv Layer\").scale(0.5),\n            Text(\"Max Pooling\").scale(0.5),\n            Text(\"ReLU Activation\").scale(0.5),\n            Text(\"Fully Connected\").scale(0.5),\n            Text(\"Output\").scale(0.5),\n        )\n\n        # Arrange layers vertically\n        layers.arrange(DOWN, buff=0.5)\n\n        # Create arrows to show data flow\n        arrows = VGroup(*[\n            Arrow(layers[i].get_bottom(), layers[i+1].get_top(), buff=0.1)\n            for i in range(len(layers) - 1)\n        ])\n\n        # Group layers and arrows\n        network_flow = VGroup(layers, arrows)\n\n        # Position network_flow in the center of the screen\n        network_flow.move_to(ORIGIN)\n\n        # Animate the construction of the neural network diagram\n        self.play(LaggedStartMap(GrowFromCenter, layers), run_time=3)\n        self.play(ShowCreation(arrows), run_time=2)\n        self.wait(2)"
  },
  {
    "text": "from manim import Circle, VGroup, AnimationGroup, FadeIn, FadeOut\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass DropOutScene(Scene):\n    def construct(self):\n        # Create a neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4, neuron_radius=0.2, layer_spacing=0.5),\n            FeedForwardLayer(6, neuron_radius=0.2, layer_spacing=0.5),\n            FeedForwardLayer(4, neuron_radius=0.2, layer_spacing=0.5),\n        ])\n\n        # Position the neural network\n        nn.move_to(ORIGIN)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Create a group of circles simulating dropout\n        dropout_circles = VGroup(*[Circle(radius=0.2).move_to(neuron.get_center())\n                                   for layer in nn.layers[1:-1]\n                                   for neuron in layer.neurons])\n\n        # Create fade in and out animations for each circle\n        animations = [AnimationGroup(FadeIn(circle), FadeOut(circle)) for circle in dropout_circles]\n\n        # Play the animations for dropout effect\n        self.play(*animations, lag_ratio=0.1)\n\n        # Wait before ending the scene\n        self.wait(1)"
  },
  {
    "text": "from manim import *\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass NeuralNetworkArchitecture(Scene):\n    def construct(self):\n        layer_sizes = [4, 8, 8, 4]\n        nn = VGroup()\n        last_layer = None\n        for i, size in enumerate(layer_sizes):\n            layer = VGroup(*[Circle(radius=0.1, stroke_width=2, stroke_color=WHITE, fill_color=BLUE, fill_opacity=0.5) for _ in range(size)])\n            layer.arrange(DOWN, buff=0.2)\n            nn.add(layer)\n            if last_layer:\n                for prev_neuron in last_layer:\n                    for neuron in layer:\n                        nn.add(Line(prev_neuron.get_top(), neuron.get_bottom(), stroke_width=1, stroke_color=GRAY))\n            last_layer = layer\n        nn.arrange(RIGHT, buff=1)\n        self.play(ShowCreation(nn))\n        self.wait(2)\n\n        forward_pass = [layer[0].set_fill(GREEN, opacity=1) for layer in nn]\n        self.play(LaggedStart(*forward_pass, lag_ratio=0.5), run_time=2)\n        self.wait(2)"
  },
  {
    "text": "from manim import Scene, VGroup\nfrom manim_ml.neural_network import NeuralNetwork, FullyConnectedLayer, ReLULayer, SoftmaxLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Create a simple fully connected neural network\n        nn = NeuralNetwork([\n            FullyConnectedLayer(784, 128),\n            ReLULayer(),\n            FullyConnectedLayer(128, 64),\n            ReLULayer(),\n            FullyConnectedLayer(64, 10),\n            SoftmaxLayer()\n        ],\n        layer_spacing=0.35,\n        )\n\n        # Organize the layers vertically in the center\n        nn.arrange(VGroup(*nn.layers), direction=DOWN, center=True)\n        self.add(nn)\n\n        # Play activation animations sequentially through the network\n        activations = nn.make_forward_pass_animation(run_time=2)\n        self.play(activations)\n        self.wait()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, Neuron\nfrom manim_ml.neural_network.layers import RecurrentLayer, FeedForwardLayer\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass RNNVisualization(Scene):\n    def construct(self):\n        neurons_per_layer = [6, 8, 4]\n        layers = []\n        for i, num_neurons in enumerate(neurons_per_layer):\n            if i == 1:  # adding a RecurrentLayer\n                layers.append(RecurrentLayer(num_neurons, radius=0.15))\n            else:\n                layers.append(FeedForwardLayer(num_neurons))\n        rnn = NeuralNetwork(layers, layer_spacing=0.5)\n        \n        rnn.to_edge(LEFT, buff=1)\n        \n        # Decorate neurons with a specific color\n        for neuron in rnn.layers[1].neurons:\n            neuron.set_color(RED)\n            neuron.set_fill(BLUE, opacity=0.5)\n        \n        # Create an RNN label\n        rnn_title = Text(\"Recurrent Neural Network\", font_size=36)\n        rnn_title.to_edge(UP)\n\n        # Adding arrow annotations\n        for layer in rnn.layers:\n            if isinstance(layer, RecurrentLayer):\n                input_arrow = Arrow(ORIGIN, LEFT)\n                input_arrow.next_to(layer.neurons[0], LEFT)\n                output_arrow = Arrow(ORIGIN, RIGHT)\n                output_arrow.next_to(layer.neurons[-1], RIGHT)\n                self.add(input_arrow, output_arrow)\n\n        # Play the scene\n        self.play(FadeIn(rnn_title))\n        self.play(DrawBorderThenFill(rnn))\n        self.wait(2)\n\n        # Animate signal through network\n        self.play(rnn.make_forward_pass_animation(), run_time=3)\n        self.wait(1)"
  },
  {
    "text": "from manim import *\n\nclass Neuron(VGroup):\n    CONFIG = {\n        \"radius\": 0.2,\n        \"fill_color\": BLUE,\n        \"fill_opacity\": 0.8,\n        \"stroke_color\": WHITE,\n        \"stroke_width\": 2,\n    }\n\n    def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.circle = Circle(radius=self.radius,\n                             fill_color=self.fill_color,\n                             fill_opacity=self.fill_opacity,\n                             stroke_color=self.stroke_color,\n                             stroke_width=self.stroke_width)\n        self.add(self.circle)\n        self.axon = None  # Will be used to store output lines\n\n    def add_axon(self, axon):\n        self.axon = axon\n        self.add(axon)\n\n\nclass Layer(VGroup):\n    CONFIG = {\n        \"neurons\": 5,\n        \"neuron_spacing\": 0.5,\n    }\n\n    def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.neurons = VGroup(*[Neuron() for _ in range(self.neurons)])\n        self.neurons.arrange(RIGHT, buff=self.neuron_spacing)\n        self.add(self.neurons)\n\n\nclass NeuralNetworkScene(ThreeDScene):\n    def construct(self):\n        layer_spacing = 1.5\n        layers = VGroup()\n\n        # Create layers of neurons\n        for num_neurons in [4, 5, 3]:\n            layer = Layer(neurons=num_neurons)\n            if layers:\n                layer.next_to(layers[-1], DOWN, buff=layer_spacing)\n            layers.add(layer)\n\n        # Draw axons\n        for i in range(len(layers) - 1):\n            for n1 in layers[i].neurons:\n                for n2 in layers[i + 1].neurons:\n                    n1.add_axon(Line(n1.get_center(), n2.get_center(), buff=0.1))\n\n        # Add the VGroup of Layers to the scene and animate\n        self.add(layers)\n        self.play(ShowCreation(layers))\n\n        # Rotate the neural network\n        self.move_camera(phi=80 * DEGREES, theta=45 * DEGREES)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 10.0\n\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        image_path = \"path/to/your/image.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Define layers for Convolutional Neural Network\n        cnn_layers = [\n            ImageLayer(numpy_image, height=2),\n            ConvolutionalLayer(num_kernels=5, kernel_size=(3, 3), stride=1),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(3)  # Assuming an output of 3 classes\n        ]\n\n        # Initialize Neural Network\n        cnn = NeuralNetwork(cnn_layers, layer_spacing=0.5)\n\n        # Scale and Position the CNN\n        cnn.scale(0.8)\n        cnn.to_edge(UP)\n\n        # Add CNN to the scene\n        self.play(FadeIn(cnn))\n\n        # Animate the forward pass\n        self.play(cnn.make_forward_pass_animation(), run_time=5)\n\n        # Pause to observe the result\n        self.wait(2)\n\n# Run the scene\nscene = CNNVisualizationScene()\nscene.render()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, Neuron, Connection\nfrom manim_ml.neural_network.layers import FeedForwardLayer, LSTMCellLayer\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 8.0\nconfig.frame_width = 8.0\n\nclass RNNSequenceScene(Scene):\n    def construct(self):\n        # Create a sequence of numbers as input\n        sequence = [1, 2, 3, 4, 5]\n        sequence_mob = VGroup(*[MathTex(str(num)) for num in sequence])\n        sequence_mob.arrange_in_grid(rows=1, buff=1)\n        self.play(Write(sequence_mob))\n        \n        # Move the sequence off to the side\n        self.play(sequence_mob.animate.to_edge(UP))\n\n        # Neural Network with LSTM Cells\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(5), # Input layer corresponding to the sequence length\n                LSTMCellLayer(),    # LSTM cell layer\n                FeedForwardLayer(5), # Output layer\n            ],\n            node_spacing=0.1,\n            layer_spacing=0.4\n        )\n        \n        nn.move_to(ORIGIN)\n        self.play(Write(nn))\n        \n        # Play a forward pass animation through the RNN\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n\n        # Isolate a Neuron and show its connections\n        focus_neuron = nn.all_layers[1].neurons[0]\n        connections = VGroup(*[\n            conn for conn in nn.connections\n            if conn.start_node is focus_neuron or conn.end_node is focus_neuron\n        ])\n        self.play(FocusOn(focus_neuron))\n        self.play(LaggedStart(*[ShowCreationThenFadeOut(conn) for conn in connections]))\n\n        # Display the updated sequence after RNN transformation\n        updated_sequence_mob = VGroup(*[MathTex(str(num+5)) for num in sequence])\n        updated_sequence_mob.next_to(nn, DOWN, buff=1)\n        self.play(Transform(sequence_mob, updated_sequence_mob))\n"
  },
  {
    "text": "from manim import Scene, Create\nfrom manim_ml.neural_network import ConvolutionalLayer, PoolingLayer, NeuralNetworkMobject\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        layers = [\n            ConvolutionalLayer(num_feature_maps=6, kernel_shape=(3, 3)),\n            PoolingLayer(),\n            ConvolutionalLayer(num_feature_maps=16, kernel_shape=(3, 3)),\n            PoolingLayer(),\n        ]\n        conv_net = NeuralNetworkMobject(layers=layers)\n        self.play(Create(conv_net))\n        self.wait()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import layers\nfrom manim_ml.neural_network import NeuralNetwork\n\nclass NeuralNetworkSceneV2(Scene):\n    def construct(self):\n        # Define neural network layers\n        network_layers = [\n            layers.InputLayer(4),\n            layers.FullyConnectedLayer(10),\n            layers.ActivationLayer(\"ReLU\"),\n            layers.FullyConnectedLayer(2),\n            layers.ActivationLayer(\"Sigmoid\")\n        ]\n        \n        # Create the neural network object\n        neural_network = NeuralNetwork(network_layers)\n        \n        # Position the network in the center of the scene\n        neural_network.move_to(ORIGIN)\n        \n        # Animate the creation of the neural network\n        self.play(Create(neural_network))\n        \n        # Run forward propagation animation with activation visualized\n        forward_prop_anim = neural_network.get_forward_pass_animation(\n            layer_time=2, activation_time=1, show_activations=True\n        )\n        \n        self.wait(1)\n        self.play(forward_prop_anim)\n        self.wait(2)"
  },
  {
    "text": "from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, RNNLayer\n\nclass RNNVisualization(Scene):\n    def construct(self):\n        rnn = NeuralNetwork([\n            RNNLayer(5, 3, activation_function=\"tanh\"),\n            FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n        ],\n        layer_spacing=0.4,\n        neural_network_spacing=0.5\n        )\n        self.add(rnn)\n        rnn_update = rnn.make_forward_pass_animation()\n        self.play(Create(rnn_update))"
  },
  {
    "text": "from manim import Scene, VGroup, RIGHT\nfrom manim_ml.neural_network import LinearLayer, ActivationLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            LinearLayer(4, 6),\n            ActivationLayer('ReLU'),\n            LinearLayer(6, 4),\n            ActivationLayer('ReLU'),\n            LinearLayer(4, 1),\n            ActivationLayer('Sigmoid')\n        )\n\n        layers.arrange(RIGHT, buff=0.5)\n        self.add(layers)\n\n        forward_pass = layers.make_forward_pass_animation()\n        self.play(forward_pass)\n        self.wait(2)"
  },
  {
    "text": "```python\nfrom manim import *\n\nclass NeocognitronScene(ThreeDScene):\n    def construct(self):\n        num_neurons = [3, 4, 2]  # Define the number of neurons in each layer\n\n        layers = VGroup()  # Group to hold all layers\n\n        # Iterate over each layer and create the neurons\n        for i, num in enumerate(num_neurons):\n            layer = VGroup()\n            for n in range(num):\n                neuron = Sphere(radius=0.2, resolution=(20, 20))\n                neuron.set_color(BLUE)\n                if layer.submobjects:\n                    neuron.next_to(layer[-1], DOWN, buff=0.5)\n                layer.add(neuron)\n            layers.add(layer)\n\n        # Align layers from left to right\n        layers.arrange(RIGHT, buff=1.0)\n\n        # Draw edges between neurons in adjacent layers\n        edges = VGroup()\n        for i in range(len(num_neurons) - 1):\n            for n_prev in layers[i]:\n                for n_next in layers[i + 1]:\n                    edge = Line(n_prev.get_center(), n_next.get_center(), buff=0.2)\n                    edge.set_stroke(BLACK, 1.5)\n                    edges.add(edge)\n\n        # Create the self-contained neural network group\n        neural_network = VGroup(layers, edges)\n\n        neural_network.move_to(ORIGIN)  # Center the network\n        self.add(neural_network)  # Add network to the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)  # Adjust camera\n\n```\n"
  },
  {
    "text": "from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Connection\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Defining a custom neural network with two hidden layers.\n        layers = [\n            FeedForwardLayer(num_nodes=4, label=\"Input\"),\n            FeedForwardLayer(num_nodes=6, label=\"Hidden1\"),\n            FeedForwardLayer(num_nodes=6, label=\"Hidden2\"),\n            FeedForwardLayer(num_nodes=2, label=\"Output\")\n        ]\n\n        # Creating the neural network.\n        custom_nn = NeuralNetwork(layers)\n\n        # Adding connections that represent weights.\n        weights = [\n            Connection(layers[0], layers[1]),\n            Connection(layers[1], layers[2]),\n            Connection(layers[2], layers[3])\n        ]\n\n        # Adding the neural network to the Scene.\n        self.add(custom_nn)\n        for weight in weights:\n            self.add(weight)\n\n        # Animating the neural network creation.\n        self.play(Create(custom_nn))\n        for weight in weights:\n            self.play(Create(weight))"
  },
  {
    "text": "from manim import Scene, VGroup, BLUE, RED\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations.training import Train\n\nclass NeuralNetworkTrainScene(Scene):\n    def construct(self):\n        # Create a neural network\n        layers = [FeedForwardLayer(n) for n in [3, 5, 4, 2]]\n        neural_network = NeuralNetwork(layers)\n        neural_network.set_colors(input_color=BLUE, output_color=RED)\n        neural_network.move_to(ORIGIN)\n\n        # Group layers for easy transformation\n        vg_layers = VGroup(*[layer for layer in neural_network.layers])\n\n        # Add network to scene\n        self.add(vg_layers)\n\n        # Create training animation\n        train_anim = Train(neural_network)\n\n        self.play(train_anim)\n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, PoolingLayer, FullyConnectedLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Define the structure of the Convolutional Neural Network\n        cnn = NeuralNetwork([\n            ConvolutionalLayer(feature_maps=1, kernel_size=(3, 3), input_shape=(28, 28, 1)),\n            PoolingLayer(pool_size=(2, 2)),\n            ConvolutionalLayer(feature_maps=3, kernel_size=(3, 3)),\n            PoolingLayer(pool_size=(2, 2)),\n            FullyConnectedLayer(units=120),\n            FullyConnectedLayer(units=84),\n            FullyConnectedLayer(units=10, activation='softmax')\n        ], layer_spacing=0.2, neural_network_type='CNN')\n\n        cnn.scale(0.5)\n        cnn.move_to(ORIGIN)\n\n        # Animate the construction and forward pass of the CNN\n        self.play(AnimationGroup(\n            Create(cnn),\n            cnn.make_forward_pass_animation(),\n            lag_ratio=0.1,\n            run_time=4\n        ))\n\n        # Hold the final scene\n        self.wait(2)"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define layers\n        layers = VGroup(*[Rectangle(height=0.1, width=2) for _ in range(4)])\n        layers.arrange(DOWN, buff=0.5)\n\n        # Add Text for each layer\n        layer_labels = VGroup(*[\n            Text(f\"Layer {i+1}\", size=0.5).move_to(layers[i])\n            for i in range(4)\n        ])\n\n        # Group layers with labels\n        neural_network = VGroup(layers, layer_labels)\n\n        # Position the entire network\n        neural_network.move_to(ORIGIN)\n\n        # Connections between layers\n        connections = VGroup()\n        for i in range(len(layers) - 1):\n            conn = Arrow(\n                layers[i].get_bottom(),\n                layers[i+1].get_top(), \n                buff=0.1\n            )\n            connections.add(conn)\n\n        # Group everything\n        complete_network = VGroup(neural_network, connections)\n\n        # Add everything to the scene\n        self.add(complete_network)\n\n        # Animate the neural network\n        self.play(FadeIn(neural_network), GrowArrow(connections))\n        self.wait(2)\n\n        # Animate activation\n        activation = Rectangle(height=0.1, width=2, fill_color=BLUE, fill_opacity=0.8)\n        activations = VGroup()\n        for layer in layers:\n            activation_copy = activation.copy().move_to(layer)\n            activations.add(activation_copy)\n\n        self.play(LaggedStart(*[FadeIn(a) for a in activations], lag_ratio=0.5))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom random import uniform\n\nclass ReceptiveField(VGroup):\n    def __init__(self, center_cell, cells, radius=0.5, **kwargs):\n        super().__init__(**kwargs)\n        self.center_cell = center_cell\n        self.cells = cells\n        self.radius = radius\n        self.circle = Circle(\n            radius=self.radius,\n            color=WHITE\n        )\n        self.circle.move_to(self.center_cell.get_center())\n        self.add(self.circle)\n        self.lines = VGroup()\n        for cell in self.cells:\n            line = Line(\n                start=self.center_cell.get_center(),\n                end=cell.get_center(),\n                stroke_width=1.5,\n                color=WHITE\n            )\n            self.lines.add(line)\n            self.add(line)\n\n    def highlight(self, color=YELLOW):\n        self.circle.set_color(color)\n        for line in self.lines:\n            line.set_color(color)\n\n    def reset_color(self):\n        self.highlight(WHITE)\n\nclass VisualCortexLayer(VGroup):\n    CONFIG = {\n        \"neuron_radius\": 0.2,\n        \"neuron_spacing\": 0.6,\n        \"neuron_color\": BLUE,\n        \"layer_name\": \"Layer\",\n    }\n\n    def __init__(self, n_neurons, **kwargs):\n        super().__init__(**kwargs)\n        self.n_neurons = n_neurons\n        self.neurons = VGroup()\n\n        for i in range(n_neurons):\n            neuron = Circle(\n                radius=self.neuron_radius,\n                color=self.neuron_color,\n                fill_opacity=0.5\n            )\n            neuron.move_to(i * self.neuron_spacing * RIGHT)\n            self.neurons.add(neuron)\n\n        self.add(self.neurons)\n        self.layer_label = Text(self.layer_name, font_size=24)\n        self.layer_label.next_to(self.neurons, UP, buff=0.1)\n        self.add(self.layer_label)\n\n    def get_neurons(self):\n        return self.neurons\n\nclass ConnectionPattern(VGroup):\n    CONFIG = {\n        \"pattern_color\": RED,\n    }\n\n    def __init__(self, layer1, layer2, **kwargs):\n        super().__init__(**kwargs)\n        self.layer1 = layer1\n        self.layer2 = layer2\n        self.receptive_fields = VGroup()\n\n        for neuron in layer1.get_neurons():\n            connected_neurons = self.select_connected_neurons(layer2)\n            receptive_field = ReceptiveField(\n                center_cell=neuron,\n                cells=connected_neurons,\n                radius=uniform(0.3, 0.5)\n            )\n            self.receptive_fields.add(receptive_field)\n        self.add(self.receptive_fields)\n\n    def select_connected_neurons(self, layer, n_connections=3):\n        return random.sample(layer.get_neurons(), n_connections)\n\nclass VisualCortexNetwork(VGroup):\n    CONFIG = {\n        \"n_layers\": 4,\n    }\n\n    def __init__(self, neurons_per_layer, **kwargs):\n        super().__init__(**kwargs)\n        self.layers = []\n        self.connections = VGroup()\n        prev_layer = None\n\n        for i, n_neurons in enumerate(neurons_per_layer):\n            layer = VisualCortexLayer(\n                n_neurons,\n                layer_name=f\"Layer {i+1}\"\n            )\n            self.layers.append(layer)\n            if prev_layer is not None:\n                connection = ConnectionPattern(prev_layer, layer)\n                self.connections.add(connection)\n            layer.shift(i * DOWN)\n            prev_layer = layer\n        \n        self.add(*self.layers, self.connections)\n\nclass VisualSystemScene(Scene):\n    def construct(self):\n        layers = [5, 4, 6, 3]\n        visual_cortex = VisualCortexNetwork(layers)\n        self.add(visual_cortex)\n\n        # Show the receptive fields connections pulsing through layers\n        for conn in visual_cortex.connections:\n            self.play(LaggedStart(*[\n                ApplyMethod(rf.highlight, YELLOW)\n                for rf in conn.receptive_fields\n            ], lag_ratio=0.2, run_time=1))\n            self.play(LaggedStart(*[\n                ApplyMethod(rf.reset_color)\n                for rf in conn.receptive_fields\n            ], lag_ratio=0.2, run_time=1))\n\n        # Shift the whole network downwards\n        self.play(ApplyMethod(visual_cortex.shift, DOWN))\n\n        # Add some labels\n        input_label = Text(\"Input Layer\", font_size=24)\n        input_label.next_to(visual_cortex.layers[0], LEFT)\n        output_label = Text(\"Output Layer\", font_size=24)\n        output_label.next_to(visual_cortex.layers[-1], LEFT)\n        self.play(Write(input_label), Write(output_label))"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = VGroup()\n        layers = [Rectangle(height=0.5, width=2) for _ in range(4)]\n        layers_labels = [Tex(f\"Layer {_ + 1}\") for _ in range(4)]\n        \n        # Position layers and add labels\n        for i, (layer, label) in enumerate(zip(layers, layers_labels)):\n            layer.next_to(3 * UP if i == 0 else layers[i - 1], DOWN, buff=1)\n            label.move_to(layer.get_center())\n            nn.add(layer, label)\n        \n        # Draw connections\n        for layer1, layer2 in zip(layers, layers[1:]):\n            nn.add(Arrow(layer1.get_bottom(), layer2.get_top(), buff=0.1))\n        \n        # Position the neural network in the center\n        nn.move_to(ORIGIN)\n        \n        # Animate construction of the neural network\n        self.play(AnimationGroup(*(FadeIn(layer) for layer in layers), lag_ratio=0.5))\n        self.play(AnimationGroup(*(Write(label) for label in layers_labels), lag_ratio=0.5))\n        self.play(AnimationGroup(*(GrowArrow(arrow) for arrow in nn.submobjects if isinstance(arrow, Arrow)), lag_ratio=0.5))"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers import Convolutional2DLayer, FlattenLayer, FeedForwardLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Create a neural network architecture\n        neural_network = NeuralNetwork(\n            layers=[\n                Convolutional2DLayer(num_feature_maps=8, feature_map_size=4),\n                Convolutional2DLayer(num_feature_maps=16, feature_map_size=2),\n                FlattenLayer(),\n                FeedForwardLayer(128),\n                FeedForwardLayer(64),\n                FeedForwardLayer(10),\n            ],\n            layer_spacing=0.3,\n            neural_network_position=UP\n        )\n\n        # Add the neural network to the scene\n        self.add(neural_network)\n\n        # Animate the neural network layers\n        self.play(*[GrowFromCenter(layer) for layer in neural_network.layers])\n\n        # Perform and animate the forward propagation through the network\n        forward_pass_animations = neural_network.forward_pass_animation()\n        self.play(AnimationGroup(*forward_pass_animations, lag_ratio=0.1))\n        \n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom PIL import Image\nimport numpy as np\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Load an image to use as input\n        image_path = \"path/to/your/image.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Create layers for the neural network\n        layers = VGroup(\n            ImageMobject(image).scale(0.5),\n            RoundedRectangle(corner_radius=0.2).scale(0.2),\n            RoundedRectangle(corner_radius=0.2).scale(0.5).set_fill(ORANGE, opacity=0.5),\n            RoundedRectangle(corner_radius=0.2).scale(0.3).set_fill(GREEN, opacity=0.8),\n        )\n\n        # Position the layers of the neural network\n        layers.arrange(DOWN, buff=0.5)\n\n        # Label the layers\n        labels = VGroup(\n            Text(\"Input Image\", font_size=24),\n            Text(\"Conv Layer\", font_size=24),\n            Text(\"ReLU Activation\", font_size=24),\n            Text(\"Output Layer\", font_size=24),\n        )\n\n        # Align labels with layers\n        for label, layer in zip(labels, layers):\n            label.next_to(layer, UP)\n\n        # Create a group with layers and labels\n        neural_network_group = VGroup(layers, labels).move_to(ORIGIN)\n\n        # Animate the creation of the neural network\n        self.play(\n            *[FadeIn(layer) for layer in layers],\n            *[Write(label) for label in labels],\n            run_time=2\n        )\n\n        self.wait(1)\n\n        # Illustrate data flowing through the network\n        flow_data = Circle(radius=0.1, color=YELLOW).move_to(layers[0].get_bottom())\n        self.play(flow_data.move_to, layers[1].get_top())\n        self.wait(0.5)\n        self.play(flow_data.move_to, layers[2].get_top())\n        self.wait(0.5)\n        self.play(flow_data.move_to, layers[3].get_top())\n\n        self.wait(2)"
  },
  {
    "text": "from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass FeedForwardNetworkScene(Scene):\n    def construct(self):\n        # Create a feedforward neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4, activation_function=\"ReLU\"),\n            FeedForwardLayer(8, activation_function=\"ReLU\"),\n            FeedForwardLayer(2, activation_function=\"Sigmoid\"),\n        ], layer_spacing=0.35)\n\n        # Add the neural network to the scene\n        self.add(nn)\n        \n        # Animate the forward pass through the neural network\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
  },
  {
    "text": "from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            Rectangle(width=2, height=1, color=BLUE),\n            Rectangle(width=2, height=1, color=GREEN),\n            Rectangle(width=2, height=1, color=RED),\n        )\n        layers.arrange(RIGHT, buff=1)\n\n        arrows = VGroup(\n            Arrow(start=layers[0].get_right(), end=layers[1].get_left(), buff=0.1),\n            Arrow(start=layers[1].get_right(), end=layers[2].get_left(), buff=0.1),\n        )\n\n        neural_network = VGroup(layers, arrows)\n\n        self.play(ShowCreation(neural_network))\n        self.wait()\n\n        activation_text = Text(\"Activation Function: ReLU\", font_size=24)\n        activation_text.next_to(layers[2], DOWN)\n\n        self.play(Write(activation_text))\n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetworkMobject\n\n\nclass NeuralNetworkMobjectScene(Scene):\n    \"\"\"Scene for demonstrating a Neural Network Mobject\"\"\"\n\n    def construct(self):\n        # Define the number of neurons in each layer\n        layers_sizes = [4, 7, 4, 2]\n\n        # Create the Neural network object\n        neural_network = NeuralNetworkMobject(layers_sizes)\n        neural_network.scale(1.5)\n        neural_network.to_edge(UP)\n\n        # Add neural network to the scene\n        self.add(neural_network)\n\n        # Animate the neural network with forward propagation\n        self.play(neural_network.forward_propagate())\n\n        # Show the initial state and the propagation\n        self.wait(2)"
  },
  {
    "text": "from manim import *_x000D_\nfrom manim_ml.neural_network import NeuralNetwork_x000D_\nfrom manim_ml.neural_network.layers import FeedForwardLayer, Convolutional2DLayer_x000D_\nfrom manim_ml.utils import generate_random_image_x000D_\n_x000D_\n# Set the configuration for the scene_x000D_\nconfig.pixel_height = 1080_x000D_\nconfig.pixel_width = 1920_x000D_\nconfig.frame_height = 8.0_x000D_\nconfig.frame_width = 14.0_x000D_\n_x000D_\nclass CNNRepresentationScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Generate a random RGB image_x000D_\n        input_image = generate_random_image(height=28, width=28, channels=3)_x000D_\n_x000D_\n        # Neural Network Architecture_x000D_\n        neural_network = NeuralNetwork([_x000D_\n            # Convert the image to grayscale and show it as the first layer_x000D_\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=28, filter_size=1),_x000D_\n            # First Convolutional layer_x000D_\n            Convolutional2DLayer(num_feature_maps=16, feature_map_size=28, filter_size=3),_x000D_\n            # Second Convolutional layer_x000D_\n            Convolutional2DLayer(num_feature_maps=32, feature_map_size=14, filter_size=3),_x000D_\n            # Fully Connected layer_x000D_\n            FeedForwardLayer(128),_x000D_\n            # Output layer_x000D_\n            FeedForwardLayer(10)_x000D_\n        ],_x000D_\n        input_image_shape=input_image.shape,_x000D_\n        layer_spacing=0.2,_x000D_\n        layer_buff=1)_x000D_\n_x000D_\n        # Add neural network to the scene_x000D_\n        self.add(neural_network)_x000D_\n_x000D_\n        # Animate the forward pass of the neural network_x000D_\n        self.play(neural_network.create_forward_pass_animation(), run_time=10)_x000D_\n        self.wait()"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            Convolutional2DLayer(1, 16, 5, filter_spacing=0.3),\n            Convolutional2DLayer(16, 32, 3, filter_spacing=0.3),\n            Convolutional2DLayer(32, 64, 3, filter_spacing=0.3),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(10),\n        ],\n        layer_spacing=0.35,\n        )\n\n        nn.move_to(ORIGIN)\n        self.add(nn)\n\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n        self.wait()"
  },
  {
    "text": "from manim import *\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nclass MnistNeuralNetworkScene(Scene):\n    def construct(self):\n        # Load image and convert it to numpy array\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.png\")  # To use another image file\n        numpy_image = np.array(image.convert(\"L\"))  # Convert image to grayscale\n\n        # Create a neural network\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            MaxPooling2DLayer(pool_size=2, pad=True),\n            FeedForwardLayer(6),\n            FeedForwardLayer(10),\n        ], layer_spacing=0.3)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Animate the forward pass of nn\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass, run_time=10)\n\n        # Wait a moment before closing the scene\n        self.wait(2)"
  },
  {
    "text": "from manim import *\nfrom manim_ml.neural_network import FullyConnectedLayer, NeuralNetwork\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define neural network architecture\n        nn = NeuralNetwork(\n            {\n                \"input\": FullyConnectedLayer(784, 16),\n                \"hidden1\": FullyConnectedLayer(16, 32, activation_function=ReLU()),\n                \"hidden2\": FullyConnectedLayer(32, 16, activation_function=ReLU()),\n                \"output\": FullyConnectedLayer(16, 10, activation_function=Softmax())\n            },\n            layer_spacing=1\n        )\n\n        # Add skip connections\n        nn.add_connection(\"input\", \"hidden2\")\n        nn.add_connection(\"hidden1\", \"output\")\n\n        # Positioning the neural network on the screen\n        nn.move_to(ORIGIN)\n\n        # Animate the construction of the neural network\n        self.play(Create(nn), run_time=2)\n\n        # Animate the forward pass of the neural network\n        forward_pass = nn.make_forward_pass_animation(\n            input_vector=np.random.rand(784),\n            show_propagation=True\n        )\n        self.play(forward_pass, run_time=4)\n\n        # Highlight the output layer\n        output_layer = nn.get_layer(\"output\")\n        self.play(output_layer.animate.set_fill(YELLOW, opacity=0.5), run_time=1)\n\n        self.wait(2)"
  },
  {
    "text": "from manim import Scene, VGroup_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\nfrom manim_ml.neural_network.animations.dropout import DropoutAnimation_x000D_\n_x000D_\nclass DropoutScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Create a neural network_x000D_\n        nn = NeuralNetwork([_x000D_\n            FeedForwardLayer(4),_x000D_\n            FeedForwardLayer(6),_x000D_\n            FeedForwardLayer(6),_x000D_\n            FeedForwardLayer(3),_x000D_\n        ], layer_spacing=0.5)_x000D_\n        _x000D_\n        # Position the neural network in the center_x000D_\n        nn.move_to(ORIGIN)_x000D_\n_x000D_\n        # Create a group to hold our animations_x000D_\n        animations = VGroup()_x000D_\n        _x000D_\n        # Create a dropout animation for each layer of the neural network_x000D_\n        for layer in nn.layers[1:]:  # Skip the input layer_x000D_\n            animations.add(DropoutAnimation(layer, p=0.2))_x000D_\n_x000D_\n        # Add the neural network to the scene_x000D_\n        self.add(nn)_x000D_\n_x000D_\n        # Play the dropout animations_x000D_\n        self.play(*animations)_x000D_\n        _x000D_\n        # End the scene_x000D_\n        self.wait(2)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            text = Text(\"Animations\").shift(UP*2.5)\n            self.play(Write(text))\n            self.wait(1)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Create\").shift(UP*2.5)), run_time=0.5)\n            start = Star()\n            self.play(Create(start))\n            self.play(Transform(text,Text(\"Uncreate\").shift(UP*2.5)), run_time=0.5)\n            self.play(Uncreate(start))"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n            self.add(circle, animated_boundary)\n            self.wait(2)\n            self.remove(circle, animated_boundary)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TracedPath\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot(color=RED)\n            trace = TracedPath(dot.get_center)\n            self.add(dot, trace)\n            self.wait(0.5)\n            self.play(dot.animate.shift(UP), run_time=0.5)\n            self.play(dot.animate.shift(LEFT), run_time=0.5)\n            self.play(dot.animate.shift(DOWN+RIGHT), run_time=0.5)\n            self.remove(dot, trace)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AddTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is a text\")\n            self.play(AddTextLetterByLetter(some_text))\n            self.play(Transform(text,Text(\"RemoveTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n            self.play(RemoveTextLetterByLetter(some_text))"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is more text\")\n            self.play(Write(some_text))\n            self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n            self.play(Unwrite(some_text))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"DrawBorderThenFill\").shift(UP*2.5)), run_time=0.5)\n            square = Square(color=BLUE, fill_opacity=1).set_fill(YELLOW)\n            self.play(DrawBorderThenFill(square))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowIncreasingSubsets\").shift(UP*2.5)), run_time=0.5)\n            circles = VGroup(\n                Circle().shift(UP*0.5),\n                Circle().shift((DOWN+LEFT)*0.5),\n                Circle().shift((DOWN+RIGHT)*0.5)\n            )\n            self.play(ShowIncreasingSubsets(circles))\n            self.wait()\n            self.remove(circles)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowSubmobjectsOneByOne\").shift(UP*2.5)), run_time=0.5)\n            circles2 = VGroup(\n                Circle().shift(UP*0.5),\n                Circle().shift((DOWN+LEFT)*0.5),\n                Circle().shift((DOWN+RIGHT)*0.5)\n            )\n            self.play(ShowSubmobjectsOneByOne(circles2))\n            self.play(Uncreate(circles2))"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(FadeIn(square))\n            self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n            self.play(FadeOut(square))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n            arrow = Arrow()\n            self.play(GrowArrow(arrow))\n            self.remove(arrow)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(GrowFromCenter(triangle))\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromEdge - DOWN\").shift(UP*2.5)), run_time=0.5)\n            squares = [Square() for _ in range(4)]\n            self.play(GrowFromEdge(squares[0], DOWN))\n            self.play(Transform(text,Text(\"GrowFromEdge - RIGHT\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[1], RIGHT))\n            self.play(Transform(text,Text(\"GrowFromEdge - UP\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[2], UP))\n            self.play(Transform(text,Text(\"GrowFromEdge - LEFT\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[3], LEFT))\n            self.remove(*squares)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromPoint\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift(UP+RIGHT*2)\n            star = Star()\n            self.add(dot)\n            self.wait(0.5)\n            self.play(GrowFromPoint(star, dot))\n            self.remove(dot, star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"SpinInFromNothing\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(SpinInFromNothing(triangle))\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Mathematical Animations\")\n            self.play(ApplyWave(some_text))\n            self.play(ApplyWave(some_text, direction=RIGHT))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Circumscribe\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Look Here\")\n            self.add(some_text)\n            self.play(Circumscribe(some_text))\n            self.play(Circumscribe(some_text, Circle))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Flash\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Ta Da\").set_color(YELLOW)\n            self.add(some_text)\n            self.play(Flash(some_text))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FocusOn\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here!\")\n            self.add(some_text)\n            self.play(FocusOn(some_text))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Indicate\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"This is important\")\n            self.play(Indicate(some_text))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Wiggle\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"THIS\")\n            self.play(Wiggle(some_text))\n            self.remove(some_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowPassingFlash\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShowPassingFlash(square))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowPassingFlashWithThinningStrokeWidth\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShowPassingFlashWithThinningStrokeWidth(square))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveAlongPath\").shift(UP*2.5)), run_time=0.5)\n            l1 = Line(LEFT+DOWN, RIGHT+UP)\n            self.add(l1)\n            d1 = Dot().shift(LEFT+DOWN)\n            self.play(Create(d1), run_time=0.5)\n            self.play(MoveAlongPath(d1, l1), rate_func=linear)\n            self.remove(l1,d1)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Rotate\").shift(UP*2.5)), run_time=0.5)\n            star = Star()\n            self.play(Rotate(star))\n            self.wait(0.5)\n            self.remove(star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Rotating\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(Rotating(square))\n            self.wait(0.5)\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Broadcast\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(Broadcast(triangle))\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ChangeSpeed\").shift(UP*2.5)), run_time=0.5)\n            d = Dot().shift(LEFT)\n            self.play(ChangeSpeed(d.animate.shift(RIGHT*2), speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1}, rate_func=linear))\n            self.remove(d)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Transform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(Transform(square,star))\n            self.remove(square,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ClockwiseTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(ClockwiseTransform(square,star))\n            self.remove(square,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"CounterclockwiseTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(CounterclockwiseTransform(square,star))\n            self.remove(square,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"CyclicReplace\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            circle = Circle()\n            triangle = Triangle()\n            vg = VGroup(square,star,circle,triangle)\n            vg.arrange(RIGHT)\n            self.play(CyclicReplace(*vg))\n            self.wait()\n            self.remove(square,star,circle,triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeToColor\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.play(FadeToColor(square,color=YELLOW))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(BLUE)\n            star = Star(fill_opacity=1).set_fill(YELLOW)\n            self.play(FadeTransform(square,star))\n            self.remove(square,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveToTarget\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            circle.generate_target()\n            circle.move_to(RIGHT)\n            self.play(MoveToTarget(circle))\n            self.remove(circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ReplacementTransform\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            square = Square().shift(RIGHT)\n            self.play(ReplacementTransform(circle,square))\n            self.remove(circle,square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Restore\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            square = Square(fill_opacity=1).set_fill(RED).shift(DOWN+RIGHT)\n            self.play(Create(circle), run_time=0.5)\n            circle.save_state()\n            self.wait(0.5)\n            self.play(Transform(circle,square), run_time=0.3)\n            self.play(circle.animate.shift(RIGHT), run_time=0.3)\n            self.play(circle.animate.rotate(0.5), run_time=0.4)\n            self.wait(0.5)\n            self.play(Restore(circle))\n            self.wait(0.2)\n            self.remove(circle,square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ScaleInPlace\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ScaleInPlace(square, scale_factor=2))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShrinkToCenter\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShrinkToCenter(square))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TransformMatchingShapes\").shift(UP*2.5)), run_time=0.5)\n            source_text = Text(\"tom marvolo riddle\")\n            dest_text = Text(\"lord voldemort\")\n            self.play(Write(source_text))\n            self.wait(0.5)\n            self.play(TransformMatchingShapes(source_text, dest_text, path_arc=PI/2))\n            self.wait(0.5)\n            self.remove(source_text,dest_text)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TransformMatchingTex\").shift(UP*2.5)), run_time=0.5)\n            eq1 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n            eq2 = MathTex(\"{{a}}^2\", \"+\", \"-{{c}}^2\", \"=\", \"-{{b}}^2\")\n            self.add(eq1)\n            self.wait(0.5)\n            self.play(TransformMatchingTex(eq1, eq2, path_arc=PI/2))\n            self.wait(0.5)\n            self.remove(eq1,eq2)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.shift\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.shift(UP), run_time=0.5)\n            self.play(circle.animate.shift(DOWN), run_time=0.5)\n            self.play(circle.animate.shift(LEFT), run_time=0.5)\n            self.play(circle.animate.shift(RIGHT), run_time=0.5)\n            self.remove(circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_fill\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.play(square.animate.set_fill(RED))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle(fill_opacity=1)\n            self.play(triangle.animate.rotate(PI))\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale(scale_factor=1.5))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate_about_origin\").shift(UP*2.5)), run_time=0.5)\n            star = Star().shift(RIGHT*2)\n            self.play(star.animate.rotate_about_origin(PI))\n            self.remove(star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(triangle.animate.rotate(PI))\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.flip\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(triangle.animate.flip())\n            self.remove(triangle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.stretch(2,1))\n            self.remove(circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.wag\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.wag())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.pose_at_angle\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.pose_at_angle())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.center\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.center())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.align_on_border\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.align_on_border(direction=np.array([0,1,0])))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.to_corner\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.to_corner())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.to_edge\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.to_edge())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.next_to\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((RIGHT+UP)*2)\n            square = Square().shift(LEFT*2)\n            self.add(dot)\n            self.play(square.animate.next_to(dot))\n            self.remove(square,dot)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_width(5))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.stretch_to_fit_width(5))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_height(3))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.stretch_to_fit_height(3))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_coord\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_coord(-1,0))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_x\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_x(-1))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_y\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_y(-1))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.space_out_submobjects\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            star = Star()\n            circle.add(star)\n            self.play(circle.animate.space_out_submobjects(factor=2))\n            self.remove(circle,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.move_to\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.move_to(RIGHT+UP))\n            self.remove(circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.replace\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            star = Star().shift(RIGHT)\n            self.add(circle, star)\n            self.play(circle.animate.replace(star))\n            self.remove(circle,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.surround\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            star = Star().shift(RIGHT)\n            self.add(circle,star)\n            self.play(circle.animate.surround(star))\n            self.remove(circle,star)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.add_background_rectangle\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.add(square)\n            self.play(square.animate.add_background_rectangle())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color(BLUE))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color_by_gradient\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color_by_gradient(RED,BLUE,YELLOW))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.fade_to\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.add(square)\n            self.play(square.animate.fade_to(GREEN, 0.5))\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.fade\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.add(square)\n            self.play(square.animate.fade())\n            self.remove(square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_color\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle(fill_opacity=1).set_fill(RED).shift(LEFT*2)\n            square = Square(fill_opacity=1).shift(RIGHT*2)\n            self.add(circle)\n            self.play(Create(square))\n            self.play(square.animate.match_color(circle))\n            self.remove(square,circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_dim_size\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_dim_size(circle, 0))\n            self.remove(square,circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_width\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_width(circle))\n            self.remove(square,circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_height\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_height(circle))\n            self.remove(square,circle)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_x\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_x(dot))\n            self.remove(star,dot)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_y\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_y(dot))\n            self.remove(star,dot)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.arrange\").shift(UP*2.5)), run_time=0.5)\n            t1 = Text(\"3\").shift(LEFT)\n            t2 = Text(\"1\")\n            t3 = Text(\"2\").shift(RIGHT)\n            vg = VGroup(t2,t3,t1)\n            self.add(t2,t3,t1)\n            self.wait(0.5)\n            self.play(vg.animate.arrange(buff=1.0))\n            self.remove(t1,t2,t3)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.arrange_in_grid\").shift(UP*2.5)), run_time=0.5)\n            boxes=VGroup(*[Square().scale(0.5) for s in range(0,6)])\n            boxes.arrange(buff=1.0)\n            self.add(*boxes)\n            self.wait(0.5)\n            self.play(boxes.animate.arrange_in_grid(rows=2, buff=0.5))\n            self.remove(*boxes)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.become\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.become(square))\n            self.remove(circ,square)"
  },
  {
    "text": "class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_points\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)\n            self.play(FadeOut(circ),FadeOut(square))"
  }
]
